CVE_ID,TARGET_CHECK_STRING
CVE-2020-13598,The fixing pattern involves implementing proper bounds checking before copying data into the buffer. This can be achieved by using safer string handling functions that limit the number of characters copied, ensuring that the buffer is not overflowed. Additionally, the code should handle cases where the filename exceeds the maximum length gracefully, returning an appropriate error code.
CVE-2020-10023,The fixing pattern involves correcting the parameters passed to the 'memmove' function to ensure that the correct length of data is moved, thus preventing buffer overflow. The adjustment ensures that the memory being accessed is within the bounds of the allocated buffer.
CVE-2023-4263,The fixing pattern involves adding a validation check for the payload length before copying the data into the buffer. If the payload length exceeds a predefined maximum size (IEEE802154_MTU), an error is logged, and the function returns an error code instead of proceeding with the copy operation. This prevents the buffer overflow by ensuring that only valid payload sizes are processed.
CVE-2017-14199,The fixing pattern involves adding a bounds check to ensure that 'state->idx' does not exceed the size of the 'ai_arr' array before it is used to access the array. If the index is out of bounds, an error message is logged, and the function returns early to prevent further execution.
CVE-2017-14201,The fixing pattern involves removing the use of a user data structure that could lead to a use-after-free condition. Instead, the shell pointer is passed directly as user data to the callback function. This eliminates the need for managing additional state through a separate structure, thereby reducing the risk of accessing freed memory.
CVE-2017-14202,The fixing pattern involves redefining the memory allocation for shell history items to ensure that the size of the allocated memory accounts for the actual length of the command data. The updated code uses a macro to round up the size of the shell history item, preventing buffer overflows by dynamically adjusting the size based on the command length.
CVE-2020-10022,The fixing pattern involves increasing the buffer size for receiving payloads and ensuring that the size of the received data is validated against the buffer's capacity. The code now checks if the size of the incoming payload exceeds the allocated buffer size before processing it, thus preventing buffer overflows. Additionally, the code has been updated to use a more appropriate size for device identity and firmware version buffers, ensuring that they can accommodate the expected data without overflow.
CVE-2025-1675,The fixing pattern involves modifying the condition that checks the size of the destination buffer to also consider the size of the source buffer. By using the `MIN` function to compare the remaining size of the destination buffer with the size of the source buffer, the fix ensures that the `memcpy` operation does not attempt to read beyond the bounds of the source buffer.
CVE-2025-2962,The fix introduces two key mechanisms:Proper compression pointer detection by checking the top two bits (mask 0xC0) equal to 0xC0.Loop prevention by tracking the target of the last jump and ensuring each subsequent jump target is strictly less than the previous one (i.e., pointers must only move backward in the message, as per RFC 1035). Additionally, a loop counter is added as a safety measure. The fix may involve refactoring to merge logic with `dns_unpack_name` for consistent security analysis.