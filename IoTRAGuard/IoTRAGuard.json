[
  {
    "id": "VULN-000001",
    "vulnerability": "A buffer overflow has been found in the Zephyr Project's getaddrinfo() implementation in 1.9.0 and 1.10.0.",
    "affected_functions": [
      "getaddrinfo()"
    ],
    "functionality": "getaddrinfo() provides protocol-independent translation from host and service names to socket addresses.",
    "call_patterns": [
      {
        "pattern": "<global>(subsys/net/lib/sockets/getaddrinfo.c)",
        "description": "Vulnerable call chain leading to dns_resolve_cb (version: v1.10.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v1.11.0 or above.",
      "code_snippet": "static void dns_resolve_cb(enum dns_resolve_status status, struct dns_addrinfo *info, void *user_data) {\n    struct getaddrinfo_state *state = user_data;\n    struct zsock_addrinfo *ai;\n    int socktype = SOCK_STREAM;\n    int proto;\n\n    if (status != DNS_RESOLVE_DONE) {\n        return;\n    }\n\n    if (state->idx >= ARRAY_SIZE(ai_arr)) {\n        NET_DBG(\"getaddrinfo entries overflow\");\n        return;\n    }\n\n    ai = ai_arr + state->idx;\n    memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n    net_sin(&ai->_ai_addr)->sin_port = state->port;\n    ai->ai_addr = &ai->_ai_addr;\n    ai->ai_addrlen = info->ai_addrlen;\n    memcpy(&ai->_ai_canonname, &info->ai_canonname, sizeof(ai->_ai_canonname));\n    state->idx++;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/6158",
      "patch_diff": "@@ -30,7 +31,7 @@ static void dns_resolve_cb(enum dns_resolve_status status,\n \n     struct getaddrinfo_state *state = user_data;\n-    struct zsock_addrinfo *ai = ai_arr + state->idx;\n+    struct zsock_addrinfo *ai;\n     int socktype = SOCK_STREAM;\n     int proto;\n \n@@ -45,7 +46,14 @@ static void dns_resolve_cb(enum dns_resolve_status status,\n         return;\n     }\n \n+    if (state->idx >= ARRAY_SIZE(ai_arr)) {\n+        NET_DBG(\"getaddrinfo entries overflow\");\n+        return;\n+    }\n+\n+    ai = ai_arr + state->idx;\n     memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n+    net_sin(&ai->_ai_addr)->sin_port = state->port;\n     ai->ai_addr = &ai->_ai_addr;\n     ai->ai_addrlen = info->ai_addrlen;\n     memcpy(&ai->_ai_canonname, &info->ai_canonname,\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The DNS callback function (dns_resolve_cb) may be called multiple times, leading to out-of-bounds array access and incorrect port number settings."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using getaddrinfo() in vulnerable versions (v1.10.0 → v1.11.0)"
    ],
    "related_cve": [
      "CVE-2017-14199"
    ],
    "related_cwe": [
      "CWE-119"
    ],
    "vulnerable_version": "v1.10.0"
  },
  {
    "id": "VULN-000002",
    "vulnerability": "A buffer overflow has been found in the Zephyr Project's getaddrinfo() implementation in 1.9.0 and 1.10.0.",
    "affected_functions": [
      "dns_resolve_cb"
    ],
    "functionality": "Handles the DNS resolution callback and populates address information.",
    "call_patterns": [
      {
        "pattern": "<global>(subsys/net/lib/sockets/getaddrinfo.c)",
        "description": "Vulnerable call chain leading to <global> (version: v1.10.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v1.11.0 or above.",
      "code_snippet": "static void dns_resolve_cb(enum dns_resolve_status status, struct dns_addrinfo *info, void *user_data) {\n    struct getaddrinfo_state *state = user_data;\n    struct zsock_addrinfo *ai;\n    int socktype = SOCK_STREAM;\n    int proto;\n\n    if (status != DNS_RESOLVE_DONE) {\n        return;\n    }\n\n    if (state->idx >= ARRAY_SIZE(ai_arr)) {\n        NET_DBG(\"getaddrinfo entries overflow\");\n        return;\n    }\n\n    ai = ai_arr + state->idx;\n    memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n    net_sin(&ai->_ai_addr)->sin_port = state->port;\n    ai->ai_addr = &ai->_ai_addr;\n    ai->ai_addrlen = info->ai_addrlen;\n    memcpy(&ai->_ai_canonname, &info->ai_canonname, sizeof(ai->_ai_canonname));\n    state->idx++;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/6158",
      "patch_diff": "@@ -30,7 +31,7 @@ static void dns_resolve_cb(enum dns_resolve_status status,\n \n     struct getaddrinfo_state *state = user_data;\n-    struct zsock_addrinfo *ai = ai_arr + state->idx;\n+    struct zsock_addrinfo *ai;\n     int socktype = SOCK_STREAM;\n     int proto;\n \n@@ -45,7 +46,14 @@ static void dns_resolve_cb(enum dns_resolve_status status,\n         return;\n     }\n \n+    if (state->idx >= ARRAY_SIZE(ai_arr)) {\n+        NET_DBG(\"getaddrinfo entries overflow\");\n+        return;\n+    }\n+\n+    ai = ai_arr + state->idx;\n     memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n+    net_sin(&ai->_ai_addr)->sin_port = state->port;\n     ai->ai_addr = &ai->_ai_addr;\n     ai->ai_addrlen = info->ai_addrlen;\n     memcpy(&ai->_ai_canonname, &info->ai_canonname,\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The DNS callback function (dns_resolve_cb) may be called multiple times, leading to out-of-bounds array access and incorrect port number settings."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_resolve_cb in vulnerable versions (v1.10.0 → v1.11.0)"
    ],
    "related_cve": [
      "CVE-2017-14199"
    ],
    "related_cwe": [
      "CWE-119"
    ],
    "vulnerable_version": "v1.10.0"
  },
  {
    "id": "VULN-000003",
    "vulnerability": "A buffer overflow has been found in the Zephyr Project's getaddrinfo() implementation in 1.9.0 and 1.10.0.",
    "affected_functions": [
      "zsock_getaddrinfo"
    ],
    "functionality": "Handles the DNS resolution callback and populates address information.",
    "call_patterns": [
      {
        "pattern": "<global>(subsys/net/lib/sockets/getaddrinfo.c)",
        "description": "Vulnerable call chain leading to zsock_getaddrinfo (version: v1.10.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v1.11.0 or above.",
      "code_snippet": "static void dns_resolve_cb(enum dns_resolve_status status, struct dns_addrinfo *info, void *user_data) {\n    struct getaddrinfo_state *state = user_data;\n    struct zsock_addrinfo *ai;\n    int socktype = SOCK_STREAM;\n    int proto;\n\n    if (status != DNS_RESOLVE_DONE) {\n        return;\n    }\n\n    if (state->idx >= ARRAY_SIZE(ai_arr)) {\n        NET_DBG(\"getaddrinfo entries overflow\");\n        return;\n    }\n\n    ai = ai_arr + state->idx;\n    memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n    net_sin(&ai->_ai_addr)->sin_port = state->port;\n    ai->ai_addr = &ai->_ai_addr;\n    ai->ai_addrlen = info->ai_addrlen;\n    memcpy(&ai->_ai_canonname, &info->ai_canonname, sizeof(ai->_ai_canonname));\n    state->idx++;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/6158",
      "patch_diff": "@@ -30,7 +31,7 @@ static void dns_resolve_cb(enum dns_resolve_status status,\n \n     struct getaddrinfo_state *state = user_data;\n-    struct zsock_addrinfo *ai = ai_arr + state->idx;\n+    struct zsock_addrinfo *ai;\n     int socktype = SOCK_STREAM;\n     int proto;\n \n@@ -45,7 +46,14 @@ static void dns_resolve_cb(enum dns_resolve_status status,\n         return;\n     }\n \n+    if (state->idx >= ARRAY_SIZE(ai_arr)) {\n+        NET_DBG(\"getaddrinfo entries overflow\");\n+        return;\n+    }\n+\n+    ai = ai_arr + state->idx;\n     memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n+    net_sin(&ai->_ai_addr)->sin_port = state->port;\n     ai->ai_addr = &ai->_ai_addr;\n     ai->ai_addrlen = info->ai_addrlen;\n     memcpy(&ai->_ai_canonname, &info->ai_canonname,\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The DNS callback function (dns_resolve_cb) may be called multiple times, leading to out-of-bounds array access and incorrect port number settings."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using zsock_getaddrinfo in vulnerable versions (v1.10.0 → v1.11.0)"
    ],
    "related_cve": [
      "CVE-2017-14199"
    ],
    "related_cwe": [
      "CWE-119"
    ],
    "vulnerable_version": "v1.10.0"
  },
  {
    "id": "VULN-000004",
    "vulnerability": "Use After Free vulnerability in the Zephyr shell allows a serial or telnet connected user to cause denial of service, and possibly remote code execution. This issue affects: Zephyr shell versions prior to 1.14.0 on all.",
    "affected_functions": [
      "int shell_exec(char *line)"
    ],
    "functionality": "This function serves as the shell command handler for DNS operations, enabling users to query, cancel, and view the status of DNS resolutions.",
    "call_patterns": [
      {
        "pattern": "dns_result_cb(subsys/net/ip/net_shell.c)",
        "description": "Vulnerable call chain leading to dns_result_cb (version: v1.13.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v1.14.0 or above.",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/13260",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The shell command handler passed a stack-allocated structure containing a boolean flag to an asynchronous DNS callback, causing a use-after-free crash when the callback accessed the freed stack memory."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_result_cb in vulnerable versions (v1.13.0 → v1.14.0)"
    ],
    "related_cve": [
      "CVE-2017-14201"
    ],
    "related_cwe": [
      "CWE-416"
    ],
    "vulnerable_version": "v1.13.0"
  },
  {
    "id": "VULN-000005",
    "vulnerability": "Improper Restriction of Operations within the Bounds of a Memory Buffer vulnerability in the shell component of Zephyr allows a serial or telnet connected user to cause a crash, possibly with arbitrary code execution. This issue affects: Zephyr shell versions prior to 1.14.0 on all.",
    "affected_functions": [
      "int shell_exec(char *line)"
    ],
    "functionality": "Display a list of previously executed shell commands.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v1.14.0 or above.",
      "code_snippet": "K_MEM_SLAB_DEFINE(_name##_history_memslab, \n\t\t\tROUND_UP(block_size + sizeof(struct shell_history_item), \n\t\t\t\tsizeof(void *)), block_count, 4);",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/13048",
      "patch_diff": "SHELL_HISTORY_DEFINE(_name, CONFIG_SHELL_CMD_BUFF_SIZE, 7); \nK_MEM_SLAB_DEFINE(_name##_history_memslab, \n\t\t\tROUND_UP(block_size + sizeof(struct shell_history_item), \n\t\t\t\tsizeof(void *)), block_count, 4);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Improper allocation of memory for shell history items leading to potential buffer overflow.The SHELL_HISTORY_DEFINE macro under-allocates memory for command history entries, causing a heap buffer overflow when a long command is stored and later retrieved."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using SHELL_HISTORY_DEFINE in vulnerable versions (v1.13.0 → v1.14.0)"
    ],
    "related_cve": [
      "CVE-2017-14202"
    ],
    "related_cwe": [
      "CWE-119"
    ],
    "vulnerable_version": "v1.13.0"
  },
  {
    "id": "VULN-000006",
    "vulnerability": "USB DFU has a potential buffer overflow where the requested length (wLength) is not checked against the buffer size. This could be used by a malicious USB host to exploit the buffer overflow. See NCC-ZEP-002 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "dfu_class_handle_req"
    ],
    "functionality": "Handles USB DFU (Device Firmware Update) requests from the host.",
    "call_patterns": [
      {
        "pattern": "dfu_class_handle_req(subsys/usb/class/usb_dfu.c)",
        "description": "Vulnerable call chain leading to dfu_class_handle_req (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When handling requests that involve buffer sizes, always validate the requested length against the maximum allowable size before processing the request. This helps prevent buffer overflow vulnerabilities. Ensure that any length derived from external sources (like USB requests) is checked against predefined constants that represent the maximum buffer sizes.",
      "code_snippet": "static int dfu_class_handle_req(struct usb_setup_packet *pSetup, ...)\n{\n    ...\n    if (len > USB_DFU_MAX_XFER_SIZE) {\n        len = USB_DFU_MAX_XFER_SIZE;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23190",
      "patch_diff": "+            if (len > USB_DFU_MAX_XFER_SIZE) {\n+                len = USB_DFU_MAX_XFER_SIZE;\n+            }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the requested length (wLength) exceeds the buffer size (USB_DFU_MAX_XFER_SIZE)."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dfu_class_handle_req in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10019"
    ],
    "related_cwe": [
      "CWE-120"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000007",
    "vulnerability": "Out-of-bounds Write in the USB Mass Storage memoryWrite handler with unaligned Sizes See NCC-ZEP-024, NCC-ZEP-025, NCC-ZEP-026 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "infoTransfer"
    ],
    "functionality": "Handles the transfer of information in the USB mass storage protocol.",
    "call_patterns": [
      {
        "pattern": "infoTransfer(subsys/usb/class/mass_storage.c)<-CBWDecode(subsys/usb/class/mass_storage.c)<-mass_storage_bulk_out(subsys/usb/class/mass_storage.c)",
        "description": "Vulnerable call chain leading to infoTransfer (version: v1.14.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23455",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the Logical Block Addressing (LBA) value exceeds the memory size."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using infoTransfer in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10021"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000008",
    "vulnerability": "A malformed JSON payload that is received from an UpdateHub server may trigger memory corruption in the Zephyr OS. This could result in a denial of service in the best case, or code execution in the worst case. See NCC-NCC-016 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions. version 2.2.0 and later versions.",
    "affected_functions": [
      "enum updatehub_response updatehub_probe(void)"
    ],
    "functionality": "This function receives and parses CoAP probe response metadata from the UpdateHub server.",
    "call_patterns": [
      {
        "pattern": "probe_cb(lib/updatehub/updatehub.c)<-updatehub_probe(lib/updatehub/updatehub.c)<-cmd_run(lib/updatehub/shell.c)",
        "description": "Vulnerable call chain leading to probe_cb (version: v2.2.0)"
      },
      {
        "pattern": "probe_cb(lib/updatehub/updatehub.c)<-updatehub_probe(lib/updatehub/updatehub.c)<-autohandler(lib/updatehub/updatehub.c)",
        "description": "Vulnerable call chain leading to probe_cb (version: v2.2.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v2.3.0 or above.",
      "code_snippet": "static void probe_cb(char *metadata, size_t metadata_size) {\n    struct coap_packet reply;\n    char tmp[MAX_DOWNLOAD_DATA];\n    size_t tmp_len;\n    int rcvd = -1;\n\n    wait_fds();\n\n    rcvd = recv(ctx.sock, tmp, MAX_DOWNLOAD_DATA, MSG_DONTWAIT);\n    if (rcvd <= 0) {\n        LOG_ERR(\"Could not receive data\");\n        ctx.code_status = UPDATEHUB_NETWORKING_ERROR;\n        return;\n    }\n\n    if (coap_packet_parse(&reply, tmp, rcvd, NULL, 0) < 0) {\n        LOG_ERR(\"Invalid data received\");\n        ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;\n        return;\n    }\n\n    if (metadata_size < (reply.max_len - reply.offset)) {\n        LOG_ERR(\"There is no buffer available\");\n        ctx.code_status = UPDATEHUB_METADATA_ERROR;\n        return;\n    }\n\n    memcpy(metadata, reply.data + reply.offset, reply.max_len - reply.offset);\n\n    tmp_len = strlen(metadata);\n    if (tmp_len >= metadata_size) {\n        LOG_ERR(\"Invalid metadata data received\");\n        ctx.code_status = UPDATEHUB_METADATA_ERROR;\n        return;\n    }\n\n    ctx.code_status = UPDATEHUB_OK;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24066",
      "patch_diff": "diff --git a/lib/updatehub/updatehub.c b/lib/updatehub/updatehub.c\n@@ -587,22 +587,23 @@ error:\n     return ret;\n }\n \n-static void probe_cb(char *metadata)\n+static void probe_cb(char *metadata, size_t metadata_size) {\n     struct coap_packet reply;\n-    char tmp[MAX_PAYLOAD_SIZE];\n+    char tmp[MAX_DOWNLOAD_DATA];\n+    size_t tmp_len;\n     int rcvd = -1;\n \n     wait_fds();\n \n-    rcvd = recv(ctx.sock, metadata, MAX_PAYLOAD_SIZE, MSG_DONTWAIT);\n+    rcvd = recv(ctx.sock, tmp, MAX_DOWNLOAD_DATA, MSG_DONTWAIT);\n     if (rcvd <= 0) {\n         LOG_ERR(\"Could not receive data\");\n         ctx.code_status = UPDATEHUB_NETWORKING_ERROR;\n         return;\n     }\n \n-    if (coap_packet_parse(&reply, metadata, rcvd, NULL, 0) < 0) {\n+    if (coap_packet_parse(&reply, tmp, rcvd, NULL, 0) < 0) {\n         LOG_ERR(\"Invalid data received\");\n         ctx.code_status = UPDATEHUB_DOWNLOAD_ERROR;\n         return;\n     }\n \n-    memset(&tmp, 0, MAX_PAYLOAD_SIZE);\n-    memcpy(tmp, reply.data + reply.offset, reply.max_len - reply.offset);\n-    memset(metadata, 0, MAX_PAYLOAD_SIZE);\n-    memcpy(metadata, tmp, strlen(tmp));\n+    if (metadata_size < (reply.max_len - reply.offset)) {\n+        LOG_ERR(\"There is no buffer available\");\n+        ctx.code_status = UPDATEHUB_METADATA_ERROR;\n+        return;\n+    }\n+\n+    memcpy(metadata, reply.data + reply.offset,\n+           reply.max_len - reply.offset);\n+\n+    tmp_len = strlen(metadata);\n+    if (tmp_len >= metadata_size) {\n+        LOG_ERR(\"Invalid metadata data received\");\n+        ctx.code_status = UPDATEHUB_METADATA_ERROR;\n+        return;\n+    }\n \n     ctx.code_status = UPDATEHUB_OK;\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The library function probe_cb has a buffer overflow vulnerability due to missing bounds checks when copying network payloads, which is triggered when the device receives a malformed JSON response from an UpdateHub server."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using probe_cb in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10022"
    ],
    "related_cwe": [
      "CWE-120"
    ],
    "vulnerable_version": "v2.2.0"
  },
  {
    "id": "VULN-000009",
    "vulnerability": "The shell subsystem contains a buffer overflow, whereby an adversary with physical access to the device is able to cause a memory corruption, resulting in denial of service or possibly code execution within the Zephyr kernel. See NCC-NCC-019 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "int shell_execute_cmd(const struct shell *shell, const char *cmd)(zephyr/subsys/shell/shell.c)"
    ],
    "functionality": "Executes a shell command.",
    "call_patterns": [
      {
        "pattern": "void shell_spaces_trim(char *str)(zephyr/subsys/shell/shell_utils.c)<-void shell_wildcard_prepare(const struct shell *shell)(zephyr/subsys/shell/shell_wildcard.c)<-static int execute(const struct shell *shell)(zephyr/subsys/shell/shell.c)<-int shell_execute_cmd(const struct shell *shell, const char *cmd)(zephyr/subsys/shell/shell.c)",
        "description": "Vulnerable call chain leading to shell_spaces_trim (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Check the number of consecutive spaces in the user's input command when calling the public API shell_execute_cmd().",
      "code_snippet": "int shell_execute_cmd_safe(const struct shell *sh, const char *cmd)\n{\n    if (!sh || !cmd) return -EINVAL;\n\n    char buf[CONFIG_SHELL_CMD_BUFF_SIZE];\n    size_t out = 0;\n\n    while (isspace((unsigned char)*cmd)) ++cmd;\n\n    bool in_space = false;\n    for (; *cmd && out < sizeof(buf) - 1; ++cmd) {\n        if (isspace((unsigned char)*cmd)) {\n            in_space = true;\n        } else {\n            if (in_space && out) {\n                buf[out++] = ' ';\n            }\n            buf[out++] = *cmd;\n            in_space = false;\n        }\n    }\n    if (out && buf[out - 1] == ' ') --out;\n\n    buf[out] = '\\0';\n\n    if (out == 0) return -EINVAL;\n\n    return shell_execute_cmd(sh, buf);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23304",
      "patch_diff": "-\t\t\tmemmove(&str[i + 1],\n-                        &str[j],\n-                        len - shift + 1);\n+\t\t\tmemmove(&str[j + 1],\n+                        &str[j],\n+                        len - j + 1);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The public API shell_execute_cmd calls the library function shell_spaces_trim, and there is a buffer overflow vulnerability inside shell_spaces_trim due to incorrect buffer size calculation when compressing consecutive spaces."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using shell_spaces_trim in vulnerable versions (v2.1.0 → v2.1.1)"
    ],
    "related_cve": [
      "CVE-2020-10023"
    ],
    "related_cwe": [
      "CWE-120"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000010",
    "vulnerability": "The shell subsystem contains a buffer overflow, whereby an adversary with physical access to the device is able to cause a memory corruption, resulting in denial of service or possibly code execution within the Zephyr kernel. See NCC-NCC-019 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "int shell_execute_cmd(const struct shell *shell, const char *cmd)(zephyr/subsys/shell/shell.c)"
    ],
    "functionality": "Executes a shell command.",
    "call_patterns": [
      {
        "pattern": "void shell_spaces_trim(char *str)(zephyr/subsys/shell/shell_utils.c)<-void shell_wildcard_prepare(const struct shell *shell)(zephyr/subsys/shell/shell_wildcard.c)<-static int execute(const struct shell *shell)(zephyr/subsys/shell/shell.c)<-int shell_execute_cmd(const struct shell *shell, const char *cmd)(zephyr/subsys/shell/shell.c)",
        "description": "Vulnerable call chain leading to shell_spaces_trim (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Check the number of consecutive spaces in the user's input command when calling the public API shell_execute_cmd().",
      "code_snippet": "int shell_execute_cmd_safe(const struct shell *sh, const char *cmd)\n{\n    if (!sh || !cmd) return -EINVAL;\n\n    char buf[CONFIG_SHELL_CMD_BUFF_SIZE];\n    size_t out = 0;\n\n    while (isspace((unsigned char)*cmd)) ++cmd;\n\n    bool in_space = false;\n    for (; *cmd && out < sizeof(buf) - 1; ++cmd) {\n        if (isspace((unsigned char)*cmd)) {\n            in_space = true;\n        } else {\n            if (in_space && out) {\n                buf[out++] = ' ';\n            }\n            buf[out++] = *cmd;\n            in_space = false;\n        }\n    }\n    if (out && buf[out - 1] == ' ') --out;\n\n    buf[out] = '\\0';\n\n    if (out == 0) return -EINVAL;\n\n    return shell_execute_cmd(sh, buf);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23304",
      "patch_diff": "-\t\t\tmemmove(&str[i + 1],\n-                        &str[j],\n-                        len - shift + 1);\n+\t\t\tmemmove(&str[j + 1],\n+                        &str[j],\n+                        len - j + 1);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The public API shell_execute_cmd() calls the library function shell_spaces_trim(), and there is a buffer overflow inside shell_spaces_trim().The vulnerability can be triggered when the third argument in memmove exceeds the remaining buffer size."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10023"
    ],
    "related_cwe": [
      "CWE-120"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000011",
    "vulnerability": "The arm platform-specific code uses a signed integer comparison when validating system call numbers. An attacker who has obtained code execution within a user thread is able to elevate privileges to that of the kernel. See NCC-ZEP-001 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "_do_syscall"
    ],
    "functionality": "Handles system calls in the ARM architecture.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When validating system call numbers, always use unsigned integer comparisons to prevent privilege escalation vulnerabilities. Ensure that the comparison logic correctly handles the range of valid syscall IDs, especially when the IDs can be negative or exceed the expected limits. Review the context in which the syscall IDs are used and ensure that any user-supplied values are properly validated before being processed.",
      "code_snippet": "    /* validate syscall limit */\n    ldr ip, =K_SYSCALL_LIMIT\n    cmp r6, ip\n    blo valid_syscall_id\n\n    /* bad syscall id.  Set arg1 to bad id and set call_id to SYSCALL_BAD */\n    str r6, [r0, #0]",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23535",
      "patch_diff": "-    blt valid_syscall_id\n+    blo valid_syscall_id"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An attacker can supply a syscall ID that is incorrectly validated due to signed integer comparison."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using _do_syscall in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10024"
    ],
    "related_cwe": [
      "CWE-697"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000012",
    "vulnerability": "The arm platform-specific code uses a signed integer comparison when validating system call numbers. An attacker who has obtained code execution within a user thread is able to elevate privileges to that of the kernel. See NCC-ZEP-001 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "arch_syscall_invoke0"
    ],
    "functionality": "This function is used to invoke a system call with a given identifier.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to signed integer comparisons, ensure that system call numbers are validated against both signed and unsigned limits. Implement checks to prevent the use of invalid syscall IDs, especially those that exceed the expected range. Always test with edge cases, including maximum values for both signed and unsigned integers, to ensure that the system behaves correctly and securely.",
      "code_snippet": "void test_bad_syscall(void) {\n    arch_syscall_invoke0(INT_MAX);\n    expect_fault = true;\n    expected_reason = K_ERR_KERNEL_OOPS;\n    arch_syscall_invoke0(UINT_MAX);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23323",
      "patch_diff": "diff --git a/tests/kernel/mem_protect/userspace/src/main.c b/tests/kernel/mem_protect/userspace/src/main.c\nindex 6e867de8a5a..d4b84ac7d19 100644\n--- a/tests/kernel/mem_protect/userspace/src/main.c\n+++ b/tests/kernel/mem_protect/userspace/src/main.c\n@@ -1112,6 +1112,10 @@ void test_bad_syscall(void) {\n \n     arch_syscall_invoke0(INT_MAX);\n \n+    expect_fault = true;\n+    expected_reason = K_ERR_KERNEL_OOPS;\n+\n+    arch_syscall_invoke0(UINT_MAX);\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An attacker can trigger the vulnerability by supplying a large unsigned syscall-ID value, which can lead to privilege escalation."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using arch_syscall_invoke0 in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10024"
    ],
    "related_cwe": [
      "CWE-697"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000013",
    "vulnerability": "The arm platform-specific code uses a signed integer comparison when validating system call numbers. An attacker who has obtained code execution within a user thread is able to elevate privileges to that of the kernel. See NCC-ZEP-001 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "This function is used to invoke a system call with a given identifier.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to signed integer comparisons, ensure that system call numbers are validated against both signed and unsigned limits. Implement checks to prevent the use of invalid syscall IDs, especially those that exceed the expected range. Always test with edge cases, including maximum values for both signed and unsigned integers, to ensure that the system behaves correctly and securely.",
      "code_snippet": "void test_bad_syscall(void) {\n    arch_syscall_invoke0(INT_MAX);\n    expect_fault = true;\n    expected_reason = K_ERR_KERNEL_OOPS;\n    arch_syscall_invoke0(UINT_MAX);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23323",
      "patch_diff": "diff --git a/tests/kernel/mem_protect/userspace/src/main.c b/tests/kernel/mem_protect/userspace/src/main.c\nindex 6e867de8a5a..d4b84ac7d19 100644\n--- a/tests/kernel/mem_protect/userspace/src/main.c\n+++ b/tests/kernel/mem_protect/userspace/src/main.c\n@@ -1112,6 +1112,10 @@ void test_bad_syscall(void) {\n \n     arch_syscall_invoke0(INT_MAX);\n \n+    expect_fault = true;\n+    expected_reason = K_ERR_KERNEL_OOPS;\n+\n+    arch_syscall_invoke0(UINT_MAX);\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An attacker can trigger the vulnerability by supplying a large unsigned syscall-ID value, which can lead to privilege escalation."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10024"
    ],
    "related_cwe": [
      "CWE-697"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000014",
    "vulnerability": "An attacker who has obtained code execution within a user thread is able to elevate privileges to that of the kernel. See NCC-ZEP-001 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "__ev_trap"
    ],
    "functionality": "Handles system call traps in the ARC architecture.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23328",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An attacker executes malicious code that sets r6 to a negative number, allowing it to bypass the syscall ID check."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using __ev_trap in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10027"
    ],
    "related_cwe": [
      "CWE-697"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000015",
    "vulnerability": "Multiple syscalls with insufficient argument validation See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "gpio_enable_callback"
    ],
    "functionality": "Enables a callback for a specified GPIO pin.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When implementing syscall handlers, always validate the driver object associated with the syscall to prevent unauthorized access or operations. Use macros like Z_OOPS to check if the driver is valid before proceeding with the function call. This ensures that the arguments passed to the function are properly validated and reduces the risk of vulnerabilities related to insufficient argument validation.",
      "code_snippet": "Z_SYSCALL_HANDLER(gpio_enable_callback, port, access_op, pin) {\n\tZ_OOPS(Z_SYSCALL_DRIVER_GPIO(port, enable_callback));\n\treturn z_impl_gpio_enable_callback((struct device *)port, access_op, pin);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23733",
      "patch_diff": "+\tZ_OOPS(Z_SYSCALL_DRIVER_GPIO(port, enable_callback));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "No driver object checks were performed for the GPIO API."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using gpio_enable_callback in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10028"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000016",
    "vulnerability": "Multiple syscalls with insufficient argument validation See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "gpio_disable_callback"
    ],
    "functionality": "Disables a callback for a specified GPIO pin.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all syscall handlers validate the driver object before proceeding with the function call. This can be achieved by using the appropriate macros to check the validity of the driver object associated with the port parameter. Always include these checks at the beginning of the syscall handler to prevent potential misuse or invalid access.",
      "code_snippet": "Z_SYSCALL_HANDLER(gpio_disable_callback, port, access_op, pin) {\n\tZ_OOPS(Z_SYSCALL_DRIVER_GPIO(port, disable_callback));\n\treturn z_impl_gpio_disable_callback((struct device *)port, access_op, pin);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23733",
      "patch_diff": "+\tZ_OOPS(Z_SYSCALL_DRIVER_GPIO(port, disable_callback));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "No driver object checks were performed for the GPIO API."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using gpio_disable_callback in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10028"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000017",
    "vulnerability": "Multiple syscalls with insufficient argument validation See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "gpio_get_pending_int"
    ],
    "functionality": "Retrieves the pending interrupt status for a specified GPIO port.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When implementing syscall handlers, always validate the driver object associated with the syscall. Use the Z_OOPS macro to check if the driver is valid before proceeding with the implementation. This ensures that the function does not operate on an invalid or uninitialized driver object, which can lead to security vulnerabilities such as insufficient argument validation.",
      "code_snippet": "Z_SYSCALL_HANDLER(gpio_get_pending_int, port) {\n\tZ_OOPS(Z_SYSCALL_DRIVER_GPIO(port, get_pending_int));\n\treturn z_impl_gpio_get_pending_int((struct device *)port);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23733",
      "patch_diff": "+\tZ_OOPS(Z_SYSCALL_DRIVER_GPIO(port, get_pending_int));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "No driver object checks were performed for the GPIO API."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using gpio_get_pending_int in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10028"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000018",
    "vulnerability": "Multiple syscalls with insufficient argument validation See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "z_vrfy_gpio_enable_callback"
    ],
    "functionality": "This function verifies and enables a GPIO callback for a specified pin.",
    "call_patterns": [
      {
        "pattern": "z_vrfy_gpio_enable_callback(drivers/gpio/gpio_handlers.c)",
        "description": "Vulnerable call chain leading to z_vrfy_gpio_enable_callback (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When implementing syscall handlers, always validate the driver object before proceeding with the function logic. Use macros like Z_OOPS to ensure that the driver is valid and that the function can safely operate on the provided parameters. This helps prevent issues related to insufficient argument validation.",
      "code_snippet": "static inline int z_vrfy_gpio_enable_callback(struct device *port, gpio_pin_t pin) {\n    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, enable_callback));\n    return z_impl_gpio_enable_callback((struct device *)port, pin);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23308",
      "patch_diff": "+    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, enable_callback));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the driver object for the GPIO port."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_vrfy_gpio_enable_callback in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10028"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000019",
    "vulnerability": "Multiple syscalls with insufficient argument validation See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "z_vrfy_gpio_disable_callback"
    ],
    "functionality": "This function verifies and disables a GPIO callback for a specified pin.",
    "call_patterns": [
      {
        "pattern": "z_vrfy_gpio_disable_callback(drivers/gpio/gpio_handlers.c)",
        "description": "Vulnerable call chain leading to z_vrfy_gpio_disable_callback (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When implementing syscall handlers, always validate the driver object before proceeding with the function logic. Use macros like Z_OOPS to ensure that the driver is valid and that the function can safely operate on the provided parameters. This helps prevent issues related to insufficient argument validation.",
      "code_snippet": "static inline int z_vrfy_gpio_disable_callback(struct device *port,\n                          gpio_pin_t pin) {\n    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, disable_callback));\n    return z_impl_gpio_disable_callback((struct device *)port, pin);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23308",
      "patch_diff": "+    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, disable_callback));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the driver object for the GPIO port."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_vrfy_gpio_disable_callback in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10028"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000020",
    "vulnerability": "Multiple syscalls with insufficient argument validation See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "z_vrfy_gpio_get_pending_int"
    ],
    "functionality": "This function verifies and retrieves the pending interrupt status for a GPIO device.",
    "call_patterns": [
      {
        "pattern": "z_vrfy_gpio_get_pending_int(drivers/gpio/gpio_handlers.c)",
        "description": "Vulnerable call chain leading to z_vrfy_gpio_get_pending_int (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When implementing syscall handlers, always validate the driver object before proceeding with the function call. Use the appropriate macros to check if the driver supports the requested operation. This helps prevent issues related to insufficient argument validation and ensures that the function operates on valid driver instances.",
      "code_snippet": "static inline int z_vrfy_gpio_get_pending_int(struct device *dev) {\n    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(dev, get_pending_int));\n    return z_impl_gpio_get_pending_int((struct device *)dev);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23308",
      "patch_diff": "+    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(dev, get_pending_int));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the driver object for the GPIO device."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_vrfy_gpio_get_pending_int in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10028"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000021",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "dma_stm32_configure"
    ],
    "functionality": "Configures the DMA stream with the specified parameters.",
    "call_patterns": [
      {
        "pattern": "dma_stm32_configure(drivers/dma/dma_stm32.c)",
        "description": "Vulnerable call chain leading to dma_stm32_configure (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all user-supplied arguments are validated before being used in the function. This includes checking for valid ranges, types, and any other constraints that are necessary for the function to operate safely. Implement checks for the parameters passed to the 'dma_stm32_configure' function to prevent potential privilege escalation or unexpected behavior.",
      "code_snippet": "static int dma_stm32_configure(struct device *dev, u32_t id, struct dma_config *config) {\n    struct dma_stm32_data *data = dev->driver_data;\n    struct dma_stm32_stream *stream;\n\n    if (id < STREAM_OFFSET || id >= data->max_streams) {\n        return -EINVAL; // Invalid stream ID\n    }\n\n    if (!config || !config->head_block || config->head_block->block_size == 0) {\n        return -EINVAL; // Invalid config\n    }\n\n    stream = &data->streams[id - STREAM_OFFSET];\n    stream->busy = true;\n\n    // Additional configuration logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23748",
      "patch_diff": "diff --git a/drivers/dma/dma_stm32.c b/drivers/dma/dma_stm32.c\nindex 5c7e1d97388..928d117d074 100644\n--- a/drivers/dma/dma_stm32.c\n+++ b/drivers/dma/dma_stm32.c\n@@ -210,8 +232,13 @@ static int dma_stm32_configure(struct device *dev, u32_t id,\n     struct dma_stm32_data *data = dev->driver_data;\n     struct dma_stm32_stream *stream = &data->streams[id - STREAM_OFFSET];\n+\n+    if (id < STREAM_OFFSET || id >= data->max_streams) {\n+        return -EINVAL; // Invalid stream ID\n+    }\n+\n+    if (!config || !config->head_block || config->head_block->block_size == 0) {\n+        return -EINVAL; // Invalid config\n+    }\n     stream->busy = true;\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the 'id' parameter can lead to out-of-bounds access."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dma_stm32_configure in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000022",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "dma_stm32_disable_stream"
    ],
    "functionality": "Configures the DMA stream with the specified parameters.",
    "call_patterns": [
      {
        "pattern": "dma_stm32_configure(drivers/dma/dma_stm32.c)",
        "description": "Vulnerable call chain leading to dma_stm32_disable_stream (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all user-supplied arguments are validated before being used in the function. This includes checking for valid ranges, types, and any other constraints that are necessary for the function to operate safely. Implement checks for the parameters passed to the 'dma_stm32_configure' function to prevent potential privilege escalation or unexpected behavior.",
      "code_snippet": "static int dma_stm32_configure(struct device *dev, u32_t id, struct dma_config *config) {\n    struct dma_stm32_data *data = dev->driver_data;\n    struct dma_stm32_stream *stream;\n\n    if (id < STREAM_OFFSET || id >= data->max_streams) {\n        return -EINVAL; // Invalid stream ID\n    }\n\n    if (!config || !config->head_block || config->head_block->block_size == 0) {\n        return -EINVAL; // Invalid config\n    }\n\n    stream = &data->streams[id - STREAM_OFFSET];\n    stream->busy = true;\n\n    // Additional configuration logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23748",
      "patch_diff": "diff --git a/drivers/dma/dma_stm32.c b/drivers/dma/dma_stm32.c\nindex 5c7e1d97388..928d117d074 100644\n--- a/drivers/dma/dma_stm32.c\n+++ b/drivers/dma/dma_stm32.c\n@@ -210,8 +232,13 @@ static int dma_stm32_configure(struct device *dev, u32_t id,\n     struct dma_stm32_data *data = dev->driver_data;\n     struct dma_stm32_stream *stream = &data->streams[id - STREAM_OFFSET];\n+\n+    if (id < STREAM_OFFSET || id >= data->max_streams) {\n+        return -EINVAL; // Invalid stream ID\n+    }\n+\n+    if (!config || !config->head_block || config->head_block->block_size == 0) {\n+        return -EINVAL; // Invalid config\n+    }\n     stream->busy = true;\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the 'id' parameter can lead to out-of-bounds access."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dma_stm32_disable_stream in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000023",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "dma_stm32_reload"
    ],
    "functionality": "Configures the DMA stream with the specified parameters.",
    "call_patterns": [
      {
        "pattern": "dma_stm32_stop(drivers/dma/dma_stm32.c)",
        "description": "Vulnerable call chain leading to dma_stm32_reload (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all user-supplied arguments are validated before being used in critical operations. This includes checking for valid ranges, types, and conditions that could lead to unexpected behavior or privilege escalation. Implement checks for the validity of parameters such as device pointers, IDs, and sizes, and return appropriate error codes when invalid inputs are detected.",
      "code_snippet": "static int dma_stm32_reload(struct device *dev, u32_t id, u32_t src, u32_t dst, size_t size) {\n    const struct dma_stm32_config *config = dev->config->config_info;\n    DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);\n\n    if (id < STREAM_OFFSET || id >= config->max_streams) {\n        return -EINVAL;\n    }\n    if (src == 0 || dst == 0 || size == 0) {\n        return -EINVAL;\n    }\n    // Additional logic for reloading the DMA stream\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23748",
      "patch_diff": "@@ -441,6 +441,12 @@ static int dma_stm32_reload(struct device *dev, u32_t id,\n     u32_t src, u32_t dst, size_t size) {\n     const struct dma_stm32_config *config = dev->config->config_info;\n     DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);\n+\n+    if (id < STREAM_OFFSET || id >= config->max_streams) {\n+        return -EINVAL;\n+    }\n+    if (src == 0 || dst == 0 || size == 0) {\n+        return -EINVAL;\n+    }\n     // Additional logic for reloading the DMA stream\n     return 0;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the 'id' parameter can lead to out-of-bounds access."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dma_stm32_reload in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000024",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "dma_stm32_stop"
    ],
    "functionality": "Configures the DMA stream with the specified parameters.",
    "call_patterns": [
      {
        "pattern": "dma_stm32_stop(drivers/dma/dma_stm32.c)",
        "description": "Vulnerable call chain leading to dma_stm32_stop (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix vulnerabilities related to insufficient argument validation in functions like 'dma_stm32_stop', ensure that all input parameters are validated before use. Specifically, check that the 'id' parameter is within the expected range and handle any invalid cases appropriately. Additionally, consider implementing logging for error cases to aid in debugging and monitoring.",
      "code_snippet": "static int dma_stm32_stop(struct device *dev, u32_t id) {\n    struct dma_stm32_data *data = dev->driver_data;\n    struct dma_stm32_stream *stream = &data->streams[id - STREAM_OFFSET];\n\n    if (id < STREAM_OFFSET || id >= data->max_streams) {\n        return -EINVAL;\n    }\n\n    LL_DMA_DisableIT_TC(dma, table_ll_stream[id]);\n    // Additional logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23748",
      "patch_diff": "@@ -521,7 +562,10 @@ static int dma_stm32_stop(struct device *dev, u32_t id) {\n     struct dma_stm32_data *data = dev->driver_data;\n     struct dma_stm32_stream *stream = &data->streams[id - STREAM_OFFSET];\n \n+    if (id < STREAM_OFFSET || id >= data->max_streams) {\n+        return -EINVAL;\n+    }\n     LL_DMA_DisableIT_TC(dma, table_ll_stream[id]);\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the 'id' parameter can lead to out-of-bounds access."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dma_stm32_stop in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000025",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "dma_stm32_start"
    ],
    "functionality": "Starts the DMA stream for data transfer.",
    "call_patterns": [
      {
        "pattern": "dma_stm32_start(drivers/dma/dma_stm32.c)",
        "description": "Vulnerable call chain leading to dma_stm32_start (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all user-supplied arguments are validated before being used in function calls. This includes checking for valid ranges, ensuring that pointers are not null, and confirming that any IDs or indices are within expected limits. Implement comprehensive error handling to prevent unauthorized access or privilege escalation.",
      "code_snippet": "static int dma_stm32_start(struct device *dev, u32_t id) {\n    const struct dma_stm32_config *config = dev->config->config_info;\n    DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);\n\n    if (id >= config->max_streams) {\n        return -EINVAL; // Validate the stream ID\n    }\n\n    // Additional logic to start the DMA stream\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23748",
      "patch_diff": "diff --git a/drivers/dma/dma_stm32.c b/drivers/dma/dma_stm32.c\n@@ -485,7 +518,11 @@ static int dma_stm32_reload(struct device *dev, u32_t id,\n \n static int dma_stm32_start(struct device *dev, u32_t id)\n {\n     const struct dma_stm32_config *config = dev->config->config_info;\n     DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);\n+\n+    if (id >= config->max_streams) {\n+        return -EINVAL; // Validate the stream ID\n+    }\n \n     // Additional logic to start the DMA stream\n     return 0;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the 'id' parameter can lead to out-of-bounds access."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dma_stm32_start in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000026",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "z_vrfy_gpio_enable_callback"
    ],
    "functionality": "This function verifies and enables a GPIO callback for a specified pin.",
    "call_patterns": [
      {
        "pattern": "z_vrfy_gpio_enable_callback(drivers/gpio/gpio_handlers.c)",
        "description": "Vulnerable call chain leading to z_vrfy_gpio_enable_callback (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all syscall handlers validate the driver object before proceeding with the function logic. This can be achieved by using macros or functions that check the validity of the driver object against expected capabilities. Always include checks for the specific operations that the syscall will perform to prevent unauthorized access or operations.",
      "code_snippet": "static inline int z_vrfy_gpio_enable_callback(struct device *port, gpio_pin_t pin) {\n    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, enable_callback));\n    return z_impl_gpio_enable_callback((struct device *)port, pin);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23308",
      "patch_diff": "+    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, enable_callback));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the driver object for the GPIO port parameter."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_vrfy_gpio_enable_callback in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000027",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "z_vrfy_gpio_disable_callback"
    ],
    "functionality": "This function verifies and disables a GPIO callback for a specified pin.",
    "call_patterns": [
      {
        "pattern": "z_vrfy_gpio_disable_callback(drivers/gpio/gpio_handlers.c)",
        "description": "Vulnerable call chain leading to z_vrfy_gpio_disable_callback (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When implementing syscall handlers, always perform necessary checks on driver objects to ensure that the arguments passed to the function are valid. This includes validating the device pointer and ensuring that the specific driver functionality is available before proceeding with the operation. Use macros or functions designed for syscall validation to enforce these checks.",
      "code_snippet": "static inline int z_vrfy_gpio_disable_callback(struct device *port,\n                          gpio_pin_t pin) {\n    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, disable_callback));\n    return z_impl_gpio_disable_callback((struct device *)port, pin);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23308",
      "patch_diff": "+    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(port, disable_callback));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the driver object for the GPIO port parameter."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_vrfy_gpio_disable_callback in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000028",
    "vulnerability": "Multiple syscalls in the Kscan subsystem perform insufficient argument validation, allowing code executing in userspace to potentially gain elevated privileges. See NCC-ZEP-006 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "z_vrfy_gpio_get_pending_int"
    ],
    "functionality": "This function verifies and retrieves pending interrupt status for a GPIO device.",
    "call_patterns": [
      {
        "pattern": "z_vrfy_gpio_get_pending_int(drivers/gpio/gpio_handlers.c)",
        "description": "Vulnerable call chain leading to z_vrfy_gpio_get_pending_int (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to insufficient argument validation in syscall handlers, ensure that you perform necessary checks on the driver object before invoking the implementation function. Use macros or functions that validate the driver object against the expected capabilities to prevent unauthorized access or operations.",
      "code_snippet": "static inline int z_vrfy_gpio_get_pending_int(struct device *dev) {\n    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(dev, get_pending_int));\n    return z_impl_gpio_get_pending_int((struct device *)dev);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23308",
      "patch_diff": "+    Z_OOPS(Z_SYSCALL_DRIVER_GPIO(dev, get_pending_int));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Insufficient validation of the driver object for the GPIO device parameter."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_vrfy_gpio_get_pending_int in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10058"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000029",
    "vulnerability": "The UpdateHub module disables DTLS peer checking, which allows for a man in the middle attack. This is mitigated by firmware images requiring valid signatures. However, there is no benefit to using DTLS without the peer checking. See NCC-ZEP-018 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
    "affected_functions": [
      "start_coap_client"
    ],
    "functionality": "This function initiates a CoAP client for communication.",
    "call_patterns": [
      {
        "pattern": "start_coap_client(lib/updatehub/updatehub.c)<-install_update(lib/updatehub/updatehub.c)<-updatehub_update(lib/updatehub/updatehub.c)<-cmd_run(lib/updatehub/shell.c)",
        "description": "Vulnerable call chain leading to start_coap_client (version: v2.2.1)"
      },
      {
        "pattern": "start_coap_client(lib/updatehub/updatehub.c)<-install_update(lib/updatehub/updatehub.c)<-updatehub_update(lib/updatehub/updatehub.c)<-autohandler(lib/updatehub/updatehub.c)",
        "description": "Vulnerable call chain leading to start_coap_client (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Ensure that DTLS peer verification is enabled in functions that establish secure connections. This can be done by setting the verification option to require peer verification, which helps prevent man-in-the-middle attacks. Always validate the configuration settings for DTLS to ensure that they align with security best practices.",
      "code_snippet": "static bool start_coap_client(void) {\n\t// ... other code ...\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_REQUIRED;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \"5684\";\n\t// ... other code ...\n#endif\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24954",
      "patch_diff": "-\tint verify = TLS_PEER_VERIFY_NONE;\n+    int verify = TLS_PEER_VERIFY_REQUIRED;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function was configured to use DTLS without requiring peer verification, allowing for potential man-in-the-middle attacks."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using start_coap_client in vulnerable versions (v2.2.0 → v2.2.1)"
    ],
    "related_cve": [
      "CVE-2020-10059"
    ],
    "related_cwe": [
      "CWE-295"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000030",
    "vulnerability": "In updatehub_probe, right after JSON parsing is complete, objects\\[1] is accessed from the output structure in two different places. If the JSON contained less than two elements, this access would reference unitialized stack memory. This could result in a crash, denial of service, or possibly an information leak. Provided the fix in CVE-2020-10059 is applied, the attack requires compromise of the server. See NCC-ZEP-030 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions. version 2.2.0 and later versions.",
    "affected_functions": [
      "updatehub_probe"
    ],
    "functionality": "This function probes the update hub for metadata about available updates.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When dealing with data structures that are populated from external sources (like JSON), always initialize the structures to avoid dereferencing uninitialized memory. Additionally, validate the length of arrays before accessing their elements to prevent out-of-bounds access. Implement checks to ensure that the expected number of elements is present before proceeding with operations that assume their existence.",
      "code_snippet": "enum updatehub_response updatehub_probe(void) {\n    struct probe request;\n    struct resp_probe_some_boards metadata_some_boards = { 0 };\n    struct resp_probe_any_boards metadata_any_boards = { 0 };\n\n    char *metadata = k_malloc(MAX_DOWNLOAD_DATA);\n    char *metadata_copy = k_malloc(MAX_DOWNLOAD_DATA);\n\n    // ... other code ...\n\n    if (metadata_any_boards.objects_len != 2) {\n        LOG_ERR(\"Could not parse json\");\n        ctx.code_status = UPDATEHUB_METADATA_ERROR;\n        goto cleanup;\n    }\n\n    sha256size = strlen(metadata_any_boards.objects[1].objects.sha256sum) + 1;\n    update_info.image_size = metadata_any_boards.objects[1].objects.size;\n    LOG_DBG(\"metadata_any: %s\", update_info.sha256sum_image);\n\n    // ... other code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/27865",
      "patch_diff": "if (metadata_any_boards.objects_len != 2) {\n    LOG_ERR(\"Could not parse json\");\n    ctx.code_status = UPDATEHUB_METADATA_ERROR;\n    goto cleanup;\n}\n\nif (metadata_some_boards.objects_len != 2) {\n    LOG_ERR(\"Could not parse json\");\n    ctx.code_status = UPDATEHUB_METADATA_ERROR;\n    goto cleanup;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when the JSON response contains less than two elements in the 'objects' array."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using updatehub_probe in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-10060"
    ],
    "related_cwe": [
      "CWE-119,CWE-824"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000031",
    "vulnerability": "A malicious userspace application can cause a integer overflow and bypass security checks performed by system call handlers. The impact would depend on the underlying system call and can range from denial of service to information leak to memory corruption resulting in code execution within the kernel. See NCC-ZEP-005 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "z_arch_mem_domain_destroy"
    ],
    "functionality": "Destroys a memory domain in the kernel.",
    "call_patterns": [
      {
        "pattern": "<global>(kernel/include/kernel_internal.h)",
        "description": "Vulnerable call chain leading to z_arch_mem_domain_destroy (version: v1.14.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to integer overflows, especially in functions that handle memory operations, ensure to validate input parameters thoroughly. Specifically, check for conditions that could lead to zero or negative sizes, and document any assumptions about buffer sizes. Always include warnings in the documentation to inform users of potential undefined behavior when invalid parameters are passed.",
      "code_snippet": "extern void z_arch_mem_domain_destroy(struct k_mem_domain *domain);\n\n * @warning 0 size buffer has undefined behavior.\n *\n * @param addr start address of the buffer\n * @param size the size of the buffer\n * @param write If nonzero, additionally check if the area is writable.",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23653",
      "patch_diff": "+ * @warning 0 size buffer has undefined behavior."
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Passing a buffer with a size of 0, which leads to undefined behavior."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using z_arch_mem_domain_destroy in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10067"
    ],
    "related_cwe": [
      "CWE-190"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000032",
    "vulnerability": "A malicious userspace application can cause a integer overflow and bypass security checks performed by system call handlers. The impact would depend on the underlying system call and can range from denial of service to information leak to memory corruption resulting in code execution within the kernel. See NCC-ZEP-005 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Destroys a memory domain in the kernel.",
    "call_patterns": [
      {
        "pattern": "<global>(kernel/include/kernel_internal.h)",
        "description": "Vulnerable call chain leading to <global> (version: v1.14.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to integer overflows, especially in functions that handle memory operations, ensure to validate input parameters thoroughly. Specifically, check for conditions that could lead to zero or negative sizes, and document any assumptions about buffer sizes. Always include warnings in the documentation to inform users of potential undefined behavior when invalid parameters are passed.",
      "code_snippet": "extern void z_arch_mem_domain_destroy(struct k_mem_domain *domain);\n\n * @warning 0 size buffer has undefined behavior.\n *\n * @param addr start address of the buffer\n * @param size the size of the buffer\n * @param write If nonzero, additionally check if the area is writable.",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23653",
      "patch_diff": "+ * @warning 0 size buffer has undefined behavior."
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Passing a buffer with a size of 0, which leads to undefined behavior."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v1.14.1 → v1.14.2)"
    ],
    "related_cve": [
      "CVE-2020-10067"
    ],
    "related_cwe": [
      "CWE-190"
    ],
    "vulnerable_version": "v1.14.1"
  },
  {
    "id": "VULN-000033",
    "vulnerability": "A malicious userspace application can cause a integer overflow and bypass security checks performed by system call handlers. The impact would depend on the underlying system call and can range from denial of service to information leak to memory corruption resulting in code execution within the kernel. See NCC-ZEP-005 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "arch_mem_domain_destroy"
    ],
    "functionality": "Destroys a memory domain in the architecture-specific memory management.",
    "call_patterns": [
      {
        "pattern": "<global>(include/sys/arch_interface.h)",
        "description": "Vulnerable call chain leading to arch_mem_domain_destroy (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to integer overflows, especially in functions that handle memory operations, ensure to validate input parameters thoroughly. Specifically, check for conditions that could lead to zero or negative sizes, and document any assumptions about buffer sizes. Always include warnings in the documentation to inform users of potential undefined behavior when invalid parameters are passed.",
      "code_snippet": "void arch_mem_domain_destroy(struct k_mem_domain *domain) {\n    // Function implementation\n    // Ensure to validate 'domain' and its properties before proceeding\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23239",
      "patch_diff": "+ * @warning 0 size buffer has undefined behavior."
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Supplying a buffer of size zero, which leads to undefined behavior."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using arch_mem_domain_destroy in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10067"
    ],
    "related_cwe": [
      "CWE-190"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000034",
    "vulnerability": "A malicious userspace application can cause a integer overflow and bypass security checks performed by system call handlers. The impact would depend on the underlying system call and can range from denial of service to information leak to memory corruption resulting in code execution within the kernel. See NCC-ZEP-005 This issue affects: zephyrproject-rtos zephyr version 1.14.1 and later versions. version 2.1.0 and later versions.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Destroys a memory domain in the architecture-specific memory management.",
    "call_patterns": [
      {
        "pattern": "<global>(include/sys/arch_interface.h)",
        "description": "Vulnerable call chain leading to <global> (version: v2.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to integer overflows, especially in functions that handle memory operations, ensure to validate input parameters thoroughly. Specifically, check for conditions that could lead to zero or negative sizes, and document any assumptions about buffer sizes. Always include warnings in the documentation to inform users of potential undefined behavior when invalid parameters are passed.",
      "code_snippet": "void arch_mem_domain_destroy(struct k_mem_domain *domain) {\n    // Function implementation\n    // Ensure to validate 'domain' and its properties before proceeding\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23239",
      "patch_diff": "+ * @warning 0 size buffer has undefined behavior."
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Supplying a buffer of size zero, which leads to undefined behavior."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v2.1.0 → v2.2.0)"
    ],
    "related_cve": [
      "CVE-2020-10067"
    ],
    "related_cwe": [
      "CWE-190"
    ],
    "vulnerable_version": "v2.1.0"
  },
  {
    "id": "VULN-000035",
    "vulnerability": "Improper handling of the full-buffer case in the Zephyr Bluetooth implementation can result in memory corruption. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "isr_rx_pdu"
    ],
    "functionality": "Handles the reception of PDU packets in a Bluetooth connection.",
    "call_patterns": [
      {
        "pattern": "empty_tx_enqueue(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_pdu_tx_prep(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_isr_rx(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)",
        "description": "Vulnerable call chain leading to isr_rx_pdu (version: v2.2.0)"
      },
      {
        "pattern": "empty_tx_enqueue(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_pdu_tx_prep(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-prepare_cb(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_master.c)",
        "description": "Vulnerable call chain leading to isr_rx_pdu (version: v2.2.0)"
      },
      {
        "pattern": "empty_tx_enqueue(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_pdu_tx_prep(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_isr_rx(subsys/bluetooth/controller/ll_sw/openisa/lll/lll_conn.c)",
        "description": "Vulnerable call chain leading to isr_rx_pdu (version: v2.2.0)"
      },
      {
        "pattern": "empty_tx_enqueue(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_pdu_tx_prep(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-prepare_cb(subsys/bluetooth/controller/ll_sw/openisa/lll/lll_master.c)",
        "description": "Vulnerable call chain leading to isr_rx_pdu (version: v2.2.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When handling packet sequences in Bluetooth communication, ensure that the offsets and lengths are properly validated to prevent memory corruption. Always check if the calculated offset exceeds the expected length before updating any pointers or offsets. This is crucial in functions that process incoming packets to avoid buffer overflows or underflows.",
      "code_snippet": "static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx, ... ) {\n    if (link) {\n        struct pdu_data *pdu_data_tx;\n        u8_t pdu_data_tx_len;\n        u8_t offset;\n\n        pdu_data_tx = (void *)(tx->pdu + lll->packet_tx_head_offset);\n        ...\n\n        offset = lll->packet_tx_head_offset + pdu_data_tx_len;\n        if (offset < lll->packet_tx_head_len) {\n            lll->packet_tx_head_offset = offset;\n        } else if (offset == lll->packet_tx_head_len) {\n            lll->packet_tx_head_len = 0;\n            lll->packet_tx_head_offset = 0;\n        }\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23547",
      "patch_diff": "@@ -688,6 +688,7 @@ static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx,\n         if (link) {\n             struct pdu_data *pdu_data_tx;\n             u8_t pdu_data_tx_len;\n+            u8_t offset;\n\n             pdu_data_tx = (void *)(tx->pdu +\n                        lll->packet_tx_head_offset);\n@@ -702,9 +703,10 @@ static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx,\n             }\n #endif /* CONFIG_BT_CTLR_LE_ENC */\n\n-            lll->packet_tx_head_offset += pdu_data_tx_len;\n-            if (lll->packet_tx_head_offset ==\n-                lll->packet_tx_head_len) {\n+            offset = lll->packet_tx_head_offset + pdu_data_tx_len;\n+            if (offset < lll->packet_tx_head_len) {\n+                lll->packet_tx_head_offset = offset;\n+            } else if (offset == lll->packet_tx_head_len) {\n                lll->packet_tx_head_len = 0;\n                lll->packet_tx_head_offset = 0;\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Improper handling of the full-buffer case when the packet transmission head offset equals the packet transmission head length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_rx_pdu in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10061"
    ],
    "related_cwe": [
      "CWE-119,CWE-787"
    ],
    "vulnerable_version": "v2.2.0"
  },
  {
    "id": "VULN-000036",
    "vulnerability": "Improper handling of the full-buffer case in the Zephyr Bluetooth implementation can result in memory corruption. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "empty_tx_enqueue"
    ],
    "functionality": "Handles the reception of PDU packets in a Bluetooth connection.",
    "call_patterns": [
      {
        "pattern": "isr_rx_pdu(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_isr_rx(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)",
        "description": "Vulnerable call chain leading to empty_tx_enqueue (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to improper handling of buffer sizes, ensure that any offsets or lengths are checked against the maximum allowed values before performing operations that modify these values. Always validate the size of incoming data and ensure that any calculations involving offsets do not exceed the allocated buffer size. Implement checks to handle edge cases, such as full buffers, to prevent memory corruption.",
      "code_snippet": "static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx, ... ) {\n    if (link) {\n        struct pdu_data *pdu_data_tx;\n        u8_t pdu_data_tx_len;\n        u8_t offset;\n\n        pdu_data_tx = (void *)(tx->pdu + lll->packet_tx_head_offset);\n        ...\n\n        offset = lll->packet_tx_head_offset + pdu_data_tx_len;\n        if (offset < lll->packet_tx_head_len) {\n            lll->packet_tx_head_offset = offset;\n        } else if (offset == lll->packet_tx_head_len) {\n            lll->packet_tx_head_len = 0;\n            lll->packet_tx_head_offset = 0;\n        }\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23516",
      "patch_diff": "+            u8_t offset;\n+\n+            offset = lll->packet_tx_head_offset + pdu_data_tx_len;\n+            if (offset < lll->packet_tx_head_len) {\n+                lll->packet_tx_head_offset = offset;\n+            } else if (offset == lll->packet_tx_head_len) {\n+                lll->packet_tx_head_len = 0;\n+                lll->packet_tx_head_offset = 0;\n            }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Improper handling of the full-buffer case when the packet transmission head offset equals the packet transmission head length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using empty_tx_enqueue in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10061"
    ],
    "related_cwe": [
      "CWE-119,CWE-787"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000037",
    "vulnerability": "Improper handling of the full-buffer case in the Zephyr Bluetooth implementation can result in memory corruption. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "lll_conn_flush"
    ],
    "functionality": "Handles the reception of PDU packets in a Bluetooth connection.",
    "call_patterns": [
      {
        "pattern": "isr_rx_pdu(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)<-lll_conn_isr_rx(subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c)",
        "description": "Vulnerable call chain leading to lll_conn_flush (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to improper handling of buffer sizes, ensure that any offsets or lengths are checked against the maximum allowed values before performing operations that modify these values. Always validate the size of incoming data and ensure that any calculations involving offsets do not exceed the allocated buffer size. Implement checks to handle edge cases, such as full buffers, to prevent memory corruption.",
      "code_snippet": "static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx, ... ) {\n    if (link) {\n        struct pdu_data *pdu_data_tx;\n        u8_t pdu_data_tx_len;\n        u8_t offset;\n\n        pdu_data_tx = (void *)(tx->pdu + lll->packet_tx_head_offset);\n        ...\n\n        offset = lll->packet_tx_head_offset + pdu_data_tx_len;\n        if (offset < lll->packet_tx_head_len) {\n            lll->packet_tx_head_offset = offset;\n        } else if (offset == lll->packet_tx_head_len) {\n            lll->packet_tx_head_len = 0;\n            lll->packet_tx_head_offset = 0;\n        }\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23516",
      "patch_diff": "+            u8_t offset;\n+\n+            offset = lll->packet_tx_head_offset + pdu_data_tx_len;\n+            if (offset < lll->packet_tx_head_len) {\n+                lll->packet_tx_head_offset = offset;\n+            } else if (offset == lll->packet_tx_head_len) {\n+                lll->packet_tx_head_len = 0;\n+                lll->packet_tx_head_offset = 0;\n            }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Improper handling of the full-buffer case when the packet transmission head offset equals the packet transmission head length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using lll_conn_flush in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10061"
    ],
    "related_cwe": [
      "CWE-119,CWE-787"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000038",
    "vulnerability": "Improper handling of the full-buffer case in the Zephyr Bluetooth implementation can result in memory corruption. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "isr_close_conn"
    ],
    "functionality": "Handles the closing of a Bluetooth connection in the controller.",
    "call_patterns": [
      {
        "pattern": "isr_close_conn(subsys/bluetooth/controller/ll_sw/ctrl.c)",
        "description": "Vulnerable call chain leading to isr_close_conn (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to improper handling of buffer cases, ensure that all relevant conditions are checked before proceeding with operations that could lead to memory corruption. Specifically, validate the state of all relevant variables and ensure that any pending requests or acknowledgments are properly accounted for. This is particularly important in scenarios involving connection updates or channel mapping in Bluetooth implementations.",
      "code_snippet": "static inline void isr_close_conn(void) {\n    #if CONFIG_BT_CTLR_CONN_RSSI\n    // Existing code...\n\n    /* break latency based on ctrl procedure pending */\n    if (((_radio.conn_curr->llcp_ack != _radio.conn_curr->llcp_req) &&\n         ((_radio.conn_curr->llcp_type == LLCP_CONN_UPD) ||\n          (_radio.conn_curr->llcp_type == LLCP_CHAN_MAP))) ||\n        (_radio.conn_curr->llcp_cu.req != _radio.conn_curr->llcp_cu.ack)) {\n        _radio.conn_curr->latency_event = 0U;\n    }\n    // Existing code...\n    #endif /* CONFIG_BT_CTLR_CONN_RSSI */\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23091",
      "patch_diff": "if (((_radio.conn_curr->llcp_ack != _radio.conn_curr->llcp_req) &&\n     ((_radio.conn_curr->llcp_type == LLCP_CONN_UPD) ||\n      (_radio.conn_curr->llcp_type == LLCP_CHAN_MAP))) ||\n    (_radio.conn_curr->llcp_cu.req != _radio.conn_curr->llcp_cu.ack)) {"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Improper handling of the full-buffer case during connection updates can lead to memory corruption."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_close_conn in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10061"
    ],
    "related_cwe": [
      "CWE-119,CWE-787"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000039",
    "vulnerability": "Improper handling of the full-buffer case in the Zephyr Bluetooth implementation can result in memory corruption. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "isr_rx_conn_pkt"
    ],
    "functionality": "Handles incoming connection packets in the Bluetooth controller.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When handling buffer operations, always ensure that any offsets or lengths are checked against the maximum allowable values to prevent buffer overflows or memory corruption. Implement checks to ensure that the new offset does not exceed the buffer length before updating it. This is particularly important in functions that manipulate packet data in network protocols.",
      "code_snippet": "void isr_rx_conn_pkt(struct radio_pdu_node_rx *node_rx, ...) {\n    if (node_tx) {\n        u8_t pdu_data_tx_len;\n        u8_t offset;\n\n        pdu_data_tx = (void *)(node_tx->pdu_data + _radio.conn_curr->packet_tx_head_offset);\n        ...\n\n        offset = _radio.conn_curr->packet_tx_head_offset + pdu_data_tx_len;\n        if (offset < _radio.conn_curr->packet_tx_head_len) {\n            _radio.conn_curr->packet_tx_head_offset = offset;\n        } else if (offset == _radio.conn_curr->packet_tx_head_len) {\n            *tx_release = isr_rx_conn_pkt_release(node_tx);\n        }\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23517",
      "patch_diff": "diff --git a/subsys/bluetooth/controller/ll_sw/ctrl.c b/subsys/bluetooth/controller/ll_sw/ctrl.c\nindex d89e70aa541..eb4c0fea54e 100644\n--- a/subsys/bluetooth/controller/ll_sw/ctrl.c\n+++ b/subsys/bluetooth/controller/ll_sw/ctrl.c\n@@ -3788,6 +3788,7 @@ isr_rx_conn_pkt(struct radio_pdu_node_rx *node_rx,\n \n \t\tif (node_tx) {\n \t\t\tu8_t pdu_data_tx_len;\n+            u8_t offset;\n \n \t\t\tpdu_data_tx = (void *)(node_tx->pdu_data +\n \t\t\t\t\t_radio.conn_curr->packet_tx_head_offset);\n@@ -3806,10 +3807,13 @@ isr_rx_conn_pkt(struct radio_pdu_node_rx *node_rx,\n \t\t\t}\n \n-            _radio.conn_curr->packet_tx_head_offset +=\n-                pdu_data_tx_len;\n-            if (_radio.conn_curr->packet_tx_head_offset ==\n-                _radio.conn_curr->packet_tx_head_len) {\n+            offset = _radio.conn_curr->packet_tx_head_offset +\n+                    pdu_data_tx_len;\n+            if (offset < _radio.conn_curr->packet_tx_head_len) {\n+                _radio.conn_curr->packet_tx_head_offset =\n+                    offset;\n+            } else if (offset ==\n+                   _radio.conn_curr->packet_tx_head_len) {\n \t\t\t\t*tx_release = isr_rx_conn_pkt_release(node_tx);\n \t\t\t}\n \t\t}\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Improper handling of the full-buffer case can lead to memory corruption when the offset exceeds the packet length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_rx_conn_pkt in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10061"
    ],
    "related_cwe": [
      "CWE-119,CWE-787"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000040",
    "vulnerability": "An off-by-one error in the Zephyr project MQTT packet length decoder can result in memory corruption and possible remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_decode"
    ],
    "functionality": "Decodes the PUBLISH message in the MQTT protocol.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length of the incoming message is validated against the expected length before processing. Specifically, check if the variable header length is greater than the total length of the message. If it is, log an error and return an appropriate error code to prevent further processing of the malformed message.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n\n    if (flags & MQTT_PUBLISH_FLAG_RETAIN) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/11b7a37d9a0b438270421b224221d91929843de4",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the variable header length is larger than the total length of the received PUBLISH message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10062"
    ],
    "related_cwe": [
      "CWE-193"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000041",
    "vulnerability": "An off-by-one error in the Zephyr project MQTT packet length decoder can result in memory corruption and possible remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_ack_decode"
    ],
    "functionality": "Decodes the PUBLISH message in the MQTT protocol.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length of the incoming message is validated against the expected length before processing. Specifically, check if the variable header length is greater than the total length of the message. If it is, log an error and return an appropriate error code to prevent further processing of the malformed message.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n\n    if (flags & MQTT_PUBLISH_FLAG_RETAIN) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/11b7a37d9a0b438270421b224221d91929843de4",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the variable header length is larger than the total length of the received PUBLISH message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_ack_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10062"
    ],
    "related_cwe": [
      "CWE-193"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000042",
    "vulnerability": "An off-by-one error in the Zephyr project MQTT packet length decoder can result in memory corruption and possible remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_receive_decode"
    ],
    "functionality": "Decodes the PUBLISH message in the MQTT protocol.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length of the incoming message is validated against the expected length before processing. Specifically, check if the variable header length is greater than the total length of the message. If it is, log an error and return an appropriate error code to prevent further processing of the malformed message.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n\n    if (flags & MQTT_PUBLISH_FLAG_RETAIN) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/11b7a37d9a0b438270421b224221d91929843de4",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the variable header length is larger than the total length of the received PUBLISH message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_receive_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10062"
    ],
    "related_cwe": [
      "CWE-193"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000043",
    "vulnerability": "A remote adversary with the ability to send arbitrary CoAP packets to be parsed by Zephyr is able to cause a denial of service. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "parse_option"
    ],
    "functionality": "This function parses CoAP options from a given data buffer.",
    "call_patterns": [
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_packet_parse(subsys/net/lib/coap/coap.c)<-install_update_cb(lib/updatehub/updatehub.c)<-install_update(lib/updatehub/updatehub.c)<-updatehub_update(lib/updatehub/updatehub.c)<-cmd_run(lib/updatehub/shell.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_packet_parse(subsys/net/lib/coap/coap.c)<-install_update_cb(lib/updatehub/updatehub.c)<-install_update(lib/updatehub/updatehub.c)<-updatehub_update(lib/updatehub/updatehub.c)<-autohandler(lib/updatehub/updatehub.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_packet_parse(subsys/net/lib/coap/coap.c)<-process_simple_coap_reply(samples/net/sockets/coap_client/src/coap-client.c)<-send_simple_coap_msgs_and_wait_for_reply(samples/net/sockets/coap_client/src/coap-client.c)<-main(samples/net/sockets/coap_client/src/coap-client.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_packet_parse(subsys/net/lib/coap/coap.c)<-process_coap_request(samples/net/sockets/coap_server/src/coap-server.c)<-process_client_request(samples/net/sockets/coap_server/src/coap-server.c)<-main(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_packet_parse(subsys/net/lib/coap/coap.c)<-lwm2m_udp_receive(subsys/net/lib/lwm2m/lwm2m_engine.c)<-socket_receive_loop(subsys/net/lib/lwm2m/lwm2m_engine.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-query_get(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_option_int(samples/net/sockets/coap_server/src/coap-server.c)<-large_update_put(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_option_int(samples/net/sockets/coap_server/src/coap-server.c)<-large_create_post(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_block_option(subsys/net/lib/coap/coap.c)<-coap_update_from_block(subsys/net/lib/coap/coap.c)<-large_get(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_block_option(subsys/net/lib/coap/coap.c)<-coap_update_from_block(subsys/net/lib/coap/coap.c)<-handle_request(subsys/net/lib/lwm2m/lwm2m_engine.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_block_option(subsys/net/lib/coap/coap.c)<-coap_update_from_block(subsys/net/lib/coap/coap.c)<-do_firmware_transfer_reply_cb(subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_observe_option(subsys/net/lib/coap/coap.c)<-coap_reply_init(subsys/net/lib/coap/coap.c)<-lwm2m_init_message(subsys/net/lib/lwm2m/lwm2m_engine.c)<-transfer_request(subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c)<-do_transmit_timeout_cb(subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_observe_option(subsys/net/lib/coap/coap.c)<-coap_reply_init(subsys/net/lib/coap/coap.c)<-lwm2m_init_message(subsys/net/lib/lwm2m/lwm2m_engine.c)<-transfer_request(subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c)<-firmware_transfer(subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_observe_option(subsys/net/lib/coap/coap.c)<-coap_reply_init(subsys/net/lib/coap/coap.c)<-lwm2m_init_message(subsys/net/lib/lwm2m/lwm2m_engine.c)<-sm_send_registration(subsys/net/lib/lwm2m/lwm2m_rd_client.c)<-sm_do_registration(subsys/net/lib/lwm2m/lwm2m_rd_client.c)<-lwm2m_rd_client_service(subsys/net/lib/lwm2m/lwm2m_rd_client.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_observe_option(subsys/net/lib/coap/coap.c)<-coap_request_is_observe(subsys/net/lib/coap/coap.c)<-obs_get(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-coap_well_known_core_get(subsys/net/lib/coap/coap_link_format.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-get_option_int(subsys/net/lib/lwm2m/lwm2m_engine.c)<-lwm2m_write_handler(subsys/net/lib/lwm2m/lwm2m_engine.c)<-do_write_op_json(subsys/net/lib/lwm2m/lwm2m_rw_json.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      },
      {
        "pattern": "parse_option(subsys/net/lib/coap/coap.c)<-coap_find_options(subsys/net/lib/coap/coap.c)<-do_registration_reply_cb(subsys/net/lib/lwm2m/lwm2m_rd_client.c)",
        "description": "Vulnerable call chain leading to parse_option (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24435",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An adversary sends arbitrary CoAP packets that lead to integer overflow during option parsing."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using parse_option in vulnerable versions (v2.2.0 → v2.2.1)"
    ],
    "related_cve": [
      "CVE-2020-10063"
    ],
    "related_cwe": [
      "CWE-190"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000044",
    "vulnerability": "A remote adversary with the ability to send arbitrary CoAP packets to be parsed by Zephyr is able to cause a denial of service. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "coap_packet_parse"
    ],
    "functionality": "This function parses CoAP options from a given data buffer.",
    "call_patterns": [
      {
        "pattern": "coap_packet_parse(subsys/net/lib/coap/coap.c)<-install_update_cb(lib/updatehub/updatehub.c)<-install_update(lib/updatehub/updatehub.c)<-updatehub_update(lib/updatehub/updatehub.c)<-cmd_run(lib/updatehub/shell.c)",
        "description": "Vulnerable call chain leading to coap_packet_parse (version: v2.2.0)"
      },
      {
        "pattern": "coap_packet_parse(subsys/net/lib/coap/coap.c)<-install_update_cb(lib/updatehub/updatehub.c)<-install_update(lib/updatehub/updatehub.c)<-updatehub_update(lib/updatehub/updatehub.c)<-autohandler(lib/updatehub/updatehub.c)",
        "description": "Vulnerable call chain leading to coap_packet_parse (version: v2.2.0)"
      },
      {
        "pattern": "coap_packet_parse(subsys/net/lib/coap/coap.c)<-process_simple_coap_reply(samples/net/sockets/coap_client/src/coap-client.c)<-send_simple_coap_msgs_and_wait_for_reply(samples/net/sockets/coap_client/src/coap-client.c)<-main(samples/net/sockets/coap_client/src/coap-client.c)",
        "description": "Vulnerable call chain leading to coap_packet_parse (version: v2.2.0)"
      },
      {
        "pattern": "coap_packet_parse(subsys/net/lib/coap/coap.c)<-process_coap_request(samples/net/sockets/coap_server/src/coap-server.c)<-process_client_request(samples/net/sockets/coap_server/src/coap-server.c)<-main(samples/net/sockets/coap_server/src/coap-server.c)",
        "description": "Vulnerable call chain leading to coap_packet_parse (version: v2.2.0)"
      },
      {
        "pattern": "coap_packet_parse(subsys/net/lib/coap/coap.c)<-lwm2m_udp_receive(subsys/net/lib/lwm2m/lwm2m_engine.c)<-socket_receive_loop(subsys/net/lib/lwm2m/lwm2m_engine.c)",
        "description": "Vulnerable call chain leading to coap_packet_parse (version: v2.2.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any arithmetic operations involving user-controlled data are checked for potential overflows. Use safe addition functions that return an error if an overflow occurs, especially when dealing with lengths or offsets that can be influenced by external input. Always validate the input data before processing it to prevent denial of service or other unintended behaviors.",
      "code_snippet": "if (u16_add_overflow(*opt_len, hdr_len, opt_len)) {\n    return -EINVAL;\n}\nif (u16_add_overflow(*opt_delta, delta, opt_delta) ||\n    u16_add_overflow(*opt_len, len, opt_len)) {\n    return -EINVAL;\n}\nif (u16_add_overflow(*pos, len, pos)) {\n    return -EINVAL;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24531",
      "patch_diff": "+\tif (u16_add_overflow(*opt_len, hdr_len, opt_len)) {\n+\t\treturn -EINVAL;\n+\t}\n+\tif (u16_add_overflow(*opt_delta, delta, opt_delta) ||\n+\t    u16_add_overflow(*opt_len, len, opt_len)) {\n+\t\treturn -EINVAL;\n+\t}\n+\tif (u16_add_overflow(*pos, len, pos)) {\n+\t\treturn -EINVAL;\n+\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An adversary sends arbitrary CoAP packets that lead to integer overflow during option parsing."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using coap_packet_parse in vulnerable versions (v2.2.0 → v2.2.1)"
    ],
    "related_cve": [
      "CVE-2020-10063"
    ],
    "related_cwe": [
      "CWE-190"
    ],
    "vulnerable_version": "v2.2.0"
  },
  {
    "id": "VULN-000045",
    "vulnerability": "In the Zephyr project Bluetooth subsystem, certain duplicate and back-to-back packets can cause incorrect behavior, resulting in a denial of service. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "length_req_rsp_recv"
    ],
    "functionality": "Handles the reception of length request response packets in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "length_req_rsp_recv(subsys/bluetooth/controller/ll_sw/ull_conn.c)",
        "description": "Vulnerable call chain leading to length_req_rsp_recv (version: v2.2.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the function handling incoming requests validates the request's context. Specifically, check if the request is a duplicate or if it follows a valid sequence of operations. If the request is invalid, drop it and handle the state appropriately to prevent denial of service. Always assert the expected opcode and manage the connection state to avoid processing invalid requests.",
      "code_snippet": "static inline int length_req_rsp_recv(struct ll_conn *conn, memq_link_t *link, struct node_rx_pdu *pdu_rx) {\n    #if defined(CONFIG_BT_CTLR_PHY)\n    // ... other code ...\n    #endif /* CONFIG_BT_CTLR_PHY */\n    } else {\n        /* Drop response with no Local initiated request and duplicate requests. */\n        if (pdu_rx->llctrl.opcode != PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {\n            mem_release(tx, &mem_conn_tx_ctrl.free);\n            /* Defer new request if previous in resize state */\n            if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {\n                return -EBUSY;\n            }\n        }\n        return 0;\n    }\n    send_length_resp:\n    // ... other code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23964",
      "patch_diff": "if (pdu_rx->llctrl.opcode != PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {\n    mem_release(tx, &mem_conn_tx_ctrl.free);\n    /* Defer new request if previous in resize state */\n    if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {\n        return -EBUSY;\n    }\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Receiving duplicate LENGTH_REQ PDUs or back-to-back LENGTH_REQ PDUs without a local initiated request."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using length_req_rsp_recv in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10068"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.0"
  },
  {
    "id": "VULN-000046",
    "vulnerability": "In the Zephyr project Bluetooth subsystem, certain duplicate and back-to-back packets can cause incorrect behavior, resulting in a denial of service. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "isr_rx_conn_pkt_ctrl_dle"
    ],
    "functionality": "Handles reception of connection packet control data in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "isr_rx_conn_pkt_ctrl_dle(subsys/bluetooth/controller/ll_sw/ctrl.c)",
        "description": "Vulnerable call chain leading to isr_rx_conn_pkt_ctrl_dle (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the function handling incoming packets validates the requests properly. Specifically, check for duplicate or back-to-back requests and handle them appropriately to prevent denial of service. Implement checks to drop invalid responses and defer processing if the system is already in a state that cannot handle new requests. Always assert the expected opcode to ensure that only valid packets are processed.",
      "code_snippet": "static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx, struct node_tx *node_tx, u8_t *rx_enqueue) {\n    if (pdu_data_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {\n        *rx_enqueue = 1U;\n    } else {\n        /* Drop response with no Local initiated request and duplicate requests. */\n        if (pdu_data_rx->llctrl.opcode != PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {\n            mem_release(node_tx, &_radio.pkt_tx_ctrl_free);\n            /* Defer new request if previous in resize state */\n            if (_radio.conn_curr->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {\n                return 1U;\n            }\n        }\n        return 0;\n    }\n\nsend_length_resp:\n    // ... (rest of the function)\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23708",
      "patch_diff": "@@ -2692,9 +2692,21 @@ static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,\n \n-        /* Drop response with no Local initiated request. */\n-        LL_ASSERT(pdu_data_rx->llctrl.opcode ==\n-              PDU_DATA_LLCTRL_TYPE_LENGTH_RSP);\n+        /* Drop response with no Local initiated request and duplicate\n+         * requests.\n+         */\n+        if (pdu_data_rx->llctrl.opcode !=\n+            PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {\n+            mem_release(node_tx, &_radio.pkt_tx_ctrl_free);\n+\n+            /* Defer new request if previous in resize state */\n+            if (_radio.conn_curr->llcp_length.state ==\n+                LLCP_LENGTH_STATE_RESIZE) {\n+                return 1U;\n+            }\n+        }\n+\n+        return 0;\n    }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Receiving back-to-back or duplicate LENGTH_REQ PDUs without a local initiated request."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_rx_conn_pkt_ctrl_dle in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10068"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000047",
    "vulnerability": "In the Zephyr project Bluetooth subsystem, certain duplicate and back-to-back packets can cause incorrect behavior, resulting in a denial of service. This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions, and version 1.14.0 and later versions.",
    "affected_functions": [
      "isr_close_conn"
    ],
    "functionality": "This function handles the closing of a Bluetooth connection and manages latency based on control procedures.",
    "call_patterns": [
      {
        "pattern": "isr_close_conn(subsys/bluetooth/controller/ll_sw/ctrl.c)",
        "description": "Vulnerable call chain leading to isr_close_conn (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23091",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability can be triggered by sending certain duplicate and back-to-back packets during a connection update procedure."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_close_conn in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10068"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000048",
    "vulnerability": "In the Zephyr Project MQTT code, improper bounds checking can result in memory corruption and possibly remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_decode"
    ],
    "functionality": "Decodes a PUBLISH MQTT message and extracts its payload.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input data is validated before processing. Specifically, check that the length of any variable header or payload does not exceed the total length of the message. If a length check fails, log an error and return an appropriate error code to prevent further processing of malformed messages.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n    // Calculate variable header length\n    if (flags & MQTT_PUBLISH_FLAG_QOS_1) {\n        var_header_length += sizeof(u16_t);\n    }\n    if (flags & MQTT_PUBLISH_FLAG_QOS_2) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/0b39cbf3c01d7feec9d0dd7cc7e0e374b6113542",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the variable header length is larger than the total length of the received PUBLISH message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10070"
    ],
    "related_cwe": [
      "CWE-120,CWE-190"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000049",
    "vulnerability": "In the Zephyr Project MQTT code, improper bounds checking can result in memory corruption and possibly remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_ack_decode"
    ],
    "functionality": "Decodes a PUBLISH MQTT message and extracts its payload.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input data is validated before processing. Specifically, check that the length of any variable header or payload does not exceed the total length of the message. If a length check fails, log an error and return an appropriate error code to prevent further processing of malformed messages.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n    // Calculate variable header length\n    if (flags & MQTT_PUBLISH_FLAG_QOS_1) {\n        var_header_length += sizeof(u16_t);\n    }\n    if (flags & MQTT_PUBLISH_FLAG_QOS_2) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/0b39cbf3c01d7feec9d0dd7cc7e0e374b6113542",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the variable header length is larger than the total length of the received PUBLISH message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_ack_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10070"
    ],
    "related_cwe": [
      "CWE-120,CWE-190"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000050",
    "vulnerability": "In the Zephyr Project MQTT code, improper bounds checking can result in memory corruption and possibly remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_receive_decode"
    ],
    "functionality": "Decodes a PUBLISH MQTT message and extracts its payload.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input data is validated before processing. Specifically, check that the length of any variable header or payload does not exceed the total length of the message. If a length check fails, log an error and return an appropriate error code to prevent further processing of malformed messages.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n    // Calculate variable header length\n    if (flags & MQTT_PUBLISH_FLAG_QOS_1) {\n        var_header_length += sizeof(u16_t);\n    }\n    if (flags & MQTT_PUBLISH_FLAG_QOS_2) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/0b39cbf3c01d7feec9d0dd7cc7e0e374b6113542",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the variable header length is larger than the total length of the received PUBLISH message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_receive_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10070"
    ],
    "related_cwe": [
      "CWE-120,CWE-190"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000051",
    "vulnerability": "The Zephyr MQTT parsing code performs insufficient checking of the length field on publish messages, allowing a buffer overflow and potentially remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_decode"
    ],
    "functionality": "Decodes a PUBLISH message in the MQTT protocol.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length fields in incoming messages are validated against the actual size of the message. Specifically, check that the total length of the message is greater than or equal to the length of the variable header before processing the payload. This prevents buffer overflows and ensures that the application can handle malformed messages gracefully.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n    // Calculate variable header length\n    if (flags & MQTT_PUBLISH_FLAG_QOS_1) {\n        var_header_length += sizeof(u16_t);\n    }\n    if (flags & MQTT_PUBLISH_FLAG_QOS_2) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/989c4713ba429aa5105fe476b4d629718f3e6082",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the received PUBLISH message has a variable header length that is larger than the total length of the message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10071"
    ],
    "related_cwe": [
      "CWE-120,CWE-129"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000052",
    "vulnerability": "The Zephyr MQTT parsing code performs insufficient checking of the length field on publish messages, allowing a buffer overflow and potentially remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_ack_decode"
    ],
    "functionality": "Decodes a PUBLISH message in the MQTT protocol.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_ack_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length fields in incoming messages are validated against the actual size of the message. Specifically, check that the total length of the message is greater than or equal to the length of the variable header before processing the payload. This prevents buffer overflows and ensures that the application can handle malformed messages gracefully.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n    // Calculate variable header length\n    if (flags & MQTT_PUBLISH_FLAG_QOS_1) {\n        var_header_length += sizeof(u16_t);\n    }\n    if (flags & MQTT_PUBLISH_FLAG_QOS_2) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/989c4713ba429aa5105fe476b4d629718f3e6082",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the received PUBLISH message has a variable header length that is larger than the total length of the message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_ack_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10071"
    ],
    "related_cwe": [
      "CWE-120,CWE-129"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000053",
    "vulnerability": "The Zephyr MQTT parsing code performs insufficient checking of the length field on publish messages, allowing a buffer overflow and potentially remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
    "affected_functions": [
      "publish_receive_decode"
    ],
    "functionality": "Decodes a PUBLISH message in the MQTT protocol.",
    "call_patterns": [
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-mqtt_startup(samples/net/cloud/google_iot_mqtt/src/protocol.c)<-main(samples/net/cloud/google_iot_mqtt/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-publish_message(samples/net/cloud/mqtt_azure/src/main.c)<-connect_to_cloud_and_publish(samples/net/cloud/mqtt_azure/src/main.c)<-main(samples/net/cloud/mqtt_azure/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      },
      {
        "pattern": "publish_decode(subsys/net/lib/mqtt/mqtt_decoder.c)<-mqtt_handle_packet(subsys/net/lib/mqtt/mqtt_rx.c)<-mqtt_handle_rx(subsys/net/lib/mqtt/mqtt_rx.c)<-client_read(subsys/net/lib/mqtt/mqtt.c)<-mqtt_input(subsys/net/lib/mqtt/mqtt.c)<-try_to_connect(samples/net/mqtt_publisher/src/main.c)<-publisher(samples/net/mqtt_publisher/src/main.c)<-main(samples/net/mqtt_publisher/src/main.c)",
        "description": "Vulnerable call chain leading to publish_receive_decode (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length fields in incoming messages are validated against the actual size of the message. Specifically, check that the total length of the message is greater than or equal to the length of the variable header before processing the payload. This prevents buffer overflows and ensures that the application can handle malformed messages gracefully.",
      "code_snippet": "int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf, struct mqtt_publish_param *param) {\n    u32_t var_header_length = 0;\n    // Calculate variable header length\n    if (flags & MQTT_PUBLISH_FLAG_QOS_1) {\n        var_header_length += sizeof(u16_t);\n    }\n    if (flags & MQTT_PUBLISH_FLAG_QOS_2) {\n        var_header_length += sizeof(u16_t);\n    }\n\n    if (var_length < var_header_length) {\n        MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n                 \"than total length (%u)\", var_header_length,\n                 var_length);\n        return -EINVAL;\n    }\n\n    param->message.payload.data = NULL;\n    param->message.payload.len = var_length - var_header_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23821/commits/989c4713ba429aa5105fe476b4d629718f3e6082",
      "patch_diff": "if (var_length < var_header_length) {\n    MQTT_ERR(\"Corrupted PUBLISH message, header length (%u) larger \"\n             \"than total length (%u)\", var_header_length,\n             var_length);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the received PUBLISH message has a variable header length that is larger than the total length of the message."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using publish_receive_decode in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10071"
    ],
    "related_cwe": [
      "CWE-120,CWE-129"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000054",
    "vulnerability": "Improper Input Frame Validation in ieee802154 Processing. Zephyr versions >= v1.14.2, >= v2.2.0 contain Stack-based Buffer Overflow (CWE-121), Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3gvq-h42f-v3c7",
    "affected_functions": [
      "ieee802154_recv"
    ],
    "functionality": "Processes received IEEE 802.15.4 packets.",
    "call_patterns": [
      {
        "pattern": "ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_recv (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all functions that manipulate buffer lengths validate the size of the buffer before performing operations that depend on those lengths. Specifically, when validating frames or headers, check that the remaining length after each operation is sufficient to accommodate the expected data. If the length is insufficient, return an error or handle the situation gracefully to prevent underflows or out-of-bounds accesses.",
      "code_snippet": "static enum net_verdict ieee802154_recv(struct net_if *iface, struct net_pkt *pkt) {\n    struct ieee802154_mpdu mpdu;\n    if (!ieee802154_validate_frame(net_pkt_data(pkt), net_pkt_get_len(pkt), &mpdu)) {\n        return NET_DROP;\n    }\n    hdr_len = (u8_t *)mpdu.payload - net_pkt_data(pkt);\n    if (hdr_len > net_pkt_get_len(pkt)) {\n        return NET_DROP;\n    }\n    net_buf_pull(pkt->buffer, hdr_len);\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24971",
      "patch_diff": "if (hdr_len > net_pkt_get_len(pkt)) {\n    return NET_DROP;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An attacker-controlled packet with a small size is received."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_recv in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10064"
    ],
    "related_cwe": [
      "CWE-121,CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000055",
    "vulnerability": "Improper Input Frame Validation in ieee802154 Processing. Zephyr versions >= v1.14.2, >= v2.2.0 contain Stack-based Buffer Overflow (CWE-121), Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3gvq-h42f-v3c7",
    "affected_functions": [
      "ieee802154_validate_frame"
    ],
    "functionality": "Validates the structure and content of an IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_compute_header_size(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_send(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_validate_frame (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all functions that manipulate buffer lengths or sizes validate the input length against the expected minimum size. Specifically, when validating frames or headers, check that the remaining length after processing each field does not fall below zero. This can be achieved by passing a length parameter to functions that modify the buffer and checking it before any operations that depend on it.",
      "code_snippet": "bool ieee802154_validate_frame(u8_t *buf, u8_t length, struct ieee802154_mpdu *mpdu) {\n    if (length < IEEE802154_MIN_LENGTH) {\n        return false;\n    }\n\n    mpdu->mhr.fs = ieee802154_validate_fc_seq(buf, &p_buf, &length);\n    if (!mpdu->mhr.fs) {\n        return false;\n    }\n\n    mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.dst_addr_mode, false);\n    mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.src_addr_mode, (mpdu->mhr.fs->fc.pan_id_comp));\n\n    #ifdef CONFIG_NET_L2_IEEE802154_SECURITY\n    if (mpdu->mhr.fs->fc.security_enabled) {\n        mpdu->mhr.aux_sec = ieee802154_validate_aux_security_hdr(p_buf, &p_buf, &length);\n        if (!mpdu->mhr.aux_sec) {\n            return false;\n        }\n    }\n    #endif\n\n    return validate_payload_and_mfr(mpdu, buf, p_buf, &length);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24971",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -389,25 +437,26 @@ bool ieee802154_validate_frame(u8_t *buf, u8_t length,\n     mpdu->mhr.fs = ieee802154_validate_fc_seq(buf, &p_buf);\n-    if (!mpdu->mhr.fs) {\n+    mpdu->mhr.fs = ieee802154_validate_fc_seq(buf, &p_buf, &length);\n+    if (!mpdu->mhr.fs) {\n         return false;\n     }\n \n     mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf,\n-                                       mpdu->mhr.fs->fc.dst_addr_mode,\n-                                       false);\n+                                       mpdu->mhr.fs->fc.dst_addr_mode,\n+                                       &length,\n+                                       false);\n     mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf,\n-                                       mpdu->mhr.fs->fc.src_addr_mode,\n-                                       (mpdu->mhr.fs->fc.pan_id_comp));\n+                                       mpdu->mhr.fs->fc.src_addr_mode,\n+                                       &length,\n+                                       (mpdu->mhr.fs->fc.pan_id_comp));\n \n     #ifdef CONFIG_NET_L2_IEEE802154_SECURITY\n     if (mpdu->mhr.fs->fc.security_enabled) {\n         mpdu->mhr.aux_sec = ieee802154_validate_aux_security_hdr(p_buf, &p_buf,\n-                                                              &length);\n+                                                              &length);\n         if (!mpdu->mhr.aux_sec) {\n             return false;\n         }\n     }\n     #endif\n \n     return validate_payload_and_mfr(mpdu, buf, p_buf, &length);\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A frame with a size less than the minimum required size is processed."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_validate_frame in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10064"
    ],
    "related_cwe": [
      "CWE-121,CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000056",
    "vulnerability": "Improper Input Frame Validation in ieee802154 Processing. Zephyr versions >= v1.14.2, >= v2.2.0 contain Stack-based Buffer Overflow (CWE-121), Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3gvq-h42f-v3c7",
    "affected_functions": [
      "ieee802154_compute_header_size"
    ],
    "functionality": "Validates the structure and content of an IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_compute_header_size(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_send(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_compute_header_size (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all functions that manipulate buffer lengths or sizes validate the input length against the expected minimum size. Specifically, when validating frames or headers, check that the remaining length after processing each field does not fall below zero. This can be achieved by passing a length parameter to functions that modify the buffer and checking it before any operations that depend on it.",
      "code_snippet": "bool ieee802154_validate_frame(u8_t *buf, u8_t length, struct ieee802154_mpdu *mpdu) {\n    if (length < IEEE802154_MIN_LENGTH) {\n        return false;\n    }\n\n    mpdu->mhr.fs = ieee802154_validate_fc_seq(buf, &p_buf, &length);\n    if (!mpdu->mhr.fs) {\n        return false;\n    }\n\n    mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.dst_addr_mode, false);\n    mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.src_addr_mode, (mpdu->mhr.fs->fc.pan_id_comp));\n\n    #ifdef CONFIG_NET_L2_IEEE802154_SECURITY\n    if (mpdu->mhr.fs->fc.security_enabled) {\n        mpdu->mhr.aux_sec = ieee802154_validate_aux_security_hdr(p_buf, &p_buf, &length);\n        if (!mpdu->mhr.aux_sec) {\n            return false;\n        }\n    }\n    #endif\n\n    return validate_payload_and_mfr(mpdu, buf, p_buf, &length);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33451",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -389,25 +437,26 @@ bool ieee802154_validate_frame(u8_t *buf, u8_t length,\n     if (length < IEEE802154_MIN_LENGTH) {\n         return false;\n     }\n \n-    mpdu->mhr.fs = ieee802154_validate_fc_seq(buf, &p_buf);\n+    mpdu->mhr.fs = ieee802154_validate_fc_seq(buf, &p_buf, &length);\n     if (!mpdu->mhr.fs) {\n         return false;\n     }\n \n-    mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf,\n+    mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length,\n     mpdu->mhr.fs->fc.dst_addr_mode,\n     false);\n \n-    mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf,\n+    mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length,\n     mpdu->mhr.fs->fc.src_addr_mode,\n     (mpdu->mhr.fs->fc.pan_id_comp));\n \n #ifdef CONFIG_NET_L2_IEEE802154_SECURITY\n     if (mpdu->mhr.fs->fc.security_enabled) {\n         mpdu->mhr.aux_sec =\n-            ieee802154_validate_aux_security_hdr(p_buf, &p_buf);\n+            ieee802154_validate_aux_security_hdr(p_buf, &p_buf, &length);\n         if (!mpdu->mhr.aux_sec) {\n             return false;\n         }\n     }\n #endif\n \n-    return validate_payload_and_mfr(mpdu, buf, p_buf, length);\n+    return validate_payload_and_mfr(mpdu, buf, p_buf, &length);\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A frame with a size less than the minimum required size is processed."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_compute_header_size in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10064"
    ],
    "related_cwe": [
      "CWE-121,CWE-122,CWE-787"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000057",
    "vulnerability": "Improper Input Frame Validation in ieee802154 Processing. Zephyr versions >= v1.14.2, >= v2.2.0 contain Stack-based Buffer Overflow (CWE-121), Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3gvq-h42f-v3c7",
    "affected_functions": [
      "validate_addr"
    ],
    "functionality": "Validates the address fields in an IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_aux_security_hdr(subsys/net/l2/ieee802154/ieee802154_frame.c)",
        "description": "Vulnerable call chain leading to validate_addr (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all functions that manipulate buffer lengths or sizes validate the available length before performing operations that depend on those lengths. Specifically, when modifying pointers or calculating sizes based on input data, always check that the resulting sizes do not exceed the allocated buffer size. This includes validating lengths after any modifications to the buffer or when passing lengths to other functions.",
      "code_snippet": "static inline struct ieee802154_address_field *\nvalidate_addr(u8_t *buf, u8_t **p_buf, u8_t *length,\n      enum ieee802154_addressing_mode mode,\n      bool pan_id_compression) {\n    u8_t len = 0;\n\n    *p_buf = buf;\n\n    if (!pan_id_compression) {\n        len = IEEE802154_PAN_ID_LENGTH;\n    }\n\n    if (mode == IEEE802154_ADDR_MODE_SHORT) {\n        len += IEEE802154_SHORT_ADDR_LENGTH;\n    } else {\n        len += IEEE802154_EXT_ADDR_LENGTH;\n    }\n\n    if (len > *length) {\n        return NULL;\n    }\n\n    *p_buf += len;\n    *length -= len;\n\n    return (struct ieee802154_address_field *)buf;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33451",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex b320a6d141c4e..452c9a416478c 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -81,17 +82,20 @@ struct ieee802154_fcf_seq *ieee802154_validate_fc_seq(u8_t *buf, u8_t **p_buf)\n \n if (p_buf) {\n-        *p_buf = buf + 3;\n+        *length -= IEEE802154_FCF_SEQ_LENGTH;\n+        *p_buf = buf + IEEE802154_FCF_SEQ_LENGTH;\n }\n \n return fs;\n }\n \n static inline struct ieee802154_address_field *\n-validate_addr(u8_t *buf, u8_t **p_buf,\n+validate_addr(u8_t *buf, u8_t **p_buf, u8_t *length,\n      enum ieee802154_addressing_mode mode,\n      bool pan_id_compression) {\n+    u8_t len = 0;\n+\n    *p_buf = buf;\n \n    if (!pan_id_compression) {\n-        *p_buf += IEEE802154_PAN_ID_LENGTH;\n+        len = IEEE802154_PAN_ID_LENGTH;\n    }\n \n    if (mode == IEEE802154_ADDR_MODE_SHORT) {\n-        *p_buf += IEEE802154_SHORT_ADDR_LENGTH;\n+        len += IEEE802154_SHORT_ADDR_LENGTH;\n    } else {\n        /* IEEE802154_ADDR_MODE_EXTENDED */\n-        *p_buf += IEEE802154_EXT_ADDR_LENGTH;\n+        len += IEEE802154_EXT_ADDR_LENGTH;\n    }\n \n+    if (len > *length) {\n+        return NULL;\n+    }\n+\n    *p_buf += len;\n    *length -= len;\n \n    return (struct ieee802154_address_field *)buf;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Address fields exceed the available buffer length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using validate_addr in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10064"
    ],
    "related_cwe": [
      "CWE-121,CWE-122,CWE-787"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000058",
    "vulnerability": "Improper Input Frame Validation in ieee802154 Processing. Zephyr versions >= v1.14.2, >= v2.2.0 contain Stack-based Buffer Overflow (CWE-121), Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3gvq-h42f-v3c7",
    "affected_functions": [
      "ieee802154_validate_aux_security_hdr"
    ],
    "functionality": "Validates the address fields in an IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_aux_security_hdr(subsys/net/l2/ieee802154/ieee802154_frame.c)",
        "description": "Vulnerable call chain leading to ieee802154_validate_aux_security_hdr (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all functions that manipulate buffer lengths or sizes validate the available length before performing operations that depend on those lengths. Specifically, when modifying pointers or calculating sizes based on input data, always check that the resulting sizes do not exceed the allocated buffer size. This includes validating lengths after any modifications to the buffer or when passing lengths to other functions.",
      "code_snippet": "static inline struct ieee802154_address_field *\nvalidate_addr(u8_t *buf, u8_t **p_buf, u8_t *length,\n      enum ieee802154_addressing_mode mode,\n      bool pan_id_compression) {\n    u8_t len = 0;\n\n    *p_buf = buf;\n\n    if (!pan_id_compression) {\n        len = IEEE802154_PAN_ID_LENGTH;\n    }\n\n    if (mode == IEEE802154_ADDR_MODE_SHORT) {\n        len += IEEE802154_SHORT_ADDR_LENGTH;\n    } else {\n        len += IEEE802154_EXT_ADDR_LENGTH;\n    }\n\n    if (len > *length) {\n        return NULL;\n    }\n\n    *p_buf += len;\n    *length -= len;\n\n    return (struct ieee802154_address_field *)buf;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33451",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex b320a6d141c4e..452c9a416478c 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -81,17 +82,20 @@ struct ieee802154_fcf_seq *ieee802154_validate_fc_seq(u8_t *buf, u8_t **p_buf)\n \n if (p_buf) {\n-        *p_buf = buf + 3;\n+        *length -= IEEE802154_FCF_SEQ_LENGTH;\n+        *p_buf = buf + IEEE802154_FCF_SEQ_LENGTH;\n }\n \n return fs;\n }\n \n static inline struct ieee802154_address_field *\n-validate_addr(u8_t *buf, u8_t **p_buf,\n+validate_addr(u8_t *buf, u8_t **p_buf, u8_t *length,\n      enum ieee802154_addressing_mode mode,\n      bool pan_id_compression) {\n+    u8_t len = 0;\n+\n    *p_buf = buf;\n \n    if (!pan_id_compression) {\n-        *p_buf += IEEE802154_PAN_ID_LENGTH;\n+        len = IEEE802154_PAN_ID_LENGTH;\n    }\n \n    if (mode == IEEE802154_ADDR_MODE_SHORT) {\n-        *p_buf += IEEE802154_SHORT_ADDR_LENGTH;\n+        len += IEEE802154_SHORT_ADDR_LENGTH;\n    } else {\n        /* IEEE802154_ADDR_MODE_EXTENDED */\n-        *p_buf += IEEE802154_EXT_ADDR_LENGTH;\n+        len += IEEE802154_EXT_ADDR_LENGTH;\n    }\n \n+    if (len > *length) {\n+        return NULL;\n+    }\n+\n    *p_buf += len;\n    *length -= len;\n \n    return (struct ieee802154_address_field *)buf;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Address fields exceed the available buffer length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_validate_aux_security_hdr in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10064"
    ],
    "related_cwe": [
      "CWE-121,CWE-122,CWE-787"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000059",
    "vulnerability": "Improper Input Frame Validation in ieee802154 Processing. Zephyr versions >= v1.14.2, >= v2.2.0 contain Stack-based Buffer Overflow (CWE-121), Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3gvq-h42f-v3c7",
    "affected_functions": [
      "validate_payload_and_mfr"
    ],
    "functionality": "Validates the payload and manufacturer-specific fields of an IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_frame(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to validate_payload_and_mfr (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all functions that manipulate buffer lengths or sizes validate the input lengths against the expected minimum sizes. Always check for potential underflows or overflows when performing arithmetic operations on lengths. When passing lengths between functions, consider using pointers to allow for modifications and checks within the called functions. Additionally, ensure that any changes to the buffer or its contents are reflected in the length checks to prevent out-of-bounds access.",
      "code_snippet": "validate_payload_and_mfr(struct ieee802154_mpdu *mpdu, u8_t *buf, u8_t *p_buf, u8_t *length) {\n    u8_t type = mpdu->mhr.fs->fc.frame_type;\n    NET_DBG(\"Header size: %u, payload size %u\", (u32_t)(p_buf - buf), *length);\n\n    if (type == IEEE802154_FRAME_TYPE_BEACON) {\n        if (!validate_beacon(mpdu, p_buf, length)) {\n            return false;\n        }\n    } else if (type == IEEE802154_FRAME_TYPE_DATA) {\n        if (*length == 0U) {\n            return false;\n        }\n        mpdu->payload = (void *)p_buf;\n    } else if (type == IEEE802154_FRAME_TYPE_ACK) {\n        if (*length) {\n            return false;\n        }\n        mpdu->payload = NULL;\n    } else {\n        if (!validate_mac_command(mpdu, p_buf, length)) {\n            return false;\n        }\n    }\n\n    if (*length) {\n        mpdu->mfr = (struct ieee802154_mfr *)(p_buf + *length);\n    } else {\n        mpdu->mfr = NULL;\n    }\n\n    return true;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24971",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex b320a6d141c4e..452c9a416478c 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -330,41 +377,42 @@ validate_payload_and_mfr(struct ieee802154_mpdu *mpdu, u8_t *buf, u8_t *p_buf, u8_t length) {\n-    u8_t payload_length;\n-    payload_length = length - (p_buf - buf);\n\n-    NET_DBG(\"Header size: %u, vs total length %u: payload size %u\", (u32_t)(p_buf - buf), length, payload_length);\n+    NET_DBG(\"Header size: %u, payload size %u\", (u32_t)(p_buf - buf), *length);\n\n    if (type == IEEE802154_FRAME_TYPE_BEACON) {\n-        if (!validate_beacon(mpdu, p_buf, payload_length)) {\n+        if (!validate_beacon(mpdu, p_buf, length)) {\n            return false;\n        }\n    } else if (type == IEEE802154_FRAME_TYPE_DATA) {\n-        if (payload_length == 0U) {\n+        if (*length == 0U) {\n            return false;\n        }\n\n        mpdu->payload = (void *)p_buf;\n    } else if (type == IEEE802154_FRAME_TYPE_ACK) {\n        if (payload_length) {\n+        if (*length) {\n            return false;\n        }\n\n        mpdu->payload = NULL;\n    } else {\n-        if (!validate_mac_command(mpdu, p_buf, payload_length)) {\n+        if (!validate_mac_command(mpdu, p_buf, length)) {\n            return false;\n        }\n    }\n\n-    mpdu->mfr = (struct ieee802154_mfr *)(p_buf + payload_length);\n+    if (*length) {\n+        mpdu->mfr = (struct ieee802154_mfr *)(p_buf + *length);\n+    } else {\n+        mpdu->mfr = NULL;\n+    }\n\n    return true;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Payload length is incorrectly calculated or exceeds the buffer length."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using validate_payload_and_mfr in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10064"
    ],
    "related_cwe": [
      "CWE-121,CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000060",
    "vulnerability": "Incorrect Error Handling in Bluetooth HCI core. Zephyr versions >= v1.14.2, >= v2.2.0 contain NULL Pointer Dereference (CWE-476). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-gc66-xfrc-24qr",
    "affected_functions": [
      "hci_cmd_done"
    ],
    "functionality": "Handles the completion of HCI commands and processes the response buffer.",
    "call_patterns": [
      {
        "pattern": "hci_cmd_done(subsys/bluetooth/host/hci_core.c)<-hci_cmd_complete(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_cmd_done (version: v2.2.1)"
      },
      {
        "pattern": "hci_cmd_done(subsys/bluetooth/host/hci_core.c)<-hci_cmd_status(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_cmd_done (version: v2.2.1)"
      },
      {
        "pattern": "hci_cmd_done(subsys/bluetooth/host/hci_core.c)<-send_cmd(subsys/bluetooth/host/hci_core.c)<-process_events(subsys/bluetooth/host/hci_core.c)<-hci_tx_thread(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_cmd_done (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always check for null pointers before dereferencing them. In functions that handle buffers, ensure that the buffer is valid before passing it to other functions. If a function can return an error or a null pointer, handle that case explicitly to prevent null pointer dereference vulnerabilities.",
      "code_snippet": "static void send_cmd(void) {\n    ...\n    err = bt_send(buf);\n    if (err) {\n        BT_ERR(\"Unable to send to driver (err %d)\", err);\n        k_sem_give(&bt_dev.ncmd_sem);\n        hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);\n        net_buf_unref(bt_dev.sent_cmd);\n        bt_dev.sent_cmd = NULL;\n        net_buf_unref(buf);\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/24902",
      "patch_diff": "diff --git a/subsys/bluetooth/host/hci_core.c b/subsys/bluetooth/host/hci_core.c\nindex c3f13ca29c5ee..b173de8e5be63 100644\n--- a/subsys/bluetooth/host/hci_core.c\n+++ b/subsys/bluetooth/host/hci_core.c\n@@ -5197,8 +5197,7 @@ static void send_cmd(void)\n if (err) {\n BT_ERR(\"Unable to send to driver (err %d)\", err);\n k_sem_give(&bt_dev.ncmd_sem);\n-hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED,\n- NULL);\n+hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);\n net_buf_unref(bt_dev.sent_cmd);\n bt_dev.sent_cmd = NULL;\n net_buf_unref(buf);\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Triggered when 'send_cmd' calls 'hci_cmd_done' with a null pointer for the 'buf' argument after an error in 'bt_send'."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using hci_cmd_done in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10066"
    ],
    "related_cwe": [
      "CWE-476"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000061",
    "vulnerability": "Zephyr Bluetooth unchecked packet data results in denial of service. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Parameters (CWE-233). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-f6vh-7v4x-8fjp",
    "affected_functions": [
      "ull_slave_setup"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_setup (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23705",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An unchecked parameter in Bluetooth data can lead to data_chan_count being less than 2 or data_chan_hop being outside the range of 5 to 16."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_setup in vulnerable versions (v2.2.0 → v2.2.1)"
    ],
    "related_cve": [
      "CVE-2020-10069"
    ],
    "related_cwe": [
      "CWE-233"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000062",
    "vulnerability": "Zephyr Bluetooth unchecked packet data results in denial of service. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Parameters (CWE-233). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-f6vh-7v4x-8fjp",
    "affected_functions": [
      "conn_update"
    ],
    "functionality": "Handles connection update requests in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "conn_update(subsys/bluetooth/controller/ll_sw/ctrl.c)",
        "description": "Vulnerable call chain leading to conn_update (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all parameters passed to functions are validated before use. Specifically, check for null pointers, invalid values, and ensure that any calculations involving these parameters do not lead to undefined behavior such as division by zero or out-of-bounds access. Implement proper error handling to gracefully manage unexpected input and prevent denial of service attacks.",
      "code_snippet": "static u8_t conn_update(struct connection *conn, struct pdu_data *pdu_data_rx) {\n    if (pdu_data_rx == NULL || conn == NULL) {\n        return 1; // Error: Invalid parameters\n    }\n    if (pdu_data_rx->llctrl.conn_update_ind.instant < 1) {\n        return 1; // Error: Invalid instant value\n    }\n    // Additional checks and logic here...\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23091",
      "patch_diff": "diff --git a/subsys/bluetooth/controller/ll_sw/ctrl.c b/subsys/bluetooth/controller/ll_sw/ctrl.c\nindex 872c6efd4d7c9..b82260353599c 100644\n--- a/subsys/bluetooth/controller/ll_sw/ctrl.c\n+++ b/subsys/bluetooth/controller/ll_sw/ctrl.c\n@@ -10332,6 +10545,7 @@ static u8_t conn_update(struct connection *conn, struct pdu_data *pdu_data_rx)\n+    if (pdu_data_rx == NULL || conn == NULL) {\n+        return 1; // Error: Invalid parameters\n+    }\n+    if (pdu_data_rx->llctrl.conn_update_ind.instant < 1) {\n+        return 1; // Error: Invalid instant value\n+    }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An unchecked parameter in Bluetooth data can lead to an assertion failure or division by zero."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using conn_update in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-10069"
    ],
    "related_cwe": [
      "CWE-233"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000063",
    "vulnerability": "Zephyr Bluetooth unchecked packet data results in denial of service. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Parameters (CWE-233). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-f6vh-7v4x-8fjp",
    "affected_functions": [
      "isr_rx_adv"
    ],
    "functionality": "Handles the reception of advertising packets in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "isr_rx_adv(subsys/bluetooth/controller/ll_sw/ctrl.c)<-isr_radio_state_rx(subsys/bluetooth/controller/ll_sw/ctrl.c)<-isr(subsys/bluetooth/controller/ll_sw/ctrl.c)",
        "description": "Vulnerable call chain leading to isr_rx_adv (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all parameters received by functions are validated before use. Specifically, check for valid ranges and conditions that could lead to undefined behavior, such as division by zero or assertion failures. In the context of the call chain, validate parameters in the 'isr_rx_adv' function to prevent invalid states from propagating from the 'isr_radio_state_rx' and 'isr' functions. Always return early from the function if any validation fails.",
      "code_snippet": "static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id, struct pdu_adv *pdu_adv, struct connection *conn) {\n\tconn->data_chan_count = util_ones_count_get(&conn->data_chan_map[0], sizeof(conn->data_chan_map));\n\tif (conn->data_chan_count < 2) {\n\t\treturn 1;\n\t}\n\tconn->data_chan_hop = pdu_adv->connect_ind.hop;\n\tif ((conn->data_chan_hop < 5) || (conn->data_chan_hop > 16)) {\n\t\treturn 1;\n\t}\n\tconn->conn_interval = pdu_adv->connect_ind.interval;\n\tconn_interval_us = ...",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/23706",
      "patch_diff": "+\tif (conn->data_chan_count < 2) {\n+\t\treturn 1;\n+\t}\n+\tif ((conn->data_chan_hop < 5) || (conn->data_chan_hop > 16)) {\n+\t\treturn 1;\n+\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An unchecked parameter in the Bluetooth data can lead to an assertion failure or division by zero if 'data_chan_count' is less than 2 or 'data_chan_hop' is outside the range of 5 to 16."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_rx_adv in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10069"
    ],
    "related_cwe": [
      "CWE-233"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000064",
    "vulnerability": "Improper Handling of Insufficient Permissions or Privileges in zephyr. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Insufficient Permissions or Privileges (CWE-280). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-vf79-hqwm-w4xc",
    "affected_functions": [
      "zsock_get_context_object"
    ],
    "functionality": "Obtain a file descriptor's associated net context.",
    "call_patterns": [
      {
        "pattern": "zsock_close(include/net/socket.h)",
        "description": "Vulnerable call chain leading to zsock_get_context_object (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any API that exposes file descriptors or similar resources implements a permission management system. This can be achieved by tagging the underlying data structures with specific identifiers (e.g., '__net_socket') and implementing access control checks before allowing operations on these resources. Use kernel object management functions to grant and verify permissions for threads accessing these resources.",
      "code_snippet": "__syscall void *zsock_get_context_object(int sock) {\n    const struct socket_op_vtable *ignored;\n    return get_sock_vtable(sock, &ignored);\n}\n\n#ifdef CONFIG_USERSPACE\nvoid *z_vrfy_zsock_get_context_object(int sock) {\n    /* All checking done in implementation */\n    return z_impl_zsock_get_context_object(sock);\n}\n#include <syscalls/zsock_get_context_object_mrsh.c>\n#endif",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/25804",
      "patch_diff": "diff --git a/include/net/socket.h b/include/net/socket.h\nindex 4011f6fd2e0c8..1f68b2308d32f 100644\n--- a/include/net/socket.h\n+++ b/include/net/socket.h\n@@ -145,6 +145,44 @@ struct zsock_addrinfo {\n  char _ai_canonname[DNS_MAX_NAME_SIZE + 1];\n };\n \n+__syscall void *zsock_get_context_object(int sock);\n+\n+void *z_impl_zsock_get_context_object(int sock) {\n+    const struct socket_op_vtable *ignored;\n+    return get_sock_vtable(sock, &ignored);\n+}\n+\n+#ifdef CONFIG_USERSPACE\n+void *z_vrfy_zsock_get_context_object(int sock) {\n+    /* All checking done in implementation */\n+    return z_impl_zsock_get_context_object(sock);\n+}\n+#include <syscalls/zsock_get_context_object_mrsh.c>\n+#endif"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Any thread can access any socket file descriptor without permission checks."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using zsock_get_context_object in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10072"
    ],
    "related_cwe": [
      "CWE-280"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000065",
    "vulnerability": "Improper Handling of Insufficient Permissions or Privileges in zephyr. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Insufficient Permissions or Privileges (CWE-280). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-vf79-hqwm-w4xc",
    "affected_functions": [
      "zsock_close"
    ],
    "functionality": "Obtain a file descriptor's associated net context.",
    "call_patterns": [
      {
        "pattern": "zsock_close(include/net/socket.h)",
        "description": "Vulnerable call chain leading to zsock_close (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any API that exposes file descriptors or similar resources implements a permission management system. This can be achieved by tagging the underlying data structures with specific identifiers (e.g., '__net_socket') and implementing access control checks before allowing operations on these resources. Use kernel object management functions to grant and verify permissions for threads accessing these resources.",
      "code_snippet": "__syscall void *zsock_get_context_object(int sock) {\n    const struct socket_op_vtable *ignored;\n    return get_sock_vtable(sock, &ignored);\n}\n\n#ifdef CONFIG_USERSPACE\nvoid *z_vrfy_zsock_get_context_object(int sock) {\n    /* All checking done in implementation */\n    return z_impl_zsock_get_context_object(sock);\n}\n#include <syscalls/zsock_get_context_object_mrsh.c>\n#endif",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/25804",
      "patch_diff": "diff --git a/include/net/socket.h b/include/net/socket.h\nindex 4011f6fd2e0c8..1f68b2308d32f 100644\n--- a/include/net/socket.h\n+++ b/include/net/socket.h\n@@ -145,6 +145,44 @@ struct zsock_addrinfo {\n  char _ai_canonname[DNS_MAX_NAME_SIZE + 1];\n };\n \n+__syscall void *zsock_get_context_object(int sock);\n+\n+void *z_impl_zsock_get_context_object(int sock) {\n+    const struct socket_op_vtable *ignored;\n+    return get_sock_vtable(sock, &ignored);\n+}\n+\n+#ifdef CONFIG_USERSPACE\n+void *z_vrfy_zsock_get_context_object(int sock) {\n+    /* All checking done in implementation */\n+    return z_impl_zsock_get_context_object(sock);\n+}\n+#include <syscalls/zsock_get_context_object_mrsh.c>\n+#endif"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Any thread can access any socket file descriptor without permission checks."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using zsock_close in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10072"
    ],
    "related_cwe": [
      "CWE-280"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000066",
    "vulnerability": "Improper Handling of Insufficient Permissions or Privileges in zephyr. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Insufficient Permissions or Privileges (CWE-280). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-vf79-hqwm-w4xc",
    "affected_functions": [
      "get_sock_vtable"
    ],
    "functionality": "Retrieve the socket operation vtable and associated context for a given socket file descriptor.",
    "call_patterns": [
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_bind(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_connect(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_listen(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_accept(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_sendto(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_sendmsg(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_recvfrom(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_getsockopt(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_setsockopt(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to get_sock_vtable (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any access to sensitive resources, such as network socket file descriptors, is properly managed through a permission system. Implement checks to validate the permissions of the calling thread before allowing access to the resource. Use kernel object tagging to enforce access control and ensure that only authorized threads can manipulate the resources. Additionally, provide APIs to manage permissions explicitly, allowing threads to grant or revoke access as needed.",
      "code_snippet": "static inline void *get_sock_vtable(int sock, const struct socket_op_vtable **vtable) {\n    void *ctx;\n    ctx = z_get_fd_obj_and_vtable(sock, (const struct fd_op_vtable **)vtable);\n    #ifdef CONFIG_USERSPACE\n    if (z_is_in_user_syscall()) {\n        struct z_object *zo;\n        int ret;\n        zo = z_object_find(ctx);\n        ret = z_object_validate(zo, K_OBJ_NET_SOCKET, _OBJ_INIT_TRUE);\n        if (ret != 0) {\n            z_dump_object_error(ret, ctx, zo, K_OBJ_NET_SOCKET);\n            ctx = NULL;\n        }\n    }\n    #endif /* CONFIG_USERSPACE */\n    if (ctx == NULL) {\n        NET_ERR(\"invalid access on sock %d by thread %p\", sock, _current);\n    }\n    return ctx;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/25804",
      "patch_diff": "diff --git a/subsys/net/lib/sockets/sockets.c b/subsys/net/lib/sockets/sockets.c\n+++ b/subsys/net/lib/sockets/sockets.c\n@@ -45,10 +45,55 @@ const struct socket_op_vtable sock_fd_op_vtable;\n static inline void *get_sock_vtable(\n             int sock, const struct socket_op_vtable **vtable) {\n-    return z_get_fd_obj_and_vtable(sock,\n-                       (const struct fd_op_vtable **)vtable);\n+    void *ctx;\n+\n+    ctx = z_get_fd_obj_and_vtable(sock,\n+                      (const struct fd_op_vtable **)vtable);\n+\n+#ifdef CONFIG_USERSPACE\n+    if (z_is_in_user_syscall()) {\n+        struct z_object *zo;\n+        int ret;\n+\n+        zo = z_object_find(ctx);\n+        ret = z_object_validate(zo, K_OBJ_NET_SOCKET, _OBJ_INIT_TRUE);\n+\n+        if (ret != 0) {\n+            z_dump_object_error(ret, ctx, zo, K_OBJ_NET_SOCKET);\n+            ctx = NULL;\n+        }\n+    }\n+#endif /* CONFIG_USERSPACE */\n+\n+    if (ctx == NULL) {\n+        NET_ERR(\"invalid access on sock %d by thread %p\", sock,\n+            _current);\n+    }\n+\n+    return ctx;\n+}\n+\n+void *z_impl_zsock_get_context_object(int sock) {\n+    const struct socket_op_vtable *ignored;\n+\n+    return get_sock_vtable(sock, &ignored);\n+}\n+\n+#ifdef CONFIG_USERSPACE\n+void *z_vrfy_zsock_get_context_object(int sock) {\n+    /* All checking done in implementation */\n+    return z_impl_zsock_get_context_object(sock);\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Lack of permission checks allows unauthorized access to socket contexts."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using get_sock_vtable in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10072"
    ],
    "related_cwe": [
      "CWE-280"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000067",
    "vulnerability": "Improper Handling of Insufficient Permissions or Privileges in zephyr. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Insufficient Permissions or Privileges (CWE-280). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-vf79-hqwm-w4xc",
    "affected_functions": [
      "k_fifo_wait_non_empty"
    ],
    "functionality": "Retrieve the socket operation vtable and associated context for a given socket file descriptor.",
    "call_patterns": [
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_bind(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_connect(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_listen(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_accept(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_sendto(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_sendmsg(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_recvfrom(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_getsockopt(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      },
      {
        "pattern": "get_sock_vtable(subsys/net/lib/sockets/sockets.c)<-z_impl_zsock_setsockopt(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to k_fifo_wait_non_empty (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any access to sensitive resources, such as network socket file descriptors, is properly managed through a permission system. Implement checks to validate the permissions of the calling thread before allowing access to the resource. Use kernel object tagging to enforce access control and ensure that only authorized threads can manipulate the resources. Additionally, provide APIs to manage permissions explicitly, allowing threads to grant or revoke access as needed.",
      "code_snippet": "static inline void *get_sock_vtable(int sock, const struct socket_op_vtable **vtable) {\n    void *ctx;\n    ctx = z_get_fd_obj_and_vtable(sock, (const struct fd_op_vtable **)vtable);\n    #ifdef CONFIG_USERSPACE\n    if (z_is_in_user_syscall()) {\n        struct z_object *zo;\n        int ret;\n        zo = z_object_find(ctx);\n        ret = z_object_validate(zo, K_OBJ_NET_SOCKET, _OBJ_INIT_TRUE);\n        if (ret != 0) {\n            z_dump_object_error(ret, ctx, zo, K_OBJ_NET_SOCKET);\n            ctx = NULL;\n        }\n    }\n    #endif /* CONFIG_USERSPACE */\n    if (ctx == NULL) {\n        NET_ERR(\"invalid access on sock %d by thread %p\", sock, _current);\n    }\n    return ctx;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/25804",
      "patch_diff": "diff --git a/subsys/net/lib/sockets/sockets.c b/subsys/net/lib/sockets/sockets.c\n+++ b/subsys/net/lib/sockets/sockets.c\n@@ -45,10 +45,55 @@ const struct socket_op_vtable sock_fd_op_vtable;\n static inline void *get_sock_vtable(\n             int sock, const struct socket_op_vtable **vtable) {\n-    return z_get_fd_obj_and_vtable(sock,\n-                       (const struct fd_op_vtable **)vtable);\n+    void *ctx;\n+\n+    ctx = z_get_fd_obj_and_vtable(sock,\n+                      (const struct fd_op_vtable **)vtable);\n+\n+#ifdef CONFIG_USERSPACE\n+    if (z_is_in_user_syscall()) {\n+        struct z_object *zo;\n+        int ret;\n+\n+        zo = z_object_find(ctx);\n+        ret = z_object_validate(zo, K_OBJ_NET_SOCKET, _OBJ_INIT_TRUE);\n+\n+        if (ret != 0) {\n+            z_dump_object_error(ret, ctx, zo, K_OBJ_NET_SOCKET);\n+            ctx = NULL;\n+        }\n+    }\n+#endif /* CONFIG_USERSPACE */\n+\n+    if (ctx == NULL) {\n+        NET_ERR(\"invalid access on sock %d by thread %p\", sock,\n+            _current);\n+    }\n+\n+    return ctx;\n+}\n+\n+void *z_impl_zsock_get_context_object(int sock) {\n+    const struct socket_op_vtable *ignored;\n+\n+    return get_sock_vtable(sock, &ignored);\n+}\n+\n+#ifdef CONFIG_USERSPACE\n+void *z_vrfy_zsock_get_context_object(int sock) {\n+    /* All checking done in implementation */\n+    return z_impl_zsock_get_context_object(sock);\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Lack of permission checks allows unauthorized access to socket contexts."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using k_fifo_wait_non_empty in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10072"
    ],
    "related_cwe": [
      "CWE-280"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000068",
    "vulnerability": "Improper Handling of Insufficient Permissions or Privileges in zephyr. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Insufficient Permissions or Privileges (CWE-280). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-vf79-hqwm-w4xc",
    "affected_functions": [
      "spair_new"
    ],
    "functionality": "Create a new socket pair for inter-thread communication.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that allocates or manages resources that can be accessed by multiple threads implements a permission management system. Use kernel object permissions to restrict access to these resources. When creating a new resource, such as a socket, ensure that the calling thread is granted access to the resource and that other threads do not have access unless explicitly granted. Implement checks to validate permissions before allowing access to the resource.",
      "code_snippet": "struct spair *spair_new(void) {\n    struct spair *spair;\n\n#ifdef CONFIG_USERSPACE\n    struct z_object *zo = z_dynamic_object_create(sizeof(*spair));\n\n    if (zo == NULL) {\n        spair = NULL;\n    } else {\n        spair = zo->name;\n        zo->type = K_OBJ_NET_SOCKET;\n    }\n#else\n    spair = k_malloc(sizeof(*spair));\n#endif\n    if (spair == NULL) {\n        errno = ENOMEM;\n        goto out;\n    }\n    return spair;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/25804",
      "patch_diff": "diff --git a/subsys/net/lib/sockets/socketpair.c b/subsys/net/lib/sockets/socketpair.c\nindex be648a246016f..199803e805c82 100644\n--- a/subsys/net/lib/sockets/socketpair.c\n+++ b/subsys/net/lib/sockets/socketpair.c\n@@ -214,7 +217,18 @@ static struct spair *spair_new(void)\n {\n     struct spair *spair;\n \n+#ifdef CONFIG_USERSPACE\n+    struct z_object *zo = z_dynamic_object_create(sizeof(*spair));\n+\n+    if (zo == NULL) {\n+        spair = NULL;\n+    } else {\n+        spair = zo->name;\n+        zo->type = K_OBJ_NET_SOCKET;\n+    }\n+#else\n     spair = k_malloc(sizeof(*spair));\n+#endif\n     if (spair == NULL) {\n         errno = ENOMEM;\n         goto out;\n     }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "No permission checks on socket creation, allowing any thread to manipulate sockets."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using spair_new in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10072"
    ],
    "related_cwe": [
      "CWE-280"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000069",
    "vulnerability": "Improper Handling of Insufficient Permissions or Privileges in zephyr. Zephyr versions >= v1.14.2, >= v2.2.0 contain Improper Handling of Insufficient Permissions or Privileges (CWE-280). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-vf79-hqwm-w4xc",
    "affected_functions": [
      "znet_mgmt_socket"
    ],
    "functionality": "Create a network management socket.",
    "call_patterns": [
      {
        "pattern": "znet_mgmt_socket(subsys/net/lib/sockets/sockets_net_mgmt.c)",
        "description": "Vulnerable call chain leading to znet_mgmt_socket (version: v2.2.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any API that exposes file descriptors implements a permission management system. This can be achieved by tagging the underlying data structures with a specific identifier (e.g., '__net_socket') and implementing functions to manage access permissions. Use kernel object permissions to restrict access to file descriptors, ensuring that only authorized threads can manipulate them. Always validate the permissions before performing operations on the file descriptors.",
      "code_snippet": "void *z_impl_zsock_get_context_object(int sock) {\n    const struct socket_op_vtable *ignored;\n    return get_sock_vtable(sock, &ignored);\n}\n\n#ifdef CONFIG_USERSPACE\nvoid *z_vrfy_zsock_get_context_object(int sock) {\n    return z_impl_zsock_get_context_object(sock);\n}\n#include <syscalls/zsock_get_context_object_mrsh.c>\n#endif",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/25804",
      "patch_diff": "diff --git a/subsys/net/lib/sockets/sockets_net_mgmt.c b/subsys/net/lib/sockets/sockets_net_mgmt.c\nindex cb0c5383c45b0..d9e0346097c4c 100644\n--- a/subsys/net/lib/sockets/sockets_net_mgmt.c\n+++ b/subsys/net/lib/sockets/sockets_net_mgmt.c\n@@ -80,13 +80,6 @@ int znet_mgmt_socket(int family, int type, int proto)\n     mgmt->wait_timeout = K_FOREVER;\n \n-#if defined(CONFIG_USERSPACE)\n-    /* Set net context object as initialized and grant access to the\n-     * calling thread (and only the calling thread)\n-     */\n-    z_object_recycle(mgmt);\n-#endif\n-\n     z_finalize_fd(fd, mgmt,\n              (const struct fd_op_vtable *)&net_mgmt_sock_fd_op_vtable);\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "No access control on the management socket, allowing unauthorized access."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using znet_mgmt_socket in vulnerable versions (v2.2.1 → v2.3.0)"
    ],
    "related_cve": [
      "CVE-2020-10072"
    ],
    "related_cwe": [
      "CWE-280"
    ],
    "vulnerable_version": "v2.2.1"
  },
  {
    "id": "VULN-000070",
    "vulnerability": "FS: Buffer Overflow when enabling Long File Names in FAT_FS and calling fs_stat. Zephyr versions >= v1.14.2, >= v2.3.0 contain Stack-based Buffer Overflow (CWE-121). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7fhv-rgxr-x56h",
    "affected_functions": [
      "int fs_stat(const char *path, struct fs_dirent *entry)"
    ],
    "functionality": "Checks the status of a file or directory specified by the path.",
    "call_patterns": [
      {
        "pattern": "static int fatfs_stat(struct fs_mount_t *mountp,const char *path, struct fs_dirent *entry)(zephyr/subsys/fs/fat_fs.c)<-static struct fs_file_system_t fatfs_fs(zephyr/subsys/fs/fat_fs.c)<-struct fs_mount_t(zephyr/include/zephyr/fs/fs.h)<-int fs_stat(const char *path, struct fs_dirent *entry)(zephyr/include/zephyr/fs/fs.h)",
        "description": "Vulnerable call chain leading to fatfs_stat(version: v2.3.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Perform checks on the filepath parameter when calling the public API fs_stat().",
      "code_snippet": "int check_file_dir_exists(const char *path)\n{\n    int res;\n    struct fs_dirent entry;\n    \n    if (path == NULL) {\n        return 0;\n    }\n    \n#if defined(CONFIG_FILE_SYSTEM_LITTLEFS)\n#define MAX_PATH_LEN 255\n#else\n#define MAX_PATH_LEN 12\n#endif\n    \n    bool found_terminator = false;\n    for (size_t i = 0; i <= MAX_PATH_LEN; i++) {\n        if (path[i] == '\\0') {\n            found_terminator = true;\n            break;\n        }\n    }\n    \n    if (!found_terminator) {\n        return 0;\n    }\n    \n    res = fs_stat(path, &entry);\n    return !res;\n    \n#undef MAX_PATH_LEN\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/17",
      "patch_diff": "diff --git a/subsys/fs/fat_fs.c b/subsys/fs/fat_fs.c\nindex abcdef1..1234567 100644\n--- a/subsys/fs/fat_fs.c\n+++ b/subsys/fs/fat_fs.c\n@@ -306,6 +306,10 @@ int fatfs_stat(struct fs_mount_t *mountp, const char *path, struct fs_dirent *\n     struct fatfs_dirent *fat_entry;\n     struct fatfs_mount *fat_mount = mountp->fs_data;\n \n+    if (strlen(path) > MAX_FILE_NAME) {\n+        return -ENAMETOOLONG;\n+    }\n+\n     strcpy(filename, path);\n     // ... rest of the function logic ...\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Calling fs_stat on a file with a filename longer than 12 characters.The public API fs_stat() calls the library function fatfs_stat(), and there is a buffer overflow inside fatfs_stat(), where the struct fs_dirent is defined with MAX_FILE_NAME. Performing fs_stat on a file with a filename longer than 12 characters long will cause a buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fs_stat in vulnerable versions (vv2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13598"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000071",
    "vulnerability": "FS: Buffer Overflow when enabling Long File Names in FAT_FS and calling fs_stat. Zephyr versions >= v1.14.2, >= v2.3.0 contain Stack-based Buffer Overflow (CWE-121). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7fhv-rgxr-x56h",
    "affected_functions": [
      "int fs_stat(const char *path, struct fs_dirent *entry)"
    ],
    "functionality": "Checks the status of a file or directory specified by the path.",
    "call_patterns": [
      {
        "pattern": "static int fatfs_stat(struct fs_mount_t *mountp,const char *path, struct fs_dirent *entry)(zephyr/subsys/fs/fat_fs.c)<-static struct fs_file_system_t fatfs_fs(zephyr/subsys/fs/fat_fs.c)<-struct fs_mount_t(zephyr/include/zephyr/fs/fs.h)<-int fs_stat(const char *path, struct fs_dirent *entry)(zephyr/include/zephyr/fs/fs.h)",
        "description": "Vulnerable call chain leading to fatfs_stat(version: v2.3.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Perform checks on the filepath parameter when calling the public API fs_stat().",
      "code_snippet": "int check_file_dir_exists(const char *path)\n{\n    int res;\n    struct fs_dirent entry;\n    \n    if (path == NULL) {\n        return 0;\n    }\n    \n#if defined(CONFIG_FILE_SYSTEM_LITTLEFS)\n#define MAX_PATH_LEN 255\n#else\n#define MAX_PATH_LEN 12\n#endif\n    \n    bool found_terminator = false;\n    for (size_t i = 0; i <= MAX_PATH_LEN; i++) {\n        if (path[i] == '\\0') {\n            found_terminator = true;\n            break;\n        }\n    }\n    \n    if (!found_terminator) {\n        return 0;\n    }\n    \n    res = fs_stat(path, &entry);\n    return !res;\n    \n#undef MAX_PATH_LEN\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/17",
      "patch_diff": "diff --git a/subsys/fs/fat_fs.c b/subsys/fs/fat_fs.c\nindex abcdef1..1234567 100644\n--- a/subsys/fs/fat_fs.c\n+++ b/subsys/fs/fat_fs.c\n@@ -306,6 +306,10 @@ int fatfs_stat(struct fs_mount_t *mountp, const char *path, struct fs_dirent *\n     struct fatfs_dirent *fat_entry;\n     struct fatfs_mount *fat_mount = mountp->fs_data;\n \n+    if (strlen(path) > MAX_FILE_NAME) {\n+        return -ENAMETOOLONG;\n+    }\n+\n     strcpy(filename, path);\n     // ... rest of the function logic ...\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Calling fs_stat on a file with a filename longer than 12 characters.The public API fs_stat() calls the library function fatfs_stat(), and there is a buffer overflow inside fatfs_stat(), where the struct fs_dirent is defined with MAX_FILE_NAME. Performing fs_stat on a file with a filename longer than 12 characters long will cause a buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fs_stat in vulnerable versions (v1.7.99 → v1.8.0)"
    ],
    "related_cve": [
      "CVE-2020-13598"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v1.7.99"
  },
  {
    "id": "VULN-000072",
    "vulnerability": "FS: Buffer Overflow when enabling Long File Names in FAT_FS and calling fs_stat. Zephyr versions >= v1.14.2, >= v2.3.0 contain Stack-based Buffer Overflow (CWE-121). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7fhv-rgxr-x56h",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "The function retrieves the status of a file or directory.",
    "call_patterns": [
      {
        "pattern": "<global>(subsys/fs/fat_fs.c)",
        "description": "Vulnerable call chain leading to <global> (version: v1.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any buffer used to store file names or paths is adequately sized to handle the maximum expected length. Implement checks to validate the length of input strings before copying them into buffers. Use safer string handling functions that limit the number of characters copied to prevent buffer overflows.",
      "code_snippet": "int fs_stat(const char *abs_path, struct fs_stat *entry) {\n    char filename[MAX_FILE_NAME];\n    if (strlen(abs_path) >= MAX_FILE_NAME) {\n        return -ENAMETOOLONG;\n    }\n    strcpy(filename, abs_path);\n    // ... rest of the function logic ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/6",
      "patch_diff": "diff --git a/subsys/fs/fat_fs.c b/subsys/fs/fat_fs.c\nindex abcdef..123456 100644\n--- a/subsys/fs/fat_fs.c\n+++ b/subsys/fs/fat_fs.c\n@@ -306,6 +306,10 @@ int fatfs_stat(const char *path, struct fs_stat *entry) {\n     // Existing code...\n+\n+    if (strlen(path) > MAX_FILE_NAME) {\n+        return -ENAMETOOLONG;\n+    }\n+\n     strcpy(entry->name, path);\n     // Continue with the rest of the function...\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Calling fs_stat on a file with a filename longer than 12 characters while Long File Name support is enabled."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v1.7.99 → v1.8.0)"
    ],
    "related_cve": [
      "CVE-2020-13598"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v1.7.99"
  },
  {
    "id": "VULN-000073",
    "vulnerability": "FS: Buffer Overflow when enabling Long File Names in FAT_FS and calling fs_stat. Zephyr versions >= v1.14.2, >= v2.3.0 contain Stack-based Buffer Overflow (CWE-121). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7fhv-rgxr-x56h",
    "affected_functions": [
      "fs_stat"
    ],
    "functionality": "This function is a wrapper that calls the underlying filesystem's stat function to get file status.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any buffer used for storing filenames is adequately sized to handle the maximum expected length. Implement checks to validate the length of the filename before copying it into the buffer. Use safer string handling functions that limit the number of characters copied to prevent buffer overflows.",
      "code_snippet": "if (strlen(path) >= MAX_FILE_NAME) {\n    return -ENAMETOOLONG;\n}\nstrcpy(entry->name, path);",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/17",
      "patch_diff": "diff --git a/subsys/fs/fat_fs.c b/subsys/fs/fat_fs.c\nindex 1234567..89abcdef 100644\n--- a/subsys/fs/fat_fs.c\n+++ b/subsys/fs/fat_fs.c\n@@ -303,6 +303,10 @@ int fatfs_stat(struct fs_mount_t *mountp, const char *path, struct fs_dirent *entry) {\n     // Existing code...\n+\n+    if (strlen(path) >= MAX_FILE_NAME) {\n+        return -ENAMETOOLONG;\n+    }\n     strcpy(entry->name, path);\n     // Existing code...\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Invoking fs_stat with a path that leads to a file with a name longer than 12 characters."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fs_stat in vulnerable versions (v1.7.99 → v1.8.0)"
    ],
    "related_cve": [
      "CVE-2020-13598"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v1.7.99"
  },
  {
    "id": "VULN-000074",
    "vulnerability": "FS: Buffer Overflow when enabling Long File Names in FAT_FS and calling fs_stat. Zephyr versions >= v1.14.2, >= v2.3.0 contain Stack-based Buffer Overflow (CWE-121). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7fhv-rgxr-x56h",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "This function is a wrapper that calls the underlying filesystem's stat function to get file status.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any buffer used to store file names is adequately sized to handle the maximum expected length. Implement checks to validate the length of the filename before copying it into the buffer. If the filename exceeds the buffer size, return an appropriate error code instead of proceeding with the operation.",
      "code_snippet": "int fs_stat(const char *abs_path, struct fs_stat *entry) {\n    char filename[MAX_FILE_NAME];\n    if (strlen(abs_path) > MAX_FILE_NAME - 1) {\n        return -ENAMETOOLONG;\n    }\n    strcpy(filename, abs_path);\n    // Proceed with the rest of the function logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/7",
      "patch_diff": "diff --git a/subsys/fs/fat_fs.c b/subsys/fs/fat_fs.c\nindex 1234567..89abcdef 100644\n--- a/subsys/fs/fat_fs.c\n+++ b/subsys/fs/fat_fs.c\n@@ -306,6 +306,10 @@ int fatfs_stat(struct fs_mount *mountp, const char *path, struct fs_stat *entry)\n     char filename[MAX_FILE_NAME];\n \n+    if (strlen(path) > MAX_FILE_NAME - 1) {\n+        return -ENAMETOOLONG;\n+    }\n+\n     strcpy(filename, path);\n     // Existing logic to handle the stat operation...\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Invoking fs_stat with a path that leads to a file with a name longer than 12 characters."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v1.7.99 → v1.8.0)"
    ],
    "related_cve": [
      "CVE-2020-13598"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v1.7.99"
  },
  {
    "id": "VULN-000075",
    "vulnerability": "Security problem with settings and littlefs. Zephyr versions >= 1.14.2, >= 2.3.0 contain Incorrect Default Permissions (CWE-276). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-5qhg-j6wc-4f6q",
    "affected_functions": [
      "MCUMGR_CMD_FS_MGMT"
    ],
    "functionality": "Enables mcumgr handlers for file management.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any configuration options that expose sensitive information are clearly marked as insecure. Additionally, implement checks in the code to prevent the use of insecure configurations in production environments. Consider encrypting sensitive data or using alternative storage mechanisms that do not expose sensitive information through file management features.",
      "code_snippet": "menuconfig MCUMGR_CMD_FS_MGMT\n    bool \"Enable mcumgr handlers for file management (insecure)\"\n    depends on FILE_SYSTEM\n    help\n      Enables mcumgr handlers for file management\n\n      This option allows mcumgr clients to access anything in the\n      file system, including application-stored secrets like\n      private keys. Use of this feature in production is strongly\n      discouraged.",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/37178",
      "patch_diff": "diff --git a/ext/lib/mgmt/mcumgr/cmd/fs_mgmt/Kconfig b/ext/lib/mgmt/mcumgr/cmd/fs_mgmt/Kconfig\nindex 11344796b3050..6df9af5dc12b7 100644\n--- a/ext/lib/mgmt/mcumgr/cmd/fs_mgmt/Kconfig\n+++ b/ext/lib/mgmt/mcumgr/cmd/fs_mgmt/Kconfig\n@@ -16,11 +16,16 @@\n # Under the License.\n \n menuconfig MCUMGR_CMD_FS_MGMT\n-    bool \"Enable mcumgr handlers for file management\"\n+    bool \"Enable mcumgr handlers for file management (insecure)\"\n     depends on FILE_SYSTEM\n     help\n       Enables mcumgr handlers for file management\n+\n+      This option allows mcumgr clients to access anything in the\n+      file system, including application-stored secrets like\n+      private keys. Use of this feature in production is strongly\n+      discouraged.\n+"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Using MCUmgr with littlefs as a backend for security-related settings."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using MCUMGR_CMD_FS_MGMT in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2020-13599"
    ],
    "related_cwe": [
      "CWE-276"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000076",
    "vulnerability": "Security problem with settings and littlefs. Zephyr versions >= 1.14.2, >= 2.3.0 contain Incorrect Default Permissions (CWE-276). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-5qhg-j6wc-4f6q",
    "affected_functions": [
      "MCUMGR_CMD_FS_MGMT"
    ],
    "functionality": "Enables mcumgr handlers for file management, allowing access to the file system.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/26083",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Using MCUmgr with littlefs as a backend for security-related settings."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using MCUMGR_CMD_FS_MGMT in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13599"
    ],
    "related_cwe": [
      "CWE-276"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000077",
    "vulnerability": "Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr",
    "affected_functions": [
      "__parse_ssid"
    ],
    "functionality": "Parses a given string to extract the SSID from a formatted input.",
    "call_patterns": [
      {
        "pattern": "<global>(drivers/wifi/eswifi/eswifi_core.c)",
        "description": "Vulnerable call chain leading to __parse_ssid (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/37177",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A malformed SPI response that does not conform to the expected format can lead to memory corruption."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using __parse_ssid in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13600"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000078",
    "vulnerability": "Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Parses a given string to extract the SSID from a formatted input.",
    "call_patterns": [
      {
        "pattern": "<global>(drivers/wifi/eswifi/eswifi_core.c)",
        "description": "Vulnerable call chain leading to <global> (version: v2.3.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that input validation is robust. Specifically, check for expected input formats and lengths before processing. Use bounds checking to prevent buffer overflows and ensure that all paths in the function return valid results. Additionally, consider implementing logging for unexpected input to aid in debugging and security audits.",
      "code_snippet": "static inline int __parse_ssid(char *str, char *ssid) {\n\tint i = 0;\n\n\tif (*str != '\"') {\n\t\treturn 0;\n\t}\n\tstr++;\n\n\twhile (*str && (*str != '\"') && i < WIFI_SSID_MAX_LEN) {\n\t\tssid[i++] = *str++;\n\t}\n\n\tif (*str != '\"') {\n\t\treturn 0;\n\t}\n\n\treturn i;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/26712",
      "patch_diff": "if (*str != '\"') {\n\t\treturn 0;\n\t}\n\n\twhile (*str && (*str != '\"') && i < WIFI_SSID_MAX_LEN) {\n\t\tssid[i++] = *str++;\n\t}\n\n\tif (*str != '\"') {\n\t\treturn 0;\n\t}\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A malformed SPI response that does not conform to the expected format can lead to memory corruption."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13600"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000079",
    "vulnerability": "Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr",
    "affected_functions": [
      "eswifi_shell_register"
    ],
    "functionality": "Registers an esWiFi device for shell commands.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that registers or interacts with hardware components checks for the validity of the input parameters and maintains proper state management. Implement checks to prevent multiple registrations and ensure that the device is properly initialized before use. Additionally, consider using mutexes or locks to protect shared resources and prevent race conditions.",
      "code_snippet": "void eswifi_shell_register(struct eswifi_dev *dev) {\n    /* only one instance supported */\n    if (eswifi) {\n        return;\n    }\n    eswifi = dev;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/26712",
      "patch_diff": "+++ b/drivers/wifi/eswifi/eswifi.h\n+#if defined(CONFIG_WIFI_ESWIFI_SHELL)\n+void eswifi_shell_register(struct eswifi_dev *dev);\n+#else\n+#define eswifi_shell_register(dev)\n+#endif\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "If the eswifi device is not properly initialized or registered, it can lead to unexpected behavior."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using eswifi_shell_register in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13600"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000080",
    "vulnerability": "Malformed SPI in response for eswifi can corrupt kernel memory. Zephyr versions >= 1.14.2, >= 2.3.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hx4p-j86p-2mhr",
    "affected_functions": [
      "eswifi_unlock"
    ],
    "functionality": "Registers an esWiFi device for shell commands.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that registers or interacts with hardware components checks for the validity of the input parameters and maintains proper state management. Implement checks to prevent multiple registrations and ensure that the device is properly initialized before use. Additionally, consider using mutexes or locks to protect shared resources and prevent race conditions.",
      "code_snippet": "void eswifi_shell_register(struct eswifi_dev *dev) {\n    /* only one instance supported */\n    if (eswifi) {\n        return;\n    }\n    eswifi = dev;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/26712",
      "patch_diff": "+++ b/drivers/wifi/eswifi/eswifi.h\n+#if defined(CONFIG_WIFI_ESWIFI_SHELL)\n+void eswifi_shell_register(struct eswifi_dev *dev);\n+#else\n+#define eswifi_shell_register(dev)\n+#endif\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "If the eswifi device is not properly initialized or registered, it can lead to unexpected behavior."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using eswifi_unlock in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13600"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000081",
    "vulnerability": "Possible read out of bounds in dns read. Zephyr versions >= 1.14.2, >= 2.3.0 contain Out-of-bounds Read (CWE-125). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-mm57-9hqw-qh44",
    "affected_functions": [
      "dns_read"
    ],
    "functionality": "Handles reading and processing DNS messages from a network packet.",
    "call_patterns": [
      {
        "pattern": "cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_read (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all buffer accesses are validated against the actual size of the data being processed. Always check that offsets and lengths do not exceed the bounds of the allocated memory. Implement checks before reading or writing to buffers, especially when dealing with external data sources. Use defensive programming techniques to validate inputs and maintain the integrity of the data being processed.",
      "code_snippet": "static int dns_read(struct dns_resolve_context *ctx, struct dns_msg_t *dns_msg, size_t data_len) {\n    dns_msg.msg = dns_data->data;\n    dns_msg.msg_size = data_len;\n\n    if (dns_msg.msg_size < (sizeof(*dns_id) + sizeof(uint16_t))) {\n        ret = DNS_EAI_FAIL;\n        goto quit;\n    }\n\n    if ((dns_msg.response_position + address_size) > dns_msg.msg_size) {\n        ret = DNS_EAI_FAIL;\n        goto quit;\n    }\n\n    src = dns_msg.msg + dns_msg.response_position;\n    memcpy(addr, src, address_size);\n\n    dns_msg.answer_offset += dns_msg.response_position - dns_msg.answer_offset;\n    dns_msg.answer_offset += dns_msg.response_length;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/30503",
      "patch_diff": "if (offset >= dns_msg->msg_size) {\n    return -ENOMEM;\n}\n\nif ((dns_msg.response_position + address_size) > dns_msg.msg_size) {\n    /* Too short message */\n    ret = DNS_EAI_FAIL;\n    goto quit;\n}\n\ndns_msg.answer_offset += dns_msg.response_position - dns_msg.answer_offset;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When RDLENGTH is larger than the actual DNS message size, leading to potential out-of-bounds reads."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_read in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13601"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000082",
    "vulnerability": "Possible read out of bounds in dns read. Zephyr versions >= 1.14.2, >= 2.3.0 contain Out-of-bounds Read (CWE-125). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-mm57-9hqw-qh44",
    "affected_functions": [
      "cb_recv"
    ],
    "functionality": "Handles reading and processing DNS messages from a network packet.",
    "call_patterns": [
      {
        "pattern": "dns_read(subsys/net/lib/dns/resolve.c)<-cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to cb_recv (version: v2.3.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all buffer accesses are validated against their sizes before performing read or write operations. Implement checks to prevent out-of-bounds access, especially when dealing with network data where the size may not be guaranteed. Use helper functions to encapsulate validation logic and ensure that all paths that manipulate buffer offsets are carefully reviewed to avoid underflows and overflows.",
      "code_snippet": "int dns_validate_msg(struct dns_resolve_context *ctx,\n\t\t\tstruct dns_msg_t *dns_msg,\n\t\t\tuint16_t *dns_id,\n\t\t\tint *query_idx,\n\t\t\tstruct net_buf *dns_cname,\n\t\t\tuint16_t *query_hash) {\n\t// Function implementation with necessary validations\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/27774",
      "patch_diff": "diff --git a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c\n--- a/subsys/net/lib/dns/resolve.c\n+++ b/subsys/net/lib/dns/resolve.c\n@@ -360,49 +361,39 @@ static inline int get_slot_by_id(struct dns_resolve_context *ctx,\n \treturn -ENOENT;\n }\n \n-static int dns_read(struct dns_resolve_context *ctx,\n- \t\t\tstruct net_pkt *pkt,\n- \t\t\tstruct net_buf *dns_data,\n- \t\t\tuint16_t *dns_id,\n- \t\t\tstruct net_buf *dns_cname,\n- \t\t\tuint16_t *query_hash)\n+int dns_validate_msg(struct dns_resolve_context *ctx,\n+ \t\t\tstruct dns_msg_t *dns_msg,\n+ \t\t\tuint16_t *dns_id,\n+ \t\t\tint *query_idx,\n+ \t\t\tstruct net_buf *dns_cname,\n+ \t\t\tuint16_t *query_hash) {\n \t// Validation logic added here\n- \t// Helper struct to track the dns msg received from the server\n- \tstruct dns_msg_t dns_msg;\n- \tint data_len;\n- \tint ret;\n- \tint query_idx = -1;\n- \n- \tdata_len = MIN(net_pkt_remaining_data(pkt), DNS_RESOLVER_MAX_BUF_SIZE);\n- \n- \tret = net_pkt_read(pkt, dns_data->data, data_len);\n- \tif (ret < 0) {\n- \t\tret = DNS_EAI_MEMORY;\n- \t\tgoto quit;\n- \t}\n- \n- \tdns_msg.msg = dns_data->data;\n- \tdns_msg.msg_size = data_len;\n- \n- \tret = dns_validate_msg(ctx, &dns_msg, dns_id, &query_idx,\n- \t\t\tdns_cname, query_hash);\n- \tif (ret == DNS_EAI_AGAIN) {\n- \t\tgoto finished;\n- \t}\n- \tif (ret < 0) {\n- \t\tgoto quit;\n- \t}\n \n \tif (k_delayed_work_remaining_get(&ctx->queries[query_idx].timer) > 0) {\n \t\tk_delayed_work_cancel(&ctx->queries[query_idx].timer);\n \t}\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When RDLENGTH is larger than the actual DNS message size, leading to potential out-of-bounds reads."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using cb_recv in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13601"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000083",
    "vulnerability": "Possible read out of bounds in dns read. Zephyr versions >= 1.14.2, >= 2.3.0 contain Out-of-bounds Read (CWE-125). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-mm57-9hqw-qh44",
    "affected_functions": [
      "dns_unpack_response_query"
    ],
    "functionality": "Unpacks the query section of a DNS response message.",
    "call_patterns": [
      {
        "pattern": "dns_unpack_response_query(subsys/net/lib/dns/dns_pack.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_unpack_response_query (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all buffer accesses are validated against the actual size of the data being processed. Specifically, check that offsets do not exceed the size of the buffer before performing any read or write operations. Additionally, when updating offsets, ensure that they are calculated based on the actual data structure sizes and not hardcoded values. Always validate the size of incoming data before processing it to prevent out-of-bounds reads or writes.",
      "code_snippet": "int dns_unpack_response_query(struct dns_msg_t *dns_msg) {\n    int offset = 0;\n    /* 4 bytes more due to qtype and qclass */\n    offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;\n    if (offset >= dns_msg->msg_size) {\n        return -ENOMEM;\n    }\n    // Additional processing...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/30503",
      "patch_diff": "diff --git a/subsys/net/lib/dns/dns_pack.c b/subsys/net/lib/dns/dns_pack.c\nindex 2c65bae5740ea..e318ceb36b5f2 100644\n--- a/subsys/net/lib/dns/dns_pack.c\n+++ b/subsys/net/lib/dns/dns_pack.c\n@@ -325,7 +325,7 @@ int dns_unpack_response_query(struct dns_msg_t *dns_msg)\n \n     /* 4 bytes more due to qtype and qclass */\n     offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;\n-    if (offset > dns_msg->msg_size) {\n+    if (offset >= dns_msg->msg_size) {\n         return -ENOMEM;\n     }\n \n@@ -434,6 +440,13 @@ static int dns_read(struct dns_resolve_context *ctx,\n                 goto quit;\n             }\n \n+            if ((dns_msg.response_position + address_size) >\n+                dns_msg.msg_size) {\n+                /* Too short message */\n+                ret = DNS_EAI_FAIL;\n+                goto quit;\n+            }\n+\n             src = dns_msg.msg + dns_msg.response_position;\n \n             memcpy(addr, src, address_size);\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the offset is equal to the size of the DNS message, leading to a read out-of-bounds."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_unpack_response_query in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13601"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000084",
    "vulnerability": "Possible read out of bounds in dns read. Zephyr versions >= 1.14.2, >= 2.3.0 contain Out-of-bounds Read (CWE-125). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-mm57-9hqw-qh44",
    "affected_functions": [
      "dns_copy_qname"
    ],
    "functionality": "Unpacks the query section of a DNS response message.",
    "call_patterns": [
      {
        "pattern": "dns_copy_qname(subsys/net/lib/dns/dns_pack.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_copy_qname (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all buffer accesses are validated against the actual size of the data being processed. Implement checks before reading or writing to buffers to prevent out-of-bounds access. Specifically, validate offsets and lengths before performing operations that depend on them, and ensure that any calculations involving offsets take into account the actual size of the data. Additionally, consider using safer functions that inherently check bounds.",
      "code_snippet": "int dns_copy_qname(u8_t *buf, u16_t *len, u16_t size, struct dns_msg_t *dns_msg) {\n    u8_t *msg = dns_msg->msg;\n    u16_t lb_size;\n    int rc = -EINVAL;\n    *len = 0U;\n    while (1) {\n        if (pos >= msg_size) {\n            rc = -ENOMEM;\n            break;\n        }\n        // Additional logic for processing...\n    }\n    return rc;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/30503",
      "patch_diff": "diff --git a/subsys/net/lib/dns/dns_pack.c b/subsys/net/lib/dns/dns_pack.c\nindex 2c65bae5740ea..e318ceb36b5f2 100644\n--- a/subsys/net/lib/dns/dns_pack.c\n+++ b/subsys/net/lib/dns/dns_pack.c\n@@ -325,7 +325,7 @@ int dns_unpack_response_query(struct dns_msg_t *dns_msg)\n \n     /* 4 bytes more due to qtype and qclass */\n     offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;\n-    if (offset > dns_msg->msg_size) {\n+    if (offset >= dns_msg->msg_size) {\n         return -ENOMEM;\n     }\n \n diff --git a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c\nindex b5ed8efa5689a..027c42ca7a798 100644\n--- a/subsys/net/lib/dns/resolve.c\n+++ b/subsys/net/lib/dns/resolve.c\n@@ -353,6 +353,12 @@ static int dns_read(struct dns_resolve_context *ctx,\n     dns_msg.msg = dns_data->data;\n     dns_msg.msg_size = data_len;\n \n+    /* Make sure that we can read DNS id, flags and rcode */\n+    if (dns_msg.msg_size < (sizeof(*dns_id) + sizeof(uint16_t))) {\n+        ret = DNS_EAI_FAIL;\n+        goto quit;\n+    }\n+\n     /* The dns_unpack_response_header() has design flaw as it expects\n      * dns id to be given instead of returning the id to the caller.\n      * In our case we would like to get it returned instead so that we\n@@ -434,6 +440,13 @@ static int dns_read(struct dns_resolve_context *ctx,\n                 goto quit;\n             }\n \n+            if ((dns_msg.response_position + address_size) >\n+                dns_msg.msg_size) {\n+                /* Too short message */\n+                ret = DNS_EAI_FAIL;\n+                goto quit;\n+            }\n+\n             src = dns_msg.msg + dns_msg.response_position;\n \n             memcpy(addr, src, address_size);\n@@ -456,7 +469,8 @@ static int dns_read(struct dns_resolve_context *ctx,\n         }\n \n         /* Update the answer offset to point to the next RR (answer) */\n-        dns_msg.answer_offset += DNS_ANSWER_PTR_LEN;\n+        dns_msg.answer_offset += dns_msg.response_position -\n+                            dns_msg.answer_offset;\n         dns_msg.answer_offset += dns_msg.response_length;\n \n         server_idx++;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the offset is equal to the size of the DNS message, leading to a read out-of-bounds."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_copy_qname in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13601"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000085",
    "vulnerability": "Possible read out of bounds in dns read. Zephyr versions >= 1.14.2, >= 2.3.0 contain Out-of-bounds Read (CWE-125). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-mm57-9hqw-qh44",
    "affected_functions": [
      "dns_unpack_answer"
    ],
    "functionality": "Unpacks the answer section of a DNS response message.",
    "call_patterns": [
      {
        "pattern": "dns_unpack_answer(subsys/net/lib/dns/dns_pack.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_unpack_answer (version: v2.3.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all buffer accesses are validated against their sizes before performing read or write operations. Specifically, check that offsets do not exceed the total message size and that any lengths derived from the message (like RDLENGTH) are validated against the remaining size of the message. Implement additional validation functions to encapsulate these checks and call them before processing the DNS message.",
      "code_snippet": "int dns_unpack_answer(struct dns_msg_t *dns_msg, int answer_ptr, uint32_t *ttl) {\n    // ... existing code ...\n    if (dns_msg->msg_size < (answer_ptr + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + RDLENGTH)) {\n        return -EINVAL;\n    }\n    // ... existing code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/27774",
      "patch_diff": "diff --git a/subsys/net/lib/dns/dns_pack.c b/subsys/net/lib/dns/dns_pack.c\nindex 31db15f167c53..4d72b1d896fdc 100644\n--- a/subsys/net/lib/dns/dns_pack.c\n+++ b/subsys/net/lib/dns/dns_pack.c\n@@ -361,14 +363,10 @@ int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,\n     uint8_t *msg = dns_msg->msg;\n     uint16_t lb_size;\n     int rc = -EINVAL;\n-    int i = 0;\n \n     *len = 0U;\n \n-    /* Iterate ANCOUNT + 1 to allow the Query's QNAME to be parsed.\n-     * This is required to avoid 'alias loops'\n-     */\n-    while (i++ < dns_header_ancount(dns_msg->msg) + 1) {\n+    while (1) {\n         if (pos >= msg_size) {\n             rc = -ENOMEM;\n             break;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the remaining size after unpacking the domain name is less than the expected size for the answer resource record."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_unpack_answer in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13601"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000086",
    "vulnerability": "Possible read out of bounds in dns read. Zephyr versions >= 1.14.2, >= 2.3.0 contain Out-of-bounds Read (CWE-125). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-mm57-9hqw-qh44",
    "affected_functions": [
      "dns_unpack_response_header"
    ],
    "functionality": "Unpacks the answer section of a DNS response message.",
    "call_patterns": [
      {
        "pattern": "dns_unpack_answer(subsys/net/lib/dns/dns_pack.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_unpack_response_header (version: v2.3.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all buffer accesses are validated against their sizes before performing read or write operations. Specifically, check that offsets do not exceed the total message size and that any lengths derived from the message (like RDLENGTH) are validated against the remaining size of the message. Implement additional validation functions to encapsulate these checks and call them before processing the DNS message.",
      "code_snippet": "int dns_unpack_answer(struct dns_msg_t *dns_msg, int answer_ptr, uint32_t *ttl) {\n    // ... existing code ...\n    if (dns_msg->msg_size < (answer_ptr + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + RDLENGTH)) {\n        return -EINVAL;\n    }\n    // ... existing code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/27774",
      "patch_diff": "diff --git a/subsys/net/lib/dns/dns_pack.c b/subsys/net/lib/dns/dns_pack.c\nindex 31db15f167c53..4d72b1d896fdc 100644\n--- a/subsys/net/lib/dns/dns_pack.c\n+++ b/subsys/net/lib/dns/dns_pack.c\n@@ -361,14 +363,10 @@ int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,\n     uint8_t *msg = dns_msg->msg;\n     uint16_t lb_size;\n     int rc = -EINVAL;\n-    int i = 0;\n \n     *len = 0U;\n \n-    /* Iterate ANCOUNT + 1 to allow the Query's QNAME to be parsed.\n-     * This is required to avoid 'alias loops'\n-     */\n-    while (i++ < dns_header_ancount(dns_msg->msg) + 1) {\n+    while (1) {\n         if (pos >= msg_size) {\n             rc = -ENOMEM;\n             break;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the remaining size after unpacking the domain name is less than the expected size for the answer resource record."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_unpack_response_header in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13601"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v2.3.0"
  },
  {
    "id": "VULN-000087",
    "vulnerability": "Remote Denial of Service in LwM2M do_write_op_tlv. Zephyr versions >= 1.14.2, >= 2.2.0 contain Improper Input Validation (CWE-20), Loop with Unreachable Exit Condition ('Infinite Loop') (CWE-835). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-g9mg-fj58-6fqh",
    "affected_functions": [
      "do_write_op_tlv"
    ],
    "functionality": "Processes LwM2M write operations based on the provided message.",
    "call_patterns": [
      {
        "pattern": "do_write_op_tlv(subsys/net/lib/lwm2m/lwm2m_rw_oma_tlv.c)<-do_write_op(subsys/net/lib/lwm2m/lwm2m_engine.c)<-handle_request(subsys/net/lib/lwm2m/lwm2m_engine.c)",
        "description": "Vulnerable call chain leading to do_write_op_tlv (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input types are validated before processing. If an unexpected type is encountered, return an appropriate error code instead of allowing the function to continue processing. This prevents infinite loops and potential denial of service attacks. Always check the input against expected values and handle unexpected cases gracefully.",
      "code_snippet": "int do_write_op_tlv(struct lwm2m_engine_obj *obj, struct lwm2m_message *msg) {\n    // existing code...\n    if (msg->operation == LWM2M_OP_WRITE || msg->operation == LWM2M_OP_CREATE) {\n        // processing logic...\n    } else {\n        return -ENOTSUP;\n    }\n    // existing code...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33578",
      "patch_diff": "+        } else {\n+            return -ENOTSUP;\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Malformed input that does not match expected TLV entry types, causing an infinite loop."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using do_write_op_tlv in vulnerable versions (v2.3.0 → v2.4.0)"
    ],
    "related_cve": [
      "CVE-2020-13602"
    ],
    "related_cwe": [
      "CWE-20,CWE-835"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000088",
    "vulnerability": "Type Confusion in 802154 ACK Frames Handling. Zephyr versions >= v2.4.0 contain NULL Pointer Dereference (CWE-476). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-27r3-rxch-2hm7",
    "affected_functions": [
      "ieee802154_recv"
    ],
    "functionality": "Handles the reception of IEEE 802.15.4 frames.",
    "call_patterns": [
      {
        "pattern": "ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_recv (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Receiving an ACK frame, which is not properly handled, leading to type confusion."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_recv in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3320"
    ],
    "related_cwe": [
      "CWE-476,CWE-843"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000089",
    "vulnerability": "Type Confusion in 802154 ACK Frames Handling. Zephyr versions >= v2.4.0 contain NULL Pointer Dereference (CWE-476). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-27r3-rxch-2hm7",
    "affected_functions": [
      "ieee802154_validate_frame"
    ],
    "functionality": "Validates the received IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_frame(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_validate_frame (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all frame types are explicitly handled in the receiving function. Validate the frame type before processing and return an appropriate verdict (e.g., NET_DROP) for unsupported types. Additionally, ensure that any pointers or structures are properly initialized to avoid dereferencing NULL pointers.",
      "code_snippet": "static enum net_verdict ieee802154_recv(struct net_if *iface, struct net_pkt *pkt) {\n    struct ieee802154_mpdu mpdu;\n    size_t hdr_len;\n\n    if (!ieee802154_validate_frame(net_pkt_data(pkt), net_pkt_get_len(pkt), &mpdu)) {\n        return NET_DROP;\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_BEACON) {\n        return ieee802154_handle_beacon(iface, &mpdu, net_pkt_ieee802154_lqi(pkt));\n    }\n\n    if (ieee802154_is_scanning(iface)) {\n        return NET_DROP;\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_MAC_COMMAND) {\n        return ieee802154_handle_mac_command(iface, &mpdu);\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_ACK) {\n        return NET_DROP;\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_DATA) {\n        ieee802154_acknowledge(iface, &mpdu);\n        set_pkt_ll_addr(net_pkt_lladdr_src(pkt), mpdu.mhr.fs->fc.pan_id_comp, mpdu.mhr.fs->fc.src_addr_mode, mpdu.mhr.src_addr);\n        set_pkt_ll_addr(net_pkt_lladdr_dst(pkt), false, mpdu.mhr.fs->fc.dst_addr_mode, mpdu.mhr.dst_addr);\n        if (!ieee802154_decipher_data_frame(iface, pkt, &mpdu)) {\n            return NET_DROP;\n        }\n        hdr_len = (uint8_t *)mpdu.payload - net_pkt_data(pkt);\n        net_buf_pull(pkt->buffer, hdr_len);\n        return ieee802154_manage_recv_packet(iface, pkt, hdr_len);\n    }\n\n    return NET_DROP;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_ACK) {\n    return NET_DROP;\n}\n\nif (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_DATA) {\n    ieee802154_acknowledge(iface, &mpdu);\n    // ... rest of the handling\n}\n\nreturn NET_DROP;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Validation recognizes ACK frame type, but processing does not handle it correctly."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_validate_frame in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3320"
    ],
    "related_cwe": [
      "CWE-476,CWE-843"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000090",
    "vulnerability": "Type Confusion in 802154 ACK Frames Handling. Zephyr versions >= v2.4.0 contain NULL Pointer Dereference (CWE-476). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-27r3-rxch-2hm7",
    "affected_functions": [
      "ieee802154_compute_header_size"
    ],
    "functionality": "Validates the received IEEE 802.15.4 frame.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_frame(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_compute_header_size (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all frame types are explicitly handled in the receiving function. Validate the frame type before processing and return an appropriate verdict (e.g., NET_DROP) for unsupported types. Additionally, ensure that any pointers or structures are properly initialized to avoid dereferencing NULL pointers.",
      "code_snippet": "static enum net_verdict ieee802154_recv(struct net_if *iface, struct net_pkt *pkt) {\n    struct ieee802154_mpdu mpdu;\n    size_t hdr_len;\n\n    if (!ieee802154_validate_frame(net_pkt_data(pkt), net_pkt_get_len(pkt), &mpdu)) {\n        return NET_DROP;\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_BEACON) {\n        return ieee802154_handle_beacon(iface, &mpdu, net_pkt_ieee802154_lqi(pkt));\n    }\n\n    if (ieee802154_is_scanning(iface)) {\n        return NET_DROP;\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_MAC_COMMAND) {\n        return ieee802154_handle_mac_command(iface, &mpdu);\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_ACK) {\n        return NET_DROP;\n    }\n\n    if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_DATA) {\n        ieee802154_acknowledge(iface, &mpdu);\n        set_pkt_ll_addr(net_pkt_lladdr_src(pkt), mpdu.mhr.fs->fc.pan_id_comp, mpdu.mhr.fs->fc.src_addr_mode, mpdu.mhr.src_addr);\n        set_pkt_ll_addr(net_pkt_lladdr_dst(pkt), false, mpdu.mhr.fs->fc.dst_addr_mode, mpdu.mhr.dst_addr);\n        if (!ieee802154_decipher_data_frame(iface, pkt, &mpdu)) {\n            return NET_DROP;\n        }\n        hdr_len = (uint8_t *)mpdu.payload - net_pkt_data(pkt);\n        net_buf_pull(pkt->buffer, hdr_len);\n        return ieee802154_manage_recv_packet(iface, pkt, hdr_len);\n    }\n\n    return NET_DROP;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "if (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_ACK) {\n    return NET_DROP;\n}\n\nif (mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_DATA) {\n    ieee802154_acknowledge(iface, &mpdu);\n    // ... rest of the handling\n}\n\nreturn NET_DROP;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Validation recognizes ACK frame type, but processing does not handle it correctly."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_compute_header_size in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3320"
    ],
    "related_cwe": [
      "CWE-476,CWE-843"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000091",
    "vulnerability": "DOS: Incorrect 802154 Frame Validation for Omitted Source / Dest Addresses. Zephyr versions >= > v2.4.0 contain NULL Pointer Dereference (CWE-476), Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-94jg-2p6q-5364",
    "affected_functions": [
      "ieee802154_validate_frame"
    ],
    "functionality": "Validates the IEEE 802.15.4 frame structure and addresses.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_frame(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_validate_frame (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Ensure that address validation functions return a failure indication when invalid addresses are encountered, especially for address types other than IEEE802154_ADDR_MODE_NONE. Modify the validate_addr function to accept a pointer to a struct ieee802154_address_field pointer, allowing it to set the address field only if validation is successful. In the ieee802154_validate_frame function, check the return value of validate_addr to determine if the address assignment was successful, and return false if it was not.",
      "code_snippet": "bool ieee802154_validate_frame(uint8_t *buf, uint8_t length, struct ieee802154_mpdu *mpdu) {\n    ...\n    if (!validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.dst_addr_mode, false, &mpdu->mhr.dst_addr) ||\n        !validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.src_addr_mode, (mpdu->mhr.fs->fc.pan_id_comp), &mpdu->mhr.src_addr)) {\n        return false;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex 1d479c85d9..42532eac41e01 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -439,13 +442,15 @@ bool ieee802154_validate_frame(uint8_t *buf, uint8_t length,\n \t\treturn false;\n \t}\n \n- mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n- \t\t\t\tfalse);\n- \n- mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n- \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp));\n+ if (!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n+ \t\t\t\tfalse, &mpdu->mhr.dst_addr) ||\n+ \t\t!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n+ \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp),\n+ \t\t\t\t&mpdu->mhr.src_addr)) {\n+ \t\treturn false;\n+ }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function may return NULL for source or destination addresses when the address mode is IEEE802154_ADDR_MODE_NONE or when the packet is too short."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_validate_frame in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3319"
    ],
    "related_cwe": [
      "CWE-476,CWE-588"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000092",
    "vulnerability": "DOS: Incorrect 802154 Frame Validation for Omitted Source / Dest Addresses. Zephyr versions >= > v2.4.0 contain NULL Pointer Dereference (CWE-476), Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-94jg-2p6q-5364",
    "affected_functions": [
      "ieee802154_compute_header_size"
    ],
    "functionality": "Validates the IEEE 802.15.4 frame structure and addresses.",
    "call_patterns": [
      {
        "pattern": "ieee802154_validate_frame(subsys/net/l2/ieee802154/ieee802154_frame.c)<-ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_compute_header_size (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Ensure that address validation functions return a failure indication when invalid addresses are encountered, especially for address types other than IEEE802154_ADDR_MODE_NONE. Modify the validate_addr function to accept a pointer to a struct ieee802154_address_field pointer, allowing it to set the address field only if validation is successful. In the ieee802154_validate_frame function, check the return value of validate_addr to determine if the address assignment was successful, and return false if it was not.",
      "code_snippet": "bool ieee802154_validate_frame(uint8_t *buf, uint8_t length, struct ieee802154_mpdu *mpdu) {\n    ...\n    if (!validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.dst_addr_mode, false, &mpdu->mhr.dst_addr) ||\n        !validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.src_addr_mode, (mpdu->mhr.fs->fc.pan_id_comp), &mpdu->mhr.src_addr)) {\n        return false;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex 1d479c85d9..42532eac41e01 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -439,13 +442,15 @@ bool ieee802154_validate_frame(uint8_t *buf, uint8_t length,\n \t\treturn false;\n \t}\n \n- mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n- \t\t\t\tfalse);\n- \n- mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n- \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp));\n+ if (!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n+ \t\t\t\tfalse, &mpdu->mhr.dst_addr) ||\n+ \t\t!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n+ \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp),\n+ \t\t\t\t&mpdu->mhr.src_addr)) {\n+ \t\treturn false;\n+ }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function may return NULL for source or destination addresses when the address mode is IEEE802154_ADDR_MODE_NONE or when the packet is too short."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_compute_header_size in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3319"
    ],
    "related_cwe": [
      "CWE-476,CWE-588"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000093",
    "vulnerability": "DOS: Incorrect 802154 Frame Validation for Omitted Source / Dest Addresses. Zephyr versions >= > v2.4.0 contain NULL Pointer Dereference (CWE-476), Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-94jg-2p6q-5364",
    "affected_functions": [
      "set_pkt_ll_addr"
    ],
    "functionality": "Sets the link-layer address for a packet based on the provided addressing mode.",
    "call_patterns": [
      {
        "pattern": "set_pkt_ll_addr(subsys/net/l2/ieee802154/ieee802154.c)<-ieee802154_recv(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to set_pkt_ll_addr (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Ensure that all address validation functions check for NULL pointers and handle them appropriately. If an address is expected but not present, the function should return an error or a failure state instead of allowing the program to continue with a NULL pointer. This can be done by modifying the validation function to return a boolean indicating success or failure, and passing a pointer to the address structure to be filled in if validation is successful.",
      "code_snippet": "bool ieee802154_validate_frame(uint8_t *buf, uint8_t length, struct ieee802154_mpdu *mpdu) {\n    ...\n    if (!validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.dst_addr_mode, false, &mpdu->mhr.dst_addr) ||\n        !validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.src_addr_mode, (mpdu->mhr.fs->fc.pan_id_comp), &mpdu->mhr.src_addr)) {\n        return false;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex 1d479c85d9..42532eac41e01 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -439,13 +442,15 @@ bool ieee802154_validate_frame(uint8_t *buf, uint8_t length,\n \t\treturn false;\n \t}\n \n- mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n- \t\t\t\tfalse);\n- \n- mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n- \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp));\n+ if (!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n+ \t\t\t\tfalse, &mpdu->mhr.dst_addr) ||\n+ \t\t!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n+ \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp), &mpdu->mhr.src_addr)) {\n+ \t\treturn false;\n+ }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function does not check for NULL pointers, leading to the assignment of a corrupted pointer when a NULL address is passed."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using set_pkt_ll_addr in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3319"
    ],
    "related_cwe": [
      "CWE-476,CWE-588"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000094",
    "vulnerability": "DOS: Incorrect 802154 Frame Validation for Omitted Source / Dest Addresses. Zephyr versions >= > v2.4.0 contain NULL Pointer Dereference (CWE-476), Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-94jg-2p6q-5364",
    "affected_functions": [
      "ieee802154_manage_recv_packet"
    ],
    "functionality": "Processes received packets and manages their handling based on the frame type.",
    "call_patterns": [
      {
        "pattern": "ieee802154_manage_recv_packet(subsys/net/l2/ieee802154/ieee802154.c)",
        "description": "Vulnerable call chain leading to ieee802154_manage_recv_packet (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Ensure that all address validation functions check for NULL pointers and handle cases where the address mode is not IEEE802154_ADDR_MODE_NONE. If an address is invalid, the function should return false, preventing further processing of potentially corrupted data.",
      "code_snippet": "bool ieee802154_validate_frame(uint8_t *buf, uint8_t length, struct ieee802154_mpdu *mpdu) {\n    ...\n    if (!validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.dst_addr_mode, false, &mpdu->mhr.dst_addr) ||\n        !validate_addr(p_buf, &p_buf, &length, mpdu->mhr.fs->fc.src_addr_mode, (mpdu->mhr.fs->fc.pan_id_comp), &mpdu->mhr.src_addr)) {\n        return false;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c\nindex 1d479c85d9..42532eac41e01 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_frame.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c\n@@ -439,13 +442,15 @@ bool ieee802154_validate_frame(uint8_t *buf, uint8_t length,\n \t\treturn false;\n\t}\n \n- mpdu->mhr.dst_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n- \t\t\t\tfalse);\n- \n- mpdu->mhr.src_addr = validate_addr(p_buf, &p_buf, &length,\n- \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n- \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp));\n+ if (!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.dst_addr_mode,\n+ \t\t\t\tfalse, &mpdu->mhr.dst_addr) ||\n+ \t\t!validate_addr(p_buf, &p_buf, &length,\n+ \t\t\t\tmpdu->mhr.fs->fc.src_addr_mode,\n+ \t\t\t\t(mpdu->mhr.fs->fc.pan_id_comp), &mpdu->mhr.src_addr)) {\n+ \t\treturn false;\n+ }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function uses potentially NULL source or destination addresses, which can lead to crashes or memory corruption."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ieee802154_manage_recv_packet in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3319"
    ],
    "related_cwe": [
      "CWE-476,CWE-588"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000095",
    "vulnerability": "BT: Possible to overwrite an existing bond during keys distribution phase when the identity address of the bond is known. Zephyr versions >= 1.14.2, >= 2.4.0, >= 2.5.0 contain Use of Multiple Resources with Duplicate Identifier (CWE-694). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-j76f-35mc-4h63",
    "affected_functions": [
      "bt_unpair"
    ],
    "functionality": "This function unpairs a device by removing its bond information.",
    "call_patterns": [
      {
        "pattern": "bt_unpair(subsys/bluetooth/host/hci_core.c)<-bt_id_reset(subsys/bluetooth/host/hci_core.c)<-cmd_id_reset(subsys/bluetooth/shell/bt.c)",
        "description": "Vulnerable call chain leading to bt_unpair (version: v2.5.0)"
      },
      {
        "pattern": "bt_unpair(subsys/bluetooth/host/hci_core.c)<-bt_id_delete(subsys/bluetooth/host/hci_core.c)<-cmd_id_delete(subsys/bluetooth/shell/bt.c)",
        "description": "Vulnerable call chain leading to bt_unpair (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that when handling identity addresses and bond information, you check for existing bonds before creating new entries. Implement checks to prevent overwriting existing bond information in RAM and persistent storage. Always validate the security level and keys associated with the bond to avoid security downgrades. Use appropriate functions to manage keys and ensure that the correct keys are used during pairing and reconnection processes.",
      "code_snippet": "int bt_unpair(uint8_t id, const bt_addr_le_t *addr) {\n    if (IS_ENABLED(CONFIG_BT_SMP) &&\n        (!addr || !bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {\n            bt_foreach_bond(id, unpair_remote, &id);\n            bt_rand(&bt_dev.irk[id], 16);\n            return 0;\n    }\n    unpair(id, addr);\n    bt_rand(&bt_dev.irk[id], 16);\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33266",
      "patch_diff": "@@ -2594,10 +2594,13 @@ int bt_unpair(uint8_t id, const bt_addr_le_t *addr) {\n        if (IS_ENABLED(CONFIG_BT_SMP) &&\n            (!addr || !bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {\n                bt_foreach_bond(id, unpair_remote, &id);\n+               bt_rand(&bt_dev.irk[id], 16);\n                return 0;\n        }\n        unpair(id, addr);\n+       bt_rand(&bt_dev.irk[id], 16);\n        return 0;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A new bond is created without checking for an existing bond with the same identity address."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bt_unpair in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2021-3436"
    ],
    "related_cwe": [
      "CWE-694"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000096",
    "vulnerability": "BT: Possible to overwrite an existing bond during keys distribution phase when the identity address of the bond is known. Zephyr versions >= 1.14.2, >= 2.4.0, >= 2.5.0 contain Use of Multiple Resources with Duplicate Identifier (CWE-694). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-j76f-35mc-4h63",
    "affected_functions": [
      "update_keys_check"
    ],
    "functionality": "This function checks if a new pairing procedure with an existing bond will not lower the established security level of the bond.",
    "call_patterns": [
      {
        "pattern": "update_keys_check(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to update_keys_check (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that when creating or updating bond information, you check for existing entries with the same identity address. If an entry exists, validate the security level and keys before overwriting or creating a new entry. This prevents duplicate entries and ensures that the correct keys are used during reconnections.",
      "code_snippet": "static bool update_keys_check(struct bt_smp *smp, struct bt_keys *keys) {\n    if (!keys || !(keys->keys & (BT_KEYS_LTK_P256 | BT_KEYS_LTK))) {\n        return true;\n    }\n    if (keys->enc_size > get_encryption_key_size(smp)) {\n        return false;\n    }\n    if ((keys->keys & BT_KEYS_LTK_P256) && !atomic_test_bit(smp->flags, SMP_FLAG_SC)) {\n        return false;\n    }\n    if ((keys->flags & BT_KEYS_AUTHENTICATED) && smp->method == JUST_WORKS) {\n        return false;\n    }\n    if (!IS_ENABLED(CONFIG_BT_SMP_ALLOW_UNAUTH_OVERWRITE) && (!(keys->flags & BT_KEYS_AUTHENTICATED) && smp->method == JUST_WORKS)) {\n        return false;\n    }\n    return true;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33266",
      "patch_diff": "if (!update_keys_check(smp, conn->le.keys)) {"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An unauthenticated pairing attempt is made when an authenticated bond already exists."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using update_keys_check in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2021-3436"
    ],
    "related_cwe": [
      "CWE-694"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000097",
    "vulnerability": "Zephyr JSON decoder incorrectly decodes array of array. Zephyr versions >= >1.14.0, >= >2.5.0 contain Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-289f-7mw3-2qf4",
    "affected_functions": [
      "arr_parse"
    ],
    "functionality": "Parses an array from a JSON object.",
    "call_patterns": [
      {
        "pattern": "<global>(lib/os/json.c)",
        "description": "Vulnerable call chain leading to arr_parse (version: v2.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that pointers to elements are validated before dereferencing them. Always check if the pointer is NULL before using it to avoid undefined behavior. Additionally, ensure that the length of arrays is correctly calculated and stored in the appropriate locations to prevent overwriting critical data.",
      "code_snippet": "static int arr_parse(struct json_obj *obj, void *val, const struct json_obj_descr *elem_descr, void *field, size_t max_elements) {\n    ptrdiff_t elem_size = get_elem_size(elem_descr);\n    void *last_elem = (char *)field + elem_size * max_elements;\n    size_t *elements = NULL;\n    struct token value;\n\n    if (val) {\n        elements = (size_t *)((char *)val + elem_descr->offset);\n    }\n\n    __ASSERT_NO_MSG(elem_size > 0);\n\n    if (elements) {\n        *elements = 0;\n    }\n\n    while (!arr_next(obj, &value)) {\n        if (value.type == JSON_TOK_LIST_END) {\n            break;\n        }\n\n        if (decode_value(obj, elem_descr, &value, field, NULL) < 0) {\n            return -EINVAL;\n        }\n\n        if (elements) {\n            (*elements)++;\n        }\n        field = (char *)field + elem_size;\n    }\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/36340",
      "patch_diff": "diff --git a/lib/os/json.c b/lib/os/json.c\nindex 69d3d614c901d..df52d13c13a4c 100644\n--- a/lib/os/json.c\n+++ b/lib/os/json.c\n@@ -509,12 +509,18 @@ static int arr_parse(struct json_obj *obj,\n {\n     ptrdiff_t elem_size = get_elem_size(elem_descr);\n     void *last_elem = (char *)field + elem_size * max_elements;\n-    size_t *elements = (size_t *)((char *)val + elem_descr->offset);\n+    size_t *elements = NULL;\n     struct token value;\n \n+    if (val) {\n+        elements = (size_t *)((char *)val + elem_descr->offset);\n+    }\n+\n     __ASSERT_NO_MSG(elem_size > 0);\n \n-    *elements = 0;\n+    if (elements) {\n+        *elements = 0;\n+    }\n \n     while (!arr_next(obj, &value)) {\n         if (value.type == JSON_TOK_LIST_END) {\n             return -ENOSPC;\n         }\n \n-        if (decode_value(obj, elem_descr, &value, field, val) < 0) {\n+        if (decode_value(obj, elem_descr, &value, field, NULL) < 0) {\n             return -EINVAL;\n         }\n \n-        (*elements)++;\n+        if (elements) {\n+            (*elements)++;\n+        }\n         field = (char *)field + elem_size;\n     }\n     return 0;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When using JSON_OBJ_DESCR_ARRAY_ARRAY with a subarray that has the token type JSON_TOK_LIST_START."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using arr_parse in vulnerable versions (v2.6.0 → v2.7.0)"
    ],
    "related_cve": [
      "CVE-2021-3510"
    ],
    "related_cwe": [
      "CWE-588"
    ],
    "vulnerable_version": "v2.6.0"
  },
  {
    "id": "VULN-000098",
    "vulnerability": "Zephyr JSON decoder incorrectly decodes array of array. Zephyr versions >= >1.14.0, >= >2.5.0 contain Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-289f-7mw3-2qf4",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Parses an array from a JSON object.",
    "call_patterns": [
      {
        "pattern": "<global>(lib/os/json.c)",
        "description": "Vulnerable call chain leading to <global> (version: v2.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that pointers to elements are validated before dereferencing them. Always check if the pointer is NULL before using it to avoid undefined behavior. Additionally, ensure that the length of arrays is correctly calculated and stored in the appropriate locations to prevent overwriting critical data.",
      "code_snippet": "static int arr_parse(struct json_obj *obj, void *val, const struct json_obj_descr *elem_descr, void *field, size_t max_elements) {\n    ptrdiff_t elem_size = get_elem_size(elem_descr);\n    void *last_elem = (char *)field + elem_size * max_elements;\n    size_t *elements = NULL;\n    struct token value;\n\n    if (val) {\n        elements = (size_t *)((char *)val + elem_descr->offset);\n    }\n\n    __ASSERT_NO_MSG(elem_size > 0);\n\n    if (elements) {\n        *elements = 0;\n    }\n\n    while (!arr_next(obj, &value)) {\n        if (value.type == JSON_TOK_LIST_END) {\n            break;\n        }\n\n        if (decode_value(obj, elem_descr, &value, field, NULL) < 0) {\n            return -EINVAL;\n        }\n\n        if (elements) {\n            (*elements)++;\n        }\n        field = (char *)field + elem_size;\n    }\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/36340",
      "patch_diff": "diff --git a/lib/os/json.c b/lib/os/json.c\nindex 69d3d614c901d..df52d13c13a4c 100644\n--- a/lib/os/json.c\n+++ b/lib/os/json.c\n@@ -509,12 +509,18 @@ static int arr_parse(struct json_obj *obj,\n {\n     ptrdiff_t elem_size = get_elem_size(elem_descr);\n     void *last_elem = (char *)field + elem_size * max_elements;\n-    size_t *elements = (size_t *)((char *)val + elem_descr->offset);\n+    size_t *elements = NULL;\n     struct token value;\n \n+    if (val) {\n+        elements = (size_t *)((char *)val + elem_descr->offset);\n+    }\n+\n     __ASSERT_NO_MSG(elem_size > 0);\n \n-    *elements = 0;\n+    if (elements) {\n+        *elements = 0;\n+    }\n \n     while (!arr_next(obj, &value)) {\n         if (value.type == JSON_TOK_LIST_END) {\n             return -ENOSPC;\n         }\n \n-        if (decode_value(obj, elem_descr, &value, field, val) < 0) {\n+        if (decode_value(obj, elem_descr, &value, field, NULL) < 0) {\n             return -EINVAL;\n         }\n \n-        (*elements)++;\n+        if (elements) {\n+            (*elements)++;\n+        }\n         field = (char *)field + elem_size;\n     }\n     return 0;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When using JSON_OBJ_DESCR_ARRAY_ARRAY with a subarray that has the token type JSON_TOK_LIST_START."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v2.6.0 → v2.7.0)"
    ],
    "related_cve": [
      "CVE-2021-3510"
    ],
    "related_cwe": [
      "CWE-588"
    ],
    "vulnerable_version": "v2.6.0"
  },
  {
    "id": "VULN-000099",
    "vulnerability": "Zephyr JSON decoder incorrectly decodes array of array. Zephyr versions >= >1.14.0, >= >2.5.0 contain Attempt to Access Child of a Non-structure Pointer (CWE-588). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-289f-7mw3-2qf4",
    "affected_functions": [
      "obj_parse"
    ],
    "functionality": "Parses an array from a JSON object.",
    "call_patterns": [
      {
        "pattern": "<global>(lib/os/json.c)",
        "description": "Vulnerable call chain leading to obj_parse (version: v2.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that pointers to elements are validated before dereferencing them. Always check if the pointer is NULL before using it to avoid undefined behavior. Additionally, ensure that the length of arrays is correctly calculated and stored in the appropriate locations to prevent overwriting critical data.",
      "code_snippet": "static int arr_parse(struct json_obj *obj, void *val, const struct json_obj_descr *elem_descr, void *field, size_t max_elements) {\n    ptrdiff_t elem_size = get_elem_size(elem_descr);\n    void *last_elem = (char *)field + elem_size * max_elements;\n    size_t *elements = NULL;\n    struct token value;\n\n    if (val) {\n        elements = (size_t *)((char *)val + elem_descr->offset);\n    }\n\n    __ASSERT_NO_MSG(elem_size > 0);\n\n    if (elements) {\n        *elements = 0;\n    }\n\n    while (!arr_next(obj, &value)) {\n        if (value.type == JSON_TOK_LIST_END) {\n            break;\n        }\n\n        if (decode_value(obj, elem_descr, &value, field, NULL) < 0) {\n            return -EINVAL;\n        }\n\n        if (elements) {\n            (*elements)++;\n        }\n        field = (char *)field + elem_size;\n    }\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/36340",
      "patch_diff": "diff --git a/lib/os/json.c b/lib/os/json.c\nindex 69d3d614c901d..df52d13c13a4c 100644\n--- a/lib/os/json.c\n+++ b/lib/os/json.c\n@@ -509,12 +509,18 @@ static int arr_parse(struct json_obj *obj,\n {\n     ptrdiff_t elem_size = get_elem_size(elem_descr);\n     void *last_elem = (char *)field + elem_size * max_elements;\n-    size_t *elements = (size_t *)((char *)val + elem_descr->offset);\n+    size_t *elements = NULL;\n     struct token value;\n \n+    if (val) {\n+        elements = (size_t *)((char *)val + elem_descr->offset);\n+    }\n+\n     __ASSERT_NO_MSG(elem_size > 0);\n \n-    *elements = 0;\n+    if (elements) {\n+        *elements = 0;\n+    }\n \n     while (!arr_next(obj, &value)) {\n         if (value.type == JSON_TOK_LIST_END) {\n             return -ENOSPC;\n         }\n \n-        if (decode_value(obj, elem_descr, &value, field, val) < 0) {\n+        if (decode_value(obj, elem_descr, &value, field, NULL) < 0) {\n             return -EINVAL;\n         }\n \n-        (*elements)++;\n+        if (elements) {\n+            (*elements)++;\n+        }\n         field = (char *)field + elem_size;\n     }\n     return 0;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When using JSON_OBJ_DESCR_ARRAY_ARRAY with a subarray that has the token type JSON_TOK_LIST_START."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using obj_parse in vulnerable versions (v2.6.0 → v2.7.0)"
    ],
    "related_cve": [
      "CVE-2021-3510"
    ],
    "related_cwe": [
      "CWE-588"
    ],
    "vulnerable_version": "v2.6.0"
  },
  {
    "id": "VULN-000100",
    "vulnerability": "Buffer Access with Incorrect Length Value in zephyr. Zephyr versions >= >=2.5.0 contain Buffer Access with Incorrect Length Value (CWE-805). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-8q65-5gqf-fmw5",
    "affected_functions": [
      "ull_scan_rsp_set"
    ],
    "functionality": "Sets the scan response data for a Bluetooth advertising set.",
    "call_patterns": [
      {
        "pattern": "ull_scan_rsp_set(subsys/bluetooth/controller/ll_sw/ull_adv.c)<-ll_adv_scan_rsp_set(subsys/bluetooth/controller/ll_sw/ull_adv.c)",
        "description": "Vulnerable call chain leading to ull_scan_rsp_set (version: v2.5.0)"
      },
      {
        "pattern": "ull_scan_rsp_set(subsys/bluetooth/controller/ll_sw/ull_adv.c)<-ll_adv_aux_sr_data_set(subsys/bluetooth/controller/ll_sw/ull_adv_aux.c)",
        "description": "Vulnerable call chain leading to ull_scan_rsp_set (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/35935",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the incoming HCI data exceeds PDU_AC_DATA_SIZE_MAX."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_scan_rsp_set in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3581"
    ],
    "related_cwe": [
      "CWE-1284,CWE-805"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000101",
    "vulnerability": "Buffer overflow in Zephyr USB DFU DNLOAD. Zephyr versions >= v2.5.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-c3gr-hgvr-f363",
    "affected_functions": [
      "dfu_class_handle_req"
    ],
    "functionality": "Handles DFU Class requests for device firmware updates.",
    "call_patterns": [
      {
        "pattern": "dfu_class_handle_req(subsys/usb/class/dfu/usb_dfu.c)",
        "description": "Vulnerable call chain leading to dfu_class_handle_req (version: v2.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length of data being processed is validated against the maximum allowed size before any memory operations. Implement checks to prevent buffer overflows by comparing the incoming request length with the configured buffer size. Additionally, separate handling for requests directed to the host and device should be implemented to ensure that each type of request is processed correctly and securely.",
      "code_snippet": "static int dfu_class_handle_req(struct usb_setup_packet *setup, int32_t *data_len, uint8_t **data) {\n    if (usb_reqtype_is_to_host(setup)) {\n        return dfu_class_handle_to_host(setup, data_len, data);\n    } else {\n        return dfu_class_handle_to_device(setup, data_len, data);\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/36694",
      "patch_diff": "diff --git a/subsys/usb/class/dfu/usb_dfu.c b/subsys/usb/class/dfu/usb_dfu.c\n--- a/subsys/usb/class/dfu/usb_dfu.c\n+++ b/subsys/usb/class/dfu/usb_dfu.c\n@@ -385,23 +385,14 @@ static void dfu_timer_expired(struct k_timer *timer) {\n }\n \n static int dfu_class_handle_req(struct usb_setup_packet *setup,\n-        int32_t *data_len, uint8_t **data) {\n-    if (usb_reqtype_is_to_host(setup)) {\n-        return dfu_class_handle_to_host(setup, data_len, data);\n-    } else {\n-        return dfu_class_handle_to_device(setup, data_len, data);\n-    }\n-}\n+\n+    if (usb_reqtype_is_to_host(setup)) {\n+        return dfu_class_handle_to_host(setup, data_len, data);\n+    } else {\n+        return dfu_class_handle_to_device(setup, data_len, data);\n+    }\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When a control transfer read request with wLength exceeding CONFIG_USB_REQUEST_BUFFER_SIZE is sent."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dfu_class_handle_req in vulnerable versions (v2.6.0 → v2.7.0)"
    ],
    "related_cve": [
      "CVE-2021-3625"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.6.0"
  },
  {
    "id": "VULN-000102",
    "vulnerability": "Buffer overflow in Zephyr USB DFU DNLOAD. Zephyr versions >= v2.5.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-c3gr-hgvr-f363",
    "affected_functions": [
      "usb_handle_control_transfer"
    ],
    "functionality": "Processes control transfer requests from USB devices.",
    "call_patterns": [
      {
        "pattern": "usb_handle_control_transfer(subsys/usb/usb_device.c)",
        "description": "Vulnerable call chain leading to usb_handle_control_transfer (version: v2.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length of data being processed is validated against the maximum allowed size before any memory operations. Implement checks to prevent buffer overflows by comparing the requested length with predefined buffer sizes. Additionally, separate handling for requests directed to the host and device should be established to ensure that the appropriate checks are applied based on the request type.",
      "code_snippet": "static void usb_handle_control_transfer(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status) {\n    struct usb_setup_packet *setup = &usb_dev.setup;\n    if (ep == USB_CONTROL_OUT_EP0 && ep_status == USB_DC_EP_SETUP) {\n        if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw, sizeof(setup_raw), NULL) < 0) {\n            usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);\n            return;\n        }\n        setup->wLength = sys_le16_to_cpu(setup_raw.wLength);\n        if (usb_reqtype_is_to_device(setup) && setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {\n            usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);\n            usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);\n            return;\n        }\n        usb_dev.data_buf_len = (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) ? CONFIG_USB_REQUEST_BUFFER_SIZE : setup->wLength;\n        usb_dev.data_buf_residue = usb_dev.data_buf_len;\n        // Continue with data processing...\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/36694",
      "patch_diff": "diff --git a/subsys/usb/usb_device.c b/subsys/usb/usb_device.c\nindex 388dc80f6c222..01f7979f4e32d 100644\n--- a/subsys/usb/usb_device.c\n+++ b/subsys/usb/usb_device.c\n@@ -306,22 +306,30 @@ static void usb_handle_control_transfer(uint8_t ep,\n \n \n-        if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {\n-            if (usb_reqtype_is_to_device(setup)) {\n+        usb_dev.data_buf = usb_dev.req_data;\n+        usb_dev.zlp_flag = false;\n+        /*\n+         * Set length to 0 as a precaution so that no trouble\n+         * happens if control request handler does not check the\n+         * request values sufficiently.\n+         */\n+        usb_dev.data_buf_len = 0;\n+        usb_dev.data_buf_residue = 0;\n+\n+        if (usb_reqtype_is_to_device(setup)) {\n+            if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {\n                 LOG_ERR(\"Request buffer too small\");\n                 usb_dc_ep_set_stall(USB_CONTROL_EP_IN);\n                 usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);\n                 return;\n             }\n-        }\n \n-        usb_dev.data_buf = usb_dev.req_data;\n-        usb_dev.data_buf_residue = setup->wLength;\n-        usb_dev.data_buf_len = setup->wLength;\n-        usb_dev.zlp_flag = false;\n+\n+            if (setup->wLength) {\n+                /* Continue with data OUT stage */\n+                usb_dev.data_buf_len = setup->wLength;\n+                usb_dev.data_buf_residue = setup->wLength;\n+                return;\n+            }\n         }\n \n         /* Ask installed handler to process request */"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When setup->wLength is greater than CONFIG_USB_REQUEST_BUFFER_SIZE and the request is directed to the device."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using usb_handle_control_transfer in vulnerable versions (v2.6.0 → v2.7.0)"
    ],
    "related_cve": [
      "CVE-2021-3625"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.6.0"
  },
  {
    "id": "VULN-000103",
    "vulnerability": "Buffer overflow in Zephyr USB DFU DNLOAD. Zephyr versions >= v2.5.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-c3gr-hgvr-f363",
    "affected_functions": [
      "usb_register_request_handler"
    ],
    "functionality": "Processes control transfer requests from USB devices.",
    "call_patterns": [
      {
        "pattern": "usb_handle_control_transfer(subsys/usb/usb_device.c)",
        "description": "Vulnerable call chain leading to usb_register_request_handler (version: v2.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the length of data being processed is validated against the maximum allowed size before any memory operations. Implement checks to prevent buffer overflows by comparing the requested length with predefined buffer sizes. Additionally, separate handling for requests directed to the host and device should be established to ensure that the appropriate checks are applied based on the request type.",
      "code_snippet": "static void usb_handle_control_transfer(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status) {\n    struct usb_setup_packet *setup = &usb_dev.setup;\n    if (ep == USB_CONTROL_OUT_EP0 && ep_status == USB_DC_EP_SETUP) {\n        if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw, sizeof(setup_raw), NULL) < 0) {\n            usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);\n            return;\n        }\n        setup->wLength = sys_le16_to_cpu(setup_raw.wLength);\n        if (usb_reqtype_is_to_device(setup) && setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {\n            usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);\n            usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);\n            return;\n        }\n        usb_dev.data_buf_len = (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) ? CONFIG_USB_REQUEST_BUFFER_SIZE : setup->wLength;\n        usb_dev.data_buf_residue = usb_dev.data_buf_len;\n        // Continue with data processing...\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/36694",
      "patch_diff": "diff --git a/subsys/usb/usb_device.c b/subsys/usb/usb_device.c\nindex 388dc80f6c222..01f7979f4e32d 100644\n--- a/subsys/usb/usb_device.c\n+++ b/subsys/usb/usb_device.c\n@@ -306,22 +306,30 @@ static void usb_handle_control_transfer(uint8_t ep,\n \n \n-        if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {\n-            if (usb_reqtype_is_to_device(setup)) {\n+        usb_dev.data_buf = usb_dev.req_data;\n+        usb_dev.zlp_flag = false;\n+        /*\n+         * Set length to 0 as a precaution so that no trouble\n+         * happens if control request handler does not check the\n+         * request values sufficiently.\n+         */\n+        usb_dev.data_buf_len = 0;\n+        usb_dev.data_buf_residue = 0;\n+\n+        if (usb_reqtype_is_to_device(setup)) {\n+            if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {\n                 LOG_ERR(\"Request buffer too small\");\n                 usb_dc_ep_set_stall(USB_CONTROL_EP_IN);\n                 usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);\n                 return;\n             }\n-        }\n \n-        usb_dev.data_buf = usb_dev.req_data;\n-        usb_dev.data_buf_residue = setup->wLength;\n-        usb_dev.data_buf_len = setup->wLength;\n-        usb_dev.zlp_flag = false;\n+\n+            if (setup->wLength) {\n+                /* Continue with data OUT stage */\n+                usb_dev.data_buf_len = setup->wLength;\n+                usb_dev.data_buf_residue = setup->wLength;\n+                return;\n+            }\n         }\n \n         /* Ask installed handler to process request */"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When setup->wLength is greater than CONFIG_USB_REQUEST_BUFFER_SIZE and the request is directed to the device."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using usb_register_request_handler in vulnerable versions (v2.6.0 → v2.7.0)"
    ],
    "related_cve": [
      "CVE-2021-3625"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.6.0"
  },
  {
    "id": "VULN-000104",
    "vulnerability": "Integer Underflow in Zephyr in IEEE 802154 Fragment Reassembly Header Removal. Zephyr versions >= >=2.4.0 contain Integer Overflow to Buffer Overflow (CWE-680). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-w44j-66g7-xw99",
    "affected_functions": [
      "fragment_reconstruct_packet"
    ],
    "functionality": "Reconstructs a packet from its fragments by removing headers.",
    "call_patterns": [
      {
        "pattern": "fragment_reconstruct_packet(subsys/net/l2/ieee802154/ieee802154_fragment.c)<-fragment_add_to_cache(subsys/net/l2/ieee802154/ieee802154_fragment.c)",
        "description": "Vulnerable call chain leading to fragment_reconstruct_packet (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An IEEE 802154 fragment with an insufficient size that leads to an integer underflow during header removal."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fragment_reconstruct_packet in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3321"
    ],
    "related_cwe": [
      "CWE-191,CWE-680"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000105",
    "vulnerability": "Integer Underflow in Zephyr in IEEE 802154 Fragment Reassembly Header Removal. Zephyr versions >= >=2.4.0 contain Integer Overflow to Buffer Overflow (CWE-680). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-w44j-66g7-xw99",
    "affected_functions": [
      "fragment_add_to_cache"
    ],
    "functionality": "Adds a fragment to the cache for reassembly.",
    "call_patterns": [
      {
        "pattern": "fragment_add_to_cache(subsys/net/l2/ieee802154/ieee802154_fragment.c)",
        "description": "Vulnerable call chain leading to fragment_add_to_cache (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A fragment that does not meet the minimum size requirement for its header, leading to potential out-of-bounds memory operations."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fragment_add_to_cache in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3321"
    ],
    "related_cwe": [
      "CWE-191,CWE-680"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000106",
    "vulnerability": "Integer Underflow in 6LoWPAN IPHC Header Uncompression in Zephyr. Zephyr versions >= >=2.4.0 contain Integer Underflow (Wrap or Wraparound) (CWE-191). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-89j6-qpxf-pfpc",
    "affected_functions": [
      "uncompress_IPHC_header"
    ],
    "functionality": "This function uncompresses the 6LoWPAN IPHC header from a network packet.",
    "call_patterns": [
      {
        "pattern": "uncompress_IPHC_header(subsys/net/ip/6lo.c)<-net_6lo_uncompress(subsys/net/ip/6lo.c)<-net_bt_recv(subsys/net/l2/bluetooth/bluetooth.c)",
        "description": "Vulnerable call chain leading to uncompress_IPHC_header (version: v2.4.0)"
      },
      {
        "pattern": "uncompress_IPHC_header(subsys/net/ip/6lo.c)<-net_6lo_uncompress(subsys/net/ip/6lo.c)<-canbus_finish_pkt(subsys/net/l2/canbus/6locan.c)<-canbus_process_sf(subsys/net/l2/canbus/6locan.c)<-canbus_process_frame(subsys/net/l2/canbus/6locan.c)<-canbus_recv(subsys/net/l2/canbus/6locan.c)",
        "description": "Vulnerable call chain leading to uncompress_IPHC_header (version: v2.4.0)"
      },
      {
        "pattern": "uncompress_IPHC_header(subsys/net/ip/6lo.c)<-net_6lo_uncompress(subsys/net/ip/6lo.c)<-fragment_add_to_cache(subsys/net/l2/ieee802154/ieee802154_fragment.c)",
        "description": "Vulnerable call chain leading to uncompress_IPHC_header (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, always validate the size of the incoming data against the expected size before performing operations that manipulate buffers. Implement checks to ensure that the buffer has enough space to accommodate the data being processed. If the buffer is insufficient, log an error and return early to prevent underflows or overflows. Additionally, consider the context of how data is received and processed, especially in fragmented scenarios, to ensure that all parts of the data are accounted for.",
      "code_snippet": "static bool uncompress_IPHC_header(struct net_pkt *pkt) {\n    size_t compressed_hdr_size = ...; // Calculate based on iphc metadata\n\n    if (pkt->buffer->len < compressed_hdr_size) {\n        NET_ERR(\"Scattered compressed header?\");\n        return false;\n    }\n\n    if (net_buf_tailroom(pkt->buffer) >= diff) {\n        NET_DBG(\"Enough tailroom. Uncompress inplace\");\n        frag = pkt->buffer;\n        // Further processing...\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31971",
      "patch_diff": "if (pkt->buffer->len < compressed_hdr_size) {\n    NET_ERR(\"Scattered compressed header?\");\n    return false;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when the size of the compressed header exceeds the actual length of the packet buffer, leading to an integer underflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using uncompress_IPHC_header in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3323"
    ],
    "related_cwe": [
      "CWE-191"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000107",
    "vulnerability": "RCE/DOS: Linked-list corruption leading to large out-of-bounds write while sorting for forged fragment list in Zephyr. Zephyr versions >= >=2.4.0 contain Out-of-bounds Write (CWE-787). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fj4r-373f-9456",
    "affected_functions": [
      "fragment_reconstruct_packet"
    ],
    "functionality": "This function sorts the fragments of a packet to reconstruct the full data packet.",
    "call_patterns": [
      {
        "pattern": "fragment_reconstruct_packet(subsys/net/l2/ieee802154/ieee802154_fragment.c)<-fragment_add_to_cache(subsys/net/l2/ieee802154/ieee802154_fragment.c)",
        "description": "Vulnerable call chain leading to fragment_reconstruct_packet (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the fragment reassembly logic explicitly checks for the presence of the FRAG1 fragment before proceeding with sorting. If the FRAG1 fragment is missing, handle the case gracefully by either dropping the packet or adjusting the sorting logic to accommodate the absence of the expected fragment. Always validate the integrity of the fragment list before processing to prevent cyclic references and out-of-bounds memory operations.",
      "code_snippet": "static inline void fragment_reconstruct_packet(struct net_pkt *pkt) {\n    struct net_buf *prev, *current, *next;\n    prev = NULL;\n    current = pkt->buffer;\n    if (!fragment_packet_valid(pkt)) {\n        NET_ERR(\"Invalid fragmented packet\");\n        return;\n    }\n    while (current) {\n        next = current->frags;\n        if (!prev || (fragment_offset(prev) > fragment_offset(current))) {\n            prev = current;\n        } else {\n            fragment_move_back(pkt, current, prev);\n        }\n        current = next;\n    }\n    fragment_remove_headers(pkt);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "diff --git a/subsys/net/l2/ieee802154/ieee802154_fragment.c b/subsys/net/l2/ieee802154/ieee802154_fragment.c\nindex 790c159b56048..8d691bfede41d 100644\n--- a/subsys/net/l2/ieee802154/ieee802154_fragment.c\n+++ b/subsys/net/l2/ieee802154/ieee802154_fragment.c\n@@ -471,6 +472,11 @@ static inline void fragment_reconstruct_packet(struct net_pkt *pkt) {\n+    if (!fragment_packet_valid(pkt)) {\n+        NET_ERR(\"Invalid fragmented packet\");\n+        return;\n+    }\n    struct net_buf *prev, *current, *next;\n    prev = NULL;\n    current = pkt->buffer;\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An attacker sends a forged fragment list that misses the FRAG1 fragment, leading to improper sorting and a cyclic fragment list."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fragment_reconstruct_packet in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3330"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000108",
    "vulnerability": "RCE/DOS: Linked-list corruption leading to large out-of-bounds write while sorting for forged fragment list in Zephyr. Zephyr versions >= >=2.4.0 contain Out-of-bounds Write (CWE-787). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fj4r-373f-9456",
    "affected_functions": [
      "fragment_move_back"
    ],
    "functionality": "This function moves a fragment back in the list to maintain the correct order based on fragment offsets.",
    "call_patterns": [
      {
        "pattern": "fragment_move_back(subsys/net/l2/ieee802154/ieee802154_fragment.c)<-fragment_reconstruct_packet(subsys/net/l2/ieee802154/ieee802154_fragment.c)<-fragment_add_to_cache(subsys/net/l2/ieee802154/ieee802154_fragment.c)",
        "description": "Vulnerable call chain leading to fragment_move_back (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the fragment reassembly logic explicitly checks for the presence of the FRAG1 fragment before proceeding with sorting. If the FRAG1 fragment is missing, handle the case appropriately to avoid creating cyclic linked lists. Additionally, validate the integrity of the fragments before processing them to prevent out-of-bounds writes.",
      "code_snippet": "static inline bool fragment_packet_valid(struct net_pkt *pkt) {\n    return (get_datagram_type(pkt->buffer->data) == NET_6LO_DISPATCH_FRAG1);\n}\n\nif (!fragment_packet_valid(pkt)) {\n    NET_ERR(\"Invalid fragmented packet\");\n    return NET_DROP;\n}\n\nfragment_reconstruct_packet(pkt);",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "if (!fragment_packet_valid(pkt)) {\n    NET_ERR(\"Invalid fragmented packet\");\n    return NET_DROP;\n}\n\nfragment_reconstruct_packet(pkt);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called during the sorting process when a fragment with a large offset is incorrectly placed as the first fragment."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fragment_move_back in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3330"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000109",
    "vulnerability": "RCE/DOS: Linked-list corruption leading to large out-of-bounds write while sorting for forged fragment list in Zephyr. Zephyr versions >= >=2.4.0 contain Out-of-bounds Write (CWE-787). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fj4r-373f-9456",
    "affected_functions": [
      "fragment_remove_headers"
    ],
    "functionality": "This function removes unnecessary headers from the fragments to retain only the actual payload.",
    "call_patterns": [
      {
        "pattern": "fragment_remove_headers(subsys/net/l2/ieee802154/ieee802154_fragment.c)<-fragment_reconstruct_packet(subsys/net/l2/ieee802154/ieee802154_fragment.c)<-fragment_add_to_cache(subsys/net/l2/ieee802154/ieee802154_fragment.c)",
        "description": "Vulnerable call chain leading to fragment_remove_headers (version: v2.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the fragment reassembly logic explicitly checks for the presence of the FRAG1 fragment before proceeding with sorting and processing. Implement validation checks to handle cases where the expected fragment structure is not met, preventing the creation of cyclic lists and ensuring that the linked list remains properly terminated. Always validate the integrity of the fragment list before performing operations that assume a well-formed structure.",
      "code_snippet": "static inline bool fragment_packet_valid(struct net_pkt *pkt) {\n    return (get_datagram_type(pkt->buffer->data) == NET_6LO_DISPATCH_FRAG1);\n}\n\nif (!fragment_packet_valid(pkt)) {\n    NET_ERR(\"Invalid fragmented packet\");\n    return NET_DROP;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/31908",
      "patch_diff": "if (!fragment_packet_valid(pkt)) {\n    NET_ERR(\"Invalid fragmented packet\");\n    return NET_DROP;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function assumes a NULL-terminated singly-linked list, which is corrupted due to the cyclic list created by the sorting logic."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fragment_remove_headers in vulnerable versions (v2.4.0 → v2.5.0)"
    ],
    "related_cve": [
      "CVE-2021-3330"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.4.0"
  },
  {
    "id": "VULN-000110",
    "vulnerability": "Truncated L2CAP K-frame causes assertion failure. Zephyr versions >= 2.4.0, >= v.2.50 contain Improper Handling of Length Parameter Inconsistency (CWE-130), Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fx88-6c29-vrp3",
    "affected_functions": [
      "l2cap_chan_le_recv"
    ],
    "functionality": "Handles the reception of L2CAP data packets.",
    "call_patterns": [
      {
        "pattern": "l2cap_chan_le_recv(subsys/bluetooth/host/l2cap.c)",
        "description": "Vulnerable call chain leading to l2cap_chan_le_recv (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/32588",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the SDU length field is truncated to only one byte, leading to an assertion failure."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using l2cap_chan_le_recv in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3454"
    ],
    "related_cwe": [
      "CWE-130,CWE-617"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000111",
    "vulnerability": "Disconnecting L2CAP channel right after invalid ATT request leads freeze. Zephyr versions >= 2.4.0, >= 2.5.0 contain Use After Free (CWE-416). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7g38-3x9v-v7vp",
    "affected_functions": [
      "l2cap_chan_sdu_sent"
    ],
    "functionality": "Handles the callback for when a Service Data Unit (SDU) has been sent over a L2CAP channel.",
    "call_patterns": [
      {
        "pattern": "l2cap_chan_sdu_sent(subsys/bluetooth/host/l2cap.c)",
        "description": "Vulnerable call chain leading to l2cap_chan_sdu_sent (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any callback functions that may be invoked after a resource has been freed first check if the resource is still valid. This can be done by looking up the resource using a unique identifier (like a channel ID) before proceeding with any operations on it. If the resource is not found, safely return from the function to prevent accessing freed memory.",
      "code_snippet": "static void l2cap_chan_sdu_sent(struct bt_conn *conn, void *user_data) {\n\tuint16_t cid = POINTER_TO_UINT(user_data);\n\tstruct bt_l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p CID 0x%04x\", conn, cid);\n\t\n\tchan = bt_l2cap_le_lookup_tx_cid(conn, cid);\n\tif (!chan) {\n\t\t/* Received SDU sent callback for disconnected channel */\n\t\treturn;\n\t}\n\n\tif (chan->ops->sent) {\n\t\tchan->ops->sent(chan);\n\t}\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/35597",
      "patch_diff": "if (!chan) {\n\t\t/* Received SDU sent callback for disconnected channel */\n\t\treturn;\n\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Sending a malformed ATT request on an EATT channel and disconnecting the L2CAP immediately."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using l2cap_chan_sdu_sent in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3455"
    ],
    "related_cwe": [
      "CWE-416"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000112",
    "vulnerability": "Disconnecting L2CAP channel right after invalid ATT request leads freeze. Zephyr versions >= 2.4.0, >= 2.5.0 contain Use After Free (CWE-416). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7g38-3x9v-v7vp",
    "affected_functions": [
      "l2cap_chan_seg_sent"
    ],
    "functionality": "Handles the callback for when a segment has been sent over a L2CAP channel.",
    "call_patterns": [
      {
        "pattern": "l2cap_chan_seg_sent(subsys/bluetooth/host/l2cap.c)",
        "description": "Vulnerable call chain leading to l2cap_chan_seg_sent (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any callback functions that operate on potentially freed memory first verify the validity of the associated channel. This can be done by looking up the channel using a unique identifier (CID) before proceeding with any operations. If the channel is not found, return early to prevent access to invalid memory.",
      "code_snippet": "static void l2cap_chan_seg_sent(struct bt_conn *conn, void *user_data) {\n    uint16_t cid = POINTER_TO_UINT(user_data);\n    struct bt_l2cap_chan *chan;\n\n    BT_DBG(\"conn %p CID 0x%04x\", conn, cid);\n\n    chan = bt_l2cap_le_lookup_tx_cid(conn, cid);\n    if (!chan) {\n        /* Received segment sent callback for disconnected channel */\n        return;\n    }\n\n    l2cap_chan_tx_resume(BT_L2CAP_LE_CHAN(chan));\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/35597",
      "patch_diff": "diff --git a/subsys/bluetooth/host/l2cap.c b/subsys/bluetooth/host/l2cap.c\nindex fdb68f8302a22..d83a3cac386c4 100644\n--- a/subsys/bluetooth/host/l2cap.c\n+++ b/subsys/bluetooth/host/l2cap.c\n@@ -1696,9 +1703,16 @@ static void l2cap_chan_seg_sent(struct bt_conn *conn, void *user_data)\n {\n-    struct bt_l2cap_chan *chan = user_data;\n+    uint16_t cid = POINTER_TO_UINT(user_data);\n+    struct bt_l2cap_chan *chan;\n \n-    BT_DBG(\"conn %p chan %p\", conn, chan);\n+    BT_DBG(\"conn %p CID 0x%04x\", conn, cid);\n+\n+    chan = bt_l2cap_le_lookup_tx_cid(conn, cid);\n+    if (!chan) {\n+        /* Received segment sent callback for disconnected channel */\n+        return;\n+    }\n \n    l2cap_chan_tx_resume(BT_L2CAP_LE_CHAN(chan));\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Sending a malformed ATT request on an EATT channel and disconnecting the L2CAP immediately."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using l2cap_chan_seg_sent in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3455"
    ],
    "related_cwe": [
      "CWE-416"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000113",
    "vulnerability": "Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf",
    "affected_functions": [
      "bluetooth_class_handler"
    ],
    "functionality": "Handles control transfers for Bluetooth USB devices.",
    "call_patterns": [
      {
        "pattern": "bluetooth_class_handler(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bluetooth_class_handler (version: v2.7.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42167",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When a control transfer is processed and the data size exceeds the available buffer size."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bluetooth_class_handler in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2021-3835"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.7.1"
  },
  {
    "id": "VULN-000114",
    "vulnerability": "Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf",
    "affected_functions": [
      "bluetooth_init"
    ],
    "functionality": "Handles control transfers for Bluetooth USB devices.",
    "call_patterns": [
      {
        "pattern": "bluetooth_init(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bluetooth_init (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42093",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When a control transfer is processed and the data size exceeds the available buffer size."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bluetooth_init in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2021-3835"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000115",
    "vulnerability": "Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf",
    "affected_functions": [
      "bt_buf_get_tx"
    ],
    "functionality": "Allocates a transmission buffer for Bluetooth commands.",
    "call_patterns": [
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-hci_rpmsg_cmd_recv(samples/bluetooth/hci_rpmsg/src/main.c)<-hci_rpmsg_rx(samples/bluetooth/hci_rpmsg/src/main.c)<-endpoint_cb(samples/bluetooth/hci_rpmsg/src/main.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_tx (version: v2.7.1)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-bt_tx_thread(samples/bluetooth/hci_spi/src/main.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_tx (version: v2.7.1)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-rx_isr(samples/bluetooth/hci_uart/src/main.c)<-bt_uart_isr(samples/bluetooth/hci_uart/src/main.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_tx (version: v2.7.1)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-acl_read_cb(subsys/usb/class/bluetooth.c)<-bluetooth_status_cb(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_tx (version: v2.7.1)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-bluetooth_class_handler(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_tx (version: v2.7.1)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-bt_h4_read(subsys/usb/class/bt_h4.c)<-bt_h4_status_cb(subsys/usb/class/bt_h4.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_tx (version: v2.7.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that before adding data to a buffer, you check if the buffer has enough tailroom to accommodate the data. If the buffer does not have sufficient space, handle the error gracefully by unreferencing the buffer and returning an appropriate error code. This prevents buffer overflows and ensures memory safety.",
      "code_snippet": "struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout, const void *data, size_t size) {\n    struct net_buf *buf;\n    buf = net_buf_alloc(pool, timeout);\n    if (!buf) {\n        return buf;\n    }\n    net_buf_reserve(buf, BT_BUF_RESERVE);\n    bt_buf_set_type(buf, type);\n    if (data && size) {\n        if (net_buf_tailroom(buf) < size) {\n            net_buf_unref(buf);\n            return NULL;\n        }\n        net_buf_add_mem(buf, data, size);\n    }\n    return buf;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42167",
      "patch_diff": "if (net_buf_tailroom(buf) < size) {\n    net_buf_unref(buf);\n    return NULL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the requested size for data exceeds the tailroom of the allocated buffer."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bt_buf_get_tx in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2021-3835"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.7.1"
  },
  {
    "id": "VULN-000116",
    "vulnerability": "Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf",
    "affected_functions": [
      "bt_buf_get_cmd_complete"
    ],
    "functionality": "Allocates a transmission buffer for Bluetooth commands.",
    "call_patterns": [
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-hci_rpmsg_cmd_recv(samples/bluetooth/hci_rpmsg/src/main.c)<-hci_rpmsg_rx(samples/bluetooth/hci_rpmsg/src/main.c)<-endpoint_cb(samples/bluetooth/hci_rpmsg/src/main.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_cmd_complete (version: v2.7.99)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-bt_tx_thread(samples/bluetooth/hci_spi/src/main.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_cmd_complete (version: v2.7.99)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-rx_isr(samples/bluetooth/hci_uart/src/main.c)<-bt_uart_isr(samples/bluetooth/hci_uart/src/main.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_cmd_complete (version: v2.7.99)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-acl_read_cb(subsys/usb/class/bluetooth.c)<-bluetooth_status_cb(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_cmd_complete (version: v2.7.99)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-bluetooth_class_handler(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_cmd_complete (version: v2.7.99)"
      },
      {
        "pattern": "bt_buf_get_tx(subsys/bluetooth/host/hci_raw.c)<-bt_h4_read(subsys/usb/class/bt_h4.c)<-bt_h4_status_cb(subsys/usb/class/bt_h4.c)",
        "description": "Vulnerable call chain leading to bt_buf_get_cmd_complete (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that before adding data to a buffer, you check if the buffer has enough tailroom to accommodate the data size. If the buffer does not have sufficient space, handle the error gracefully by unreferencing the buffer and returning an appropriate error code. This prevents buffer overflows and ensures memory safety.",
      "code_snippet": "struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout, const void *data, size_t size) {\n    struct net_buf *buf;\n    buf = net_buf_alloc(pool, timeout);\n    if (!buf) {\n        return buf;\n    }\n    net_buf_reserve(buf, BT_BUF_RESERVE);\n    bt_buf_set_type(buf, type);\n    if (data && size) {\n        if (net_buf_tailroom(buf) < size) {\n            net_buf_unref(buf);\n            return NULL;\n        }\n        net_buf_add_mem(buf, data, size);\n    }\n    return buf;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42093",
      "patch_diff": "diff --git a/subsys/bluetooth/host/hci_raw.c b/subsys/bluetooth/host/hci_raw.c\nindex e3d765bed0299..cb4f0a3fbf7ad 100644\n--- a/subsys/bluetooth/host/hci_raw.c\n+++ b/subsys/bluetooth/host/hci_raw.c\n@@ -159,6 +159,11 @@ struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout,\n     bt_buf_set_type(buf, type);\n \n     if (data && size) {\n+        if (net_buf_tailroom(buf) < size) {\n+            net_buf_unref(buf);\n+            return NULL;\n+        }\n+\n         net_buf_add_mem(buf, data, size);\n     }\n \n     return buf;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the requested size for data exceeds the tailroom of the allocated buffer."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bt_buf_get_cmd_complete in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2021-3835"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000117",
    "vulnerability": "Buffer overflow in usb device class. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-fm6v-8625-99jf",
    "affected_functions": [
      "bluetooth_interface_config"
    ],
    "functionality": "Handles control transfers for Bluetooth USB devices.",
    "call_patterns": [
      {
        "pattern": "bluetooth_class_handler(subsys/usb/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to bluetooth_interface_config (version: v2.7.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42167",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When a control transfer is processed and the data size exceeds the available buffer size."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bluetooth_interface_config in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2021-3835"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.7.1"
  },
  {
    "id": "VULN-000118",
    "vulnerability": "The RNDIS USB device class includes a buffer overflow vulnerability. Zephyr versions >= v2.6.0 contain Heap-based Buffer Overflow (CWE-122). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-hvfp-w4h8-gxvj",
    "affected_functions": [
      "queue_encapsulated_cmd"
    ],
    "functionality": "Handles queuing of RNDIS commands by copying user-provided data into a buffer.",
    "call_patterns": [
      {
        "pattern": "queue_encapsulated_cmd(subsys/usb/class/netusb/function_rndis.c)<-rndis_class_handler(subsys/usb/class/netusb/function_rndis.c)",
        "description": "Vulnerable call chain leading to queue_encapsulated_cmd (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the buffer size used for copying data is validated against the maximum allowed size. Implement checks to prevent buffer overflows by ensuring that the length of the data being copied does not exceed the allocated buffer size. Additionally, consider using safer functions that limit the number of bytes copied based on the buffer size.",
      "code_snippet": "static int queue_encapsulated_cmd(uint8_t *data, uint32_t len) {\n    struct net_buf *buf;\n\n    if (len > CFG_RNDIS_CMD_BUF_SIZE) {\n        LOG_ERR(\"Data length exceeds buffer size\");\n        return -EINVAL;\n    }\n\n    buf = net_buf_alloc(&rndis_cmd_pool, K_NO_WAIT);\n    if (!buf) {\n        LOG_ERR(\"Cannot get free buffer\");\n        return -ENOMEM;\n    }\n\n    memcpy(net_buf_add(buf, len), data, len);\n    net_buf_put(&rndis_cmd_queue, buf);\n\n    LOG_DBG(\"queued buf %p\", buf);\n\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/39725",
      "patch_diff": "diff --git a/subsys/usb/class/netusb/function_rndis.c b/subsys/usb/class/netusb/function_rndis.c\nindex 1cabc3086f757..e032c86265a6f 100644\n--- a/subsys/usb/class/netusb/function_rndis.c\n+++ b/subsys/usb/class/netusb/function_rndis.c\n@@ -32,7 +32,7 @@ static struct k_fifo rndis_tx_queue;\n \n /* Serialize RNDIS command queue for later processing */\n #define CFG_RNDIS_CMD_BUF_COUNT\t2\n-#define CFG_RNDIS_CMD_BUF_SIZE\t512\n+#define CFG_RNDIS_CMD_BUF_SIZE\tCONFIG_USB_REQUEST_BUFFER_SIZE\n static struct k_fifo rndis_cmd_queue;\n \n static int queue_encapsulated_cmd(uint8_t *data, uint32_t len) {\n+    if (len > CFG_RNDIS_CMD_BUF_SIZE) {\n+        LOG_ERR(\"Data length exceeds buffer size\");\n+        return -EINVAL;\n+    }\n    struct net_buf *buf;\n    buf = net_buf_alloc(&rndis_cmd_pool, K_NO_WAIT);\n    if (!buf) {\n        LOG_ERR(\"Cannot get free buffer\");\n        return -ENOMEM;\n    }\n    memcpy(net_buf_add(buf, len), data, len);\n    net_buf_put(&rndis_cmd_queue, buf);\n    LOG_DBG(\"queued buf %p\", buf);\n    return 0;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A control transfer request with a length greater than the allocated buffer size (512 bytes) is sent to the device."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using queue_encapsulated_cmd in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2021-3861"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000119",
    "vulnerability": "Assertion reachable with repeated LL_CONNECTION_PARAM_REQ. Zephyr versions >= v1.14 contain Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-46h3-hjcq-2jjr",
    "affected_functions": [
      "isr_rx_conn_pkt_ctrl"
    ],
    "functionality": "Handles incoming connection packet control for the Bluetooth controller.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that your function properly handles duplicate requests or unexpected states without causing assertions that could lead to denial of service. Instead of asserting, implement logic to gracefully handle the situation, such as ignoring the request or marking it for later processing. Always consider the state of the system and provide appropriate feedback or logging to aid in debugging.",
      "code_snippet": "if (is_busy) {\n    /* Ignore duplicate request as peripheral is busy\n     * processing the previously initiated connection\n     * update request procedure.\n     */\n    /* Mark for buffer for release */\n    (*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;\n} else {\n    LL_ASSERT(0);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33759",
      "patch_diff": "-            LL_ASSERT(0);\n+            /* Ignore duplicate request as peripheral is busy\n+             * processing the previously initiated connection\n+             * update request procedure.\n+             */\n+            /* Mark for buffer for release */\n+            (*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Repeated LL_CONNECTION_PARAM_REQ while the peripheral is busy processing a previous connection update request."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using isr_rx_conn_pkt_ctrl in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2021-3430"
    ],
    "related_cwe": [
      "CWE-617"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000120",
    "vulnerability": "Assertion reachable with repeated LL_CONNECTION_PARAM_REQ. Zephyr versions >= v1.14 contain Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-46h3-hjcq-2jjr",
    "affected_functions": [
      "ctrl_rx"
    ],
    "functionality": "Processes received connection-related packets in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "ctrl_rx(subsys/bluetooth/controller/ll_sw/ull_conn.c)<-ull_conn_rx(subsys/bluetooth/controller/ll_sw/ull_conn.c)",
        "description": "Vulnerable call chain leading to ctrl_rx (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that your function properly handles unexpected or duplicate requests without causing assertions that could lead to denial of service. Instead of asserting, implement logic to gracefully handle the situation, such as marking requests for release or ignoring them if the system is busy. Always consider the state of the system and provide appropriate feedback or handling mechanisms.",
      "code_snippet": "static inline int ctrl_rx(memq_link_t *link, struct node_rx_pdu **rx, struct connection *conn) {\n    if (conn->state == CONNECTION_BUSY) {\n        /* Ignore duplicate request as peripheral is busy\n         * processing the previously initiated connection\n         * update request procedure.\n         */\n        /* Mark for buffer for release */\n        (*rx)->hdr.type = NODE_RX_TYPE_RELEASE;\n    }\n    // Other processing logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33272",
      "patch_diff": "-            LL_ASSERT(0);\n+            /* Ignore duplicate request as peripheral is busy\n+             * processing the previously initiated connection\n+             * update request procedure.\n+             */\n+            /* Mark for buffer for release */\n+            (*rx)->hdr.type = NODE_RX_TYPE_RELEASE;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Repeated LL_CONNECTION_PARAM_REQ while the peripheral is busy processing a previous connection update request."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ctrl_rx in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2021-3430"
    ],
    "related_cwe": [
      "CWE-617"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000121",
    "vulnerability": "Assertion reachable with repeated LL_CONNECTION_PARAM_REQ. Zephyr versions >= v1.14 contain Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-46h3-hjcq-2jjr",
    "affected_functions": [
      "pdu_len_cmp"
    ],
    "functionality": "Processes received connection-related packets in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "pdu_len_cmp(subsys/bluetooth/controller/ll_sw/ull_conn.c)<-ctrl_rx(subsys/bluetooth/controller/ll_sw/ull_conn.c)<-ull_conn_rx(subsys/bluetooth/controller/ll_sw/ull_conn.c)",
        "description": "Vulnerable call chain leading to pdu_len_cmp (version: v1.14.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that your code properly handles unexpected or duplicate requests without crashing. Instead of using assertions that can lead to program termination, implement logic to gracefully handle such cases. This can include ignoring the request, logging a warning, or marking the request for release, depending on the context. Always consider the state of the system and ensure that it can recover or continue functioning correctly.",
      "code_snippet": "if (is_duplicate_request) {\n    /* Ignore duplicate request as peripheral is busy\n     * processing the previously initiated connection\n     * update request procedure.\n     */\n    (*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;\n} else {\n    // Handle valid request\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33759",
      "patch_diff": "LL_ASSERT(0); -> /* Ignore duplicate request as peripheral is busy processing the previously initiated connection update request procedure. */\n(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Repeated LL_CONNECTION_PARAM_REQ while the peripheral is busy processing a previous connection update request."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using pdu_len_cmp in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2021-3430"
    ],
    "related_cwe": [
      "CWE-617"
    ],
    "vulnerable_version": "v1.14.2"
  },
  {
    "id": "VULN-000122",
    "vulnerability": "Assertion reachable with repeated LL_CONNECTION_PARAM_REQ. Zephyr versions >= v1.14 contain Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-46h3-hjcq-2jjr",
    "affected_functions": [
      "force_md_cnt_calc"
    ],
    "functionality": "Processes received connection-related packets in the Bluetooth controller.",
    "call_patterns": [
      {
        "pattern": "ctrl_rx(subsys/bluetooth/controller/ll_sw/ull_conn.c)<-ull_conn_rx(subsys/bluetooth/controller/ll_sw/ull_conn.c)",
        "description": "Vulnerable call chain leading to force_md_cnt_calc (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that your function properly handles unexpected or duplicate requests without causing assertions that could lead to denial of service. Instead of asserting, implement logic to gracefully handle the situation, such as marking requests for release or ignoring them if the system is busy. Always consider the state of the system and provide appropriate feedback or handling mechanisms.",
      "code_snippet": "static inline int ctrl_rx(memq_link_t *link, struct node_rx_pdu **rx, struct connection *conn) {\n    if (conn->state == CONNECTION_BUSY) {\n        /* Ignore duplicate request as peripheral is busy\n         * processing the previously initiated connection\n         * update request procedure.\n         */\n        /* Mark for buffer for release */\n        (*rx)->hdr.type = NODE_RX_TYPE_RELEASE;\n    }\n    // Other processing logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33272",
      "patch_diff": "-            LL_ASSERT(0);\n+            /* Ignore duplicate request as peripheral is busy\n+             * processing the previously initiated connection\n+             * update request procedure.\n+             */\n+            /* Mark for buffer for release */\n+            (*rx)->hdr.type = NODE_RX_TYPE_RELEASE;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Repeated LL_CONNECTION_PARAM_REQ while the peripheral is busy processing a previous connection update request."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using force_md_cnt_calc in vulnerable versions (v1.14.2 → v1.14.3)"
    ],
    "related_cve": [
      "CVE-2021-3430"
    ],
    "related_cwe": [
      "CWE-617"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000123",
    "vulnerability": "Assertion reachable with repeated LL_FEATURE_REQ. Zephyr versions >= v2.5.0 contain Reachable Assertion (CWE-617). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7548-5m6f-mqv9",
    "affected_functions": [
      "ctrl_tx_rsp_mem_acquire"
    ],
    "functionality": "This function checks for transaction violations and acquires a free control transmission PDU.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that handles transactions or requests has a mechanism to prevent duplicate processing. Implement a transaction lock that is set when a request is being processed and reset once the processing is complete. This will prevent assertion failures or unexpected behavior due to repeated requests. Always check the state of the transaction lock before proceeding with the request handling.",
      "code_snippet": "static struct node_tx *ctrl_tx_rsp_mem_acquire(struct ll_conn *conn, struct node_rx_pdu *rx, int *err) {\n    struct node_tx *tx;\n\n    /* Ignore duplicate requests without previous being acknowledged. */\n    if (conn->common.txn_lock) {\n        /* Mark for buffer for release */\n        rx->hdr.type = NODE_RX_TYPE_RELEASE;\n\n        /* Drop request */\n        *err = 0U;\n\n        return NULL;\n    }\n\n    /* Acquire ctrl tx mem */\n    tx = mem_acquire(&mem_conn_tx_ctrl.free);\n    if (!tx) {\n        *err = -ENOBUFS;\n        return NULL;\n    }\n\n    /* Lock further responses to duplicate requests before previous response is acknowledged. */\n    conn->common.txn_lock = 1U;\n\n    return tx;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33340",
      "patch_diff": "conn->common.txn_lock = 0; // Reset the transaction lock\nif (conn->common.txn_lock) { // Check for transaction lock before processing\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability can be triggered when there are duplicate requests without the previous request being acknowledged, leading to an assertion failure."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ctrl_tx_rsp_mem_acquire in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3431"
    ],
    "related_cwe": [
      "CWE-617"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000124",
    "vulnerability": "Invalid interval in CONNECT_IND leads to Division by Zero. Zephyr versions >= v1.14.0 Divide By Zero (CWE-369). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7364-p4wc-8mj4",
    "affected_functions": [
      "ull_slave_setup"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_setup (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in calculations. Specifically, check for invalid or unexpected values that could lead to division by zero or other undefined behavior. Implement early returns for invalid states and ensure that all necessary conditions are checked before proceeding with calculations that depend on those values.",
      "code_snippet": "void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx, ...) {\n    ...\n    lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);\n    if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n        (lll->data_chan_hop > 16) || !lll->interval) {\n        lll->initiated = 0U;\n        ...\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33278",
      "patch_diff": "if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n    (lll->data_chan_hop > 16) || !lll->interval) {\n    lll->initiated = 0U;\n    ...\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An invalid interval in the CONNECT_IND leads to a division by zero."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_setup in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3432"
    ],
    "related_cwe": [
      "CWE-369"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000125",
    "vulnerability": "Invalid interval in CONNECT_IND leads to Division by Zero. Zephyr versions >= v1.14.0 Divide By Zero (CWE-369). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7364-p4wc-8mj4",
    "affected_functions": [
      "ull_slave_ticker_cb"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_ticker_cb (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in calculations. Specifically, check for invalid or unexpected values that could lead to division by zero or other undefined behavior. Implement early returns for invalid states and ensure that all necessary conditions are checked before proceeding with calculations that depend on those values.",
      "code_snippet": "void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx, ...) {\n    ...\n    lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);\n    if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n        (lll->data_chan_hop > 16) || !lll->interval) {\n        lll->initiated = 0U;\n        ...\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33278",
      "patch_diff": "if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n    (lll->data_chan_hop > 16) || !lll->interval) {\n    lll->initiated = 0U;\n    ...\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An invalid interval in the CONNECT_IND leads to a division by zero."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_ticker_cb in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3432"
    ],
    "related_cwe": [
      "CWE-369"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000126",
    "vulnerability": "Invalid interval in CONNECT_IND leads to Division by Zero. Zephyr versions >= v1.14.0 Divide By Zero (CWE-369). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7364-p4wc-8mj4",
    "affected_functions": [
      "ull_slave_latency_cancel"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_latency_cancel (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in calculations. Specifically, check for invalid or unexpected values that could lead to division by zero or other undefined behavior. Implement early returns for invalid states and ensure that all necessary conditions are checked before proceeding with calculations that depend on those values.",
      "code_snippet": "void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx, ...) {\n    ...\n    lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);\n    if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n        (lll->data_chan_hop > 16) || !lll->interval) {\n        lll->initiated = 0U;\n        ...\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33278",
      "patch_diff": "if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n    (lll->data_chan_hop > 16) || !lll->interval) {\n    lll->initiated = 0U;\n    ...\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "An invalid interval in the CONNECT_IND leads to a division by zero."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_latency_cancel in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3432"
    ],
    "related_cwe": [
      "CWE-369"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000127",
    "vulnerability": "Invalid channel map in CONNECT_IND results to Deadlock. Zephyr versions >= v2.5.0 Improper Check or Handling of Exceptional Conditions (CWE-703). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3c2f-w4v6-qxrp",
    "affected_functions": [
      "ull_slave_setup"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_setup (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before processing. Specifically, check for valid ranges and conditions that could lead to deadlocks or invalid states. Implement early returns for invalid conditions and ensure that resources are properly released to avoid memory leaks or deadlocks.",
      "code_snippet": "void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx, ... ) {\n    ...\n    if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n        (lll->data_chan_hop > 16) || !lll->interval) {\n        lll->initiated = 0U;\n        rx->type = NODE_RX_TYPE_RELEASE;\n        if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {\n            struct node_rx_pdu *rx_csa;\n            rx_csa = (void *)ftr->extra;\n            ll_rx_put(link, rx);\n            rx = (void *)rx_csa;\n            link = rx->link;\n            rx->type = NODE_RX_TYPE_RELEASE;\n        }\n        ll_rx_put(link, rx);\n        ll_rx_sched();\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33278",
      "patch_diff": "if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n    (lll->data_chan_hop > 16) || !lll->interval) {\n    lll->initiated = 0U;\n    rx->type = NODE_RX_TYPE_RELEASE;\n    if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {\n        struct node_rx_pdu *rx_csa;\n        rx_csa = (void *)ftr->extra;\n        ll_rx_put(link, rx);\n        rx = (void *)rx_csa;\n        link = rx->link;\n        rx->type = NODE_RX_TYPE_RELEASE;\n    }\n    ll_rx_put(link, rx);\n    ll_rx_sched();\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Invalid channel map or parameters in the CONNECT_IND message, leading to a deadlock."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_setup in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3433"
    ],
    "related_cwe": [
      "CWE-703"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000128",
    "vulnerability": "Invalid channel map in CONNECT_IND results to Deadlock. Zephyr versions >= v2.5.0 Improper Check or Handling of Exceptional Conditions (CWE-703). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3c2f-w4v6-qxrp",
    "affected_functions": [
      "ull_slave_ticker_cb"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_ticker_cb (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before processing. Specifically, check for valid ranges and conditions that could lead to deadlocks or invalid states. Implement early returns for invalid conditions and ensure that resources are properly released to avoid memory leaks or deadlocks.",
      "code_snippet": "void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx, ... ) {\n    ...\n    if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n        (lll->data_chan_hop > 16) || !lll->interval) {\n        lll->initiated = 0U;\n        rx->type = NODE_RX_TYPE_RELEASE;\n        if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {\n            struct node_rx_pdu *rx_csa;\n            rx_csa = (void *)ftr->extra;\n            ll_rx_put(link, rx);\n            rx = (void *)rx_csa;\n            link = rx->link;\n            rx->type = NODE_RX_TYPE_RELEASE;\n        }\n        ll_rx_put(link, rx);\n        ll_rx_sched();\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33278",
      "patch_diff": "if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n    (lll->data_chan_hop > 16) || !lll->interval) {\n    lll->initiated = 0U;\n    rx->type = NODE_RX_TYPE_RELEASE;\n    if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {\n        struct node_rx_pdu *rx_csa;\n        rx_csa = (void *)ftr->extra;\n        ll_rx_put(link, rx);\n        rx = (void *)rx_csa;\n        link = rx->link;\n        rx->type = NODE_RX_TYPE_RELEASE;\n    }\n    ll_rx_put(link, rx);\n    ll_rx_sched();\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Invalid channel map or parameters in the CONNECT_IND message, leading to a deadlock."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_ticker_cb in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3433"
    ],
    "related_cwe": [
      "CWE-703"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000129",
    "vulnerability": "Invalid channel map in CONNECT_IND results to Deadlock. Zephyr versions >= v2.5.0 Improper Check or Handling of Exceptional Conditions (CWE-703). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-3c2f-w4v6-qxrp",
    "affected_functions": [
      "ull_slave_latency_cancel"
    ],
    "functionality": "Sets up the slave connection parameters for Bluetooth communication.",
    "call_patterns": [
      {
        "pattern": "ull_slave_setup(subsys/bluetooth/controller/ll_sw/ull_slave.c)",
        "description": "Vulnerable call chain leading to ull_slave_latency_cancel (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before processing. Specifically, check for valid ranges and conditions that could lead to deadlocks or invalid states. Implement early returns for invalid conditions and ensure that resources are properly released to avoid memory leaks or deadlocks.",
      "code_snippet": "void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx, ... ) {\n    ...\n    if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n        (lll->data_chan_hop > 16) || !lll->interval) {\n        lll->initiated = 0U;\n        rx->type = NODE_RX_TYPE_RELEASE;\n        if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {\n            struct node_rx_pdu *rx_csa;\n            rx_csa = (void *)ftr->extra;\n            ll_rx_put(link, rx);\n            rx = (void *)rx_csa;\n            link = rx->link;\n            rx->type = NODE_RX_TYPE_RELEASE;\n        }\n        ll_rx_put(link, rx);\n        ll_rx_sched();\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33278",
      "patch_diff": "if ((lll->data_chan_count < 2) || (lll->data_chan_hop < 5) ||\n    (lll->data_chan_hop > 16) || !lll->interval) {\n    lll->initiated = 0U;\n    rx->type = NODE_RX_TYPE_RELEASE;\n    if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {\n        struct node_rx_pdu *rx_csa;\n        rx_csa = (void *)ftr->extra;\n        ll_rx_put(link, rx);\n        rx = (void *)rx_csa;\n        link = rx->link;\n        rx->type = NODE_RX_TYPE_RELEASE;\n    }\n    ll_rx_put(link, rx);\n    ll_rx_sched();\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Invalid channel map or parameters in the CONNECT_IND message, leading to a deadlock."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ull_slave_latency_cancel in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3433"
    ],
    "related_cwe": [
      "CWE-703"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000130",
    "vulnerability": "Stack based buffer overflow in le_ecred_conn_req(). Zephyr versions >= v2.5.0 Stack-based Buffer Overflow (CWE-121). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-8w87-6rfp-cfrm",
    "affected_functions": [
      "le_ecred_conn_req"
    ],
    "functionality": "Handles LE credit-based connection requests in the L2CAP layer of Bluetooth.",
    "call_patterns": [
      {
        "pattern": "le_ecred_conn_req(subsys/bluetooth/host/l2cap.c)",
        "description": "Vulnerable call chain leading to le_ecred_conn_req (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that you validate the size of incoming buffers before processing them. Check the length of the buffer against expected sizes and handle cases where the buffer is too large or too small. Use appropriate error handling to prevent buffer overflows and ensure that all memory accesses are safe. Additionally, initialize variables to prevent using uninitialized memory.",
      "code_snippet": "static void le_ecred_conn_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf) {\n    struct bt_l2cap_le_ecred_conn_req *req;\n    uint16_t psm, mtu, mps;\n    uint16_t dcid[BT_L2CAP_LE_MAX_CHANNELS];\n    size_t i = 0;\n\n    if (buf->len < sizeof(*req)) {\n        return;\n    }\n\n    req = net_buf_pull_mem(buf, sizeof(*req));\n\n    if (buf->len > sizeof(dcid)) {\n        BT_ERR(\"Too large LE conn req packet size\");\n        result = BT_L2CAP_LE_ERR_INVALID_PARAMS;\n        goto response;\n    }\n\n    psm = sys_le16_to_cpu(req->psm);\n    mtu = sys_le16_to_cpu(req->mtu);\n    mps = sys_le16_to_cpu(req->mps);\n\n    memset(dcid, 0, sizeof(dcid));\n\n    while (buf->len >= sizeof(scid)) {\n        scid = net_buf_pull_le16(buf);\n        dcid[i++] = sys_cpu_to_le16(ch->rx.cid);\n        continue;\n    }\n\nresponse:\n    buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_ECRED_CONN_RSP, ident, sizeof(*rsp) + (sizeof(scid) * i));\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33305",
      "patch_diff": "if (buf->len > sizeof(dcid)) {\n    BT_ERR(\"Too large LE conn req packet size\");\n    result = BT_L2CAP_LE_ERR_INVALID_PARAMS;\n    goto response;\n}\n\nmemset(dcid, 0, sizeof(dcid));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the incoming buffer exceeds the size of the destination CID, leading to a stack-based buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using le_ecred_conn_req in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3434"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000131",
    "vulnerability": "Information leakage in le_ecred_conn_req(). Zephyr versions >= v2.4.0 Use of Uninitialized Resource (CWE-908). For more information, see https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-xhg3-gvj6-4rqh",
    "affected_functions": [
      "le_ecred_conn_req"
    ],
    "functionality": "Handles LE credit-based connection requests in the L2CAP layer of Bluetooth.",
    "call_patterns": [
      {
        "pattern": "le_ecred_conn_req(subsys/bluetooth/host/l2cap.c)",
        "description": "Vulnerable call chain leading to le_ecred_conn_req (version: v2.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that you validate the size of incoming buffers before processing them. Implement checks to prevent information leakage by ensuring that sensitive data is not exposed through improper handling of buffer lengths. Always initialize buffers to prevent uninitialized memory access and ensure that error handling is robust to avoid unintended behavior.",
      "code_snippet": "static void le_ecred_conn_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf) {\n    struct bt_l2cap_le_ecred_conn_req *req;\n    uint16_t psm, mtu, mps;\n    uint16_t dcid[BT_L2CAP_LE_MAX_CID];\n    size_t i = 0;\n\n    if (buf->len < sizeof(*req)) {\n        return;\n    }\n\n    req = net_buf_pull_mem(buf, sizeof(*req));\n\n    if (buf->len > sizeof(dcid)) {\n        BT_ERR(\"Too large LE conn req packet size\");\n        result = BT_L2CAP_LE_ERR_INVALID_PARAMS;\n        goto response;\n    }\n\n    psm = sys_le16_to_cpu(req->psm);\n    mtu = sys_le16_to_cpu(req->mtu);\n    mps = sys_le16_to_cpu(req->mps);\n\n    memset(dcid, 0, sizeof(dcid));\n\n    while (buf->len >= sizeof(scid)) {\n        scid = net_buf_pull_le16(buf);\n        dcid[i++] = sys_cpu_to_le16(ch->rx.cid);\n    }\n\nresponse:\n    buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_ECRED_CONN_RSP, ident,\n                                  sizeof(*rsp) + (sizeof(scid) * i));\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/33305",
      "patch_diff": "if (buf->len > sizeof(dcid)) {\n    BT_ERR(\"Too large LE conn req packet size\");\n    result = BT_L2CAP_LE_ERR_INVALID_PARAMS;\n    goto response;\n}\n\nmemset(dcid, 0, sizeof(dcid));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the LE connection request packet exceeds the expected size, leading to potential information leakage."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using le_ecred_conn_req in vulnerable versions (v2.5.0 → v2.6.0)"
    ],
    "related_cve": [
      "CVE-2021-3435"
    ],
    "related_cwe": [
      "CWE-908"
    ],
    "vulnerable_version": "v2.5.0"
  },
  {
    "id": "VULN-000132",
    "vulnerability": "In Zephyr bluetooth mesh core stack, an out-of-bound write vulnerability can be triggered during provisioning.",
    "affected_functions": [
      "gen_prov_start"
    ],
    "functionality": "This function handles the start of the provisioning process in the Bluetooth mesh core stack.",
    "call_patterns": [
      {
        "pattern": "gen_prov_start(subsys/bluetooth/mesh/pb_adv.c)",
        "description": "Vulnerable call chain leading to gen_prov_start (version: v2.7.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated against expected constraints before processing. Specifically, check for mismatched values that could lead to out-of-bounds writes. In the context of the call chain, validate the SegN against the calculated last segment based on the TotalLength to prevent invalid states.",
      "code_snippet": "static void gen_prov_start(struct prov_rx *rx, struct net_buf_simple *buf) {\n\tif (rx->gpc == NULL || buf == NULL) {\n\t\treturn;\n\t}\n\n\tif (START_LAST_SEG(rx->gpc) != last_seg(link.rx.buf->len)) {\n\t\tBT_ERR(\"Invalid SegN (%u, calculated %u)\", START_LAST_SEG(rx->gpc),\n\t\t\tlast_seg(link.rx.buf->len));\n\t\tprov_failed(PROV_ERR_NVAL_FMT);\n\t\treturn;\n\t}\n\n\tprov_clear_tx();\n\n\tlink.rx.last_seg = START_LAST_SEG(rx->gpc);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/45187",
      "patch_diff": "if (START_LAST_SEG(rx->gpc) != last_seg(link.rx.buf->len)) {\n\t\tBT_ERR(\"Invalid SegN (%u, calculated %u)\", START_LAST_SEG(rx->gpc),\n\t\t\tlast_seg(link.rx.buf->len));\n\t\tprov_failed(PROV_ERR_NVAL_FMT);\n\t\treturn;\n\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Sending a malformed Transaction Start PDU with legal TotalLength and an oversized SegN."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using gen_prov_start in vulnerable versions (v3.0.0 → v3.1.0)"
    ],
    "related_cve": [
      "CVE-2022-1041"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.2"
  },
  {
    "id": "VULN-000133",
    "vulnerability": "In Zephyr bluetooth mesh core stack, an out-of-bound write vulnerability can be triggered during provisioning.",
    "affected_functions": [
      "gen_prov_cont"
    ],
    "functionality": "Handles the continuation of provisioning in the Bluetooth mesh core stack.",
    "call_patterns": [
      {
        "pattern": "gen_prov_cont(subsys/bluetooth/mesh/pb_adv.c)",
        "description": "Vulnerable call chain leading to gen_prov_cont (version: v2.7.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any data being written to a buffer is validated against the buffer's maximum size before performing the write operation. Implement checks to prevent out-of-bounds writes, especially when dealing with data segments that can be influenced by external inputs. Always validate the segment indices and their corresponding offsets to ensure they do not exceed the allocated buffer size.",
      "code_snippet": "static void gen_prov_cont(struct prov_rx *rx, struct net_buf_simple *buf) {\n\tif (seg > 63) {\n\t\treturn;\n\t}\n\n\tif (XACT_SEG_OFFSET(seg) + buf->len > RX_BUFFER_MAX) {\n\t\tBT_WARN(\"Rx buffer overflow. Malformed generic prov frame?\");\n\t\treturn;\n\t}\n\n\tmemcpy(XACT_SEG_DATA(seg), buf->data, buf->len);\n\tXACT_SEG_RECV(seg);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/45134",
      "patch_diff": "if (XACT_SEG_OFFSET(seg) + buf->len > RX_BUFFER_MAX) {\n\t\tBT_WARN(\"Rx buffer overflow. Malformed generic prov frame?\");\n\t\treturn;\n\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Receiving a Transaction Continue PDU before a Transaction Start PDU, with SegO greater than 2."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using gen_prov_cont in vulnerable versions (v3.0.0 → v3.1.0)"
    ],
    "related_cve": [
      "CVE-2022-1042"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.2"
  },
  {
    "id": "VULN-000134",
    "vulnerability": "In subsys/net/ip/tcp.c , function tcp_flags , when the incoming parameter flags is ECN or CWR , the buf will out-of-bounds write a byte zero.",
    "affected_functions": [
      "tcp_flags"
    ],
    "functionality": "The function tcp_flags parses TCP header flags and formats them into a string.",
    "call_patterns": [
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_send_process(subsys/net/ip/tcp.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-tcp_recv(subsys/net/ip/tcp.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-execute_upload(samples/net/zperf/src/zperf_shell.c)<-shell_cmd_upload(samples/net/zperf/src/zperf_shell.c)<-cmd_tcp_upload(samples/net/zperf/src/zperf_shell.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-execute_upload(samples/net/zperf/src/zperf_shell.c)<-shell_cmd_upload(samples/net/zperf/src/zperf_shell.c)<-cmd_udp_upload(samples/net/zperf/src/zperf_shell.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-execute_upload(samples/net/zperf/src/zperf_shell.c)<-shell_cmd_upload2(samples/net/zperf/src/zperf_shell.c)<-cmd_tcp_upload2(samples/net/zperf/src/zperf_shell.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-execute_upload(samples/net/zperf/src/zperf_shell.c)<-shell_cmd_upload2(samples/net/zperf/src/zperf_shell.c)<-cmd_udp_upload2(samples/net/zperf/src/zperf_shell.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-do_net_init(subsys/logging/log_backend_net.c)<-send_output(subsys/logging/log_backend_net.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-do_net_init(subsys/logging/log_backend_net.c)<-process(subsys/logging/log_backend_net.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-do_net_init(subsys/logging/log_backend_net.c)<-sync_string(subsys/logging/log_backend_net.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-zsock_connect_ctx(subsys/net/lib/sockets/sockets.c)<-sock_connect_vmeth(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_out(subsys/net/ip/tcp.c)<-tcp_data_received(subsys/net/ip/tcp.c)<-tcp_in(subsys/net/ip/tcp.c)<-net_tcp_connect(subsys/net/ip/tcp.c)<-net_context_connect(subsys/net/ip/net_context.c)<-net_socks5_connect(subsys/net/lib/socks/socks.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-tcp_received(samples/bluetooth/ipsp/src/main.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-line_out(subsys/logging/log_backend_net.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-zsock_sendto_ctx(subsys/net/lib/sockets/sockets.c)<-sock_write_vmeth(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-zsock_sendto_ctx(subsys/net/lib/sockets/sockets.c)<-sock_sendto_vmeth(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-telnet_command_send_reply(subsys/shell/backends/shell_telnet.c)<-telnet_reply_ay_command(subsys/shell/backends/shell_telnet.c)<-telnet_reply_command(subsys/shell/backends/shell_telnet.c)<-telnet_handle_command(subsys/shell/backends/shell_telnet.c)<-telnet_recv(subsys/shell/backends/shell_telnet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-telnet_send(subsys/shell/backends/shell_telnet.c)<-telnet_send_prematurely(subsys/shell/backends/shell_telnet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_send(subsys/net/ip/net_context.c)<-telnet_send(subsys/shell/backends/shell_telnet.c)<-write(subsys/shell/backends/shell_telnet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendmsg(subsys/net/ip/net_context.c)<-zsock_sendmsg_ctx(subsys/net/lib/sockets/sockets.c)<-sock_sendmsg_vmeth(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendmsg(subsys/net/ip/net_context.c)<-zpacket_sendmsg_ctx(subsys/net/lib/sockets/sockets_packet.c)<-packet_sock_sendmsg_vmeth(subsys/net/lib/sockets/sockets_packet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-udp_received(samples/bluetooth/ipsp/src/main.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-zperf_receiver_send_stat(samples/net/zperf/src/zperf_udp_receiver.c)<-udp_received(samples/net/zperf/src/zperf_udp_receiver.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-send_response(subsys/net/lib/dns/llmnr_responder.c)<-dns_read(subsys/net/lib/dns/llmnr_responder.c)<-recv_cb(subsys/net/lib/dns/llmnr_responder.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-send_response(subsys/net/lib/dns/mdns_responder.c)<-dns_read(subsys/net/lib/dns/mdns_responder.c)<-recv_cb(subsys/net/lib/dns/mdns_responder.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-dns_write(subsys/net/lib/dns/resolve.c)<-cb_recv(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-dns_write(subsys/net/lib/dns/resolve.c)<-dns_resolve_name(subsys/net/lib/dns/resolve.c)<-dns_get_addr_info(include/net/dns_resolve.h)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-zcan_sendto_ctx(subsys/net/lib/sockets/sockets_can.c)<-can_sock_write_vmeth(subsys/net/lib/sockets/sockets_can.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-zcan_sendto_ctx(subsys/net/lib/sockets/sockets_can.c)<-can_sock_sendto_vmeth(subsys/net/lib/sockets/sockets_can.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-zpacket_sendto_ctx(subsys/net/lib/sockets/sockets_packet.c)<-packet_sock_write_vmeth(subsys/net/lib/sockets/sockets_packet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_send_queued_data(subsys/net/ip/tcp.c)<-net_tcp_queue_data(subsys/net/ip/tcp.c)<-context_sendto(subsys/net/ip/net_context.c)<-net_context_sendto(subsys/net/ip/net_context.c)<-zpacket_sendto_ctx(subsys/net/lib/sockets/sockets_packet.c)<-packet_sock_sendto_vmeth(subsys/net/lib/sockets/sockets_packet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-tcp_send_data(subsys/net/ip/tcp.c)<-tcp_resend_data(subsys/net/ip/tcp.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-listen(samples/bluetooth/ipsp/src/main.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-capture_cleanup(subsys/net/lib/capture/capture.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-dns_resolve_close_locked(subsys/net/lib/dns/resolve.c)<-dns_resolve_close(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-dns_resolve_close_locked(subsys/net/lib/dns/resolve.c)<-dns_resolve_reconfigure(subsys/net/lib/dns/resolve.c)<-esp_dns_work(drivers/wifi/esp_at/esp.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-zsock_flush_queue(subsys/net/lib/sockets/sockets.c)<-zsock_close_ctx(subsys/net/lib/sockets/sockets.c)<-sock_close_vmeth(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-zsock_flush_queue(subsys/net/lib/sockets/sockets.c)<-zsock_close_ctx(subsys/net/lib/sockets/sockets.c)<-packet_sock_close_vmeth(subsys/net/lib/sockets/sockets_packet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-zsock_flush_queue(subsys/net/lib/sockets/sockets.c)<-zsock_accept_ctx(subsys/net/lib/sockets/sockets.c)<-sock_accept_vmeth(subsys/net/lib/sockets/sockets.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-telnet_end_client_connection(subsys/shell/backends/shell_telnet.c)<-telnet_sent_cb(subsys/shell/backends/shell_telnet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-telnet_accept(subsys/shell/backends/shell_telnet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_send(subsys/net/ip/tcp.c)<-tcp_send_process_no_lock(subsys/net/ip/tcp.c)<-tcp_out_ext(subsys/net/ip/tcp.c)<-net_tcp_put(subsys/net/ip/tcp.c)<-net_context_put(subsys/net/ip/net_context.c)<-telnet_setup_server(subsys/shell/backends/shell_telnet.c)<-telnet_init(subsys/shell/backends/shell_telnet.c)<-init(subsys/shell/backends/shell_telnet.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_conn_state(subsys/net/ip/tcp.c)<-tcp_timewait_timeout(subsys/net/ip/tcp.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      },
      {
        "pattern": "tcp_flags(subsys/net/ip/tcp.c)<-tcp_th(subsys/net/ip/tcp.c)<-tcp_conn_state(subsys/net/ip/tcp.c)<-tcp_establish_timeout(subsys/net/ip/tcp.c)<-tcp_fin_timeout(subsys/net/ip/tcp.c)",
        "description": "Vulnerable call chain leading to tcp_flags (version: v3.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When handling incoming parameters in functions that manipulate buffers, always validate the parameters before performing operations that could lead to out-of-bounds writes. Specifically, check the length of the buffer and ensure it is greater than zero before attempting to access or modify its contents. This is crucial in functions that parse data from external sources, such as network packets, to prevent vulnerabilities like buffer overflows or stack corruption.",
      "code_snippet": "static const char *tcp_flags(uint8_t flags) {\n    // ... existing code ...\n    if (len > 0) {\n        buf[len - 1] = '\\0'; /* delete the last comma */\n    }\n    // ... existing code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/45796",
      "patch_diff": "@@ -238,7 +238,9 @@ static const char *tcp_flags(uint8_t flags)\n \t\tlen += snprintk(buf + len, BUF_SIZE - len, \"URG,\");\n \t}\n \n- \tbuf[len - 1] = '\\0'; /* delete the last comma */\n+ \tif (len > 0) {\n+ \t\tbuf[len - 1] = '\\0'; /* delete the last comma */\n+ \t}\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when a malformed TCP packet is received with the th_flags field set to ECN or CWR."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using tcp_flags in vulnerable versions (v3.0.0 → v3.1.0)"
    ],
    "related_cve": [
      "CVE-2022-1841"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.0.0"
  },
  {
    "id": "VULN-000135",
    "vulnerability": "The denial-of-service can be triggered by transmitting a carefully crafted CAN frame on the same CAN network as the vulnerable node. The frame must have a CAN ID matching an installed filter in the vulnerable node (this can easily be guessed based on CAN traffic analyses). The frame must contain the opposite RTR bit as what the filter installed in the vulnerable node contains (if the filter matches RTR frames, the frame must be a data frame or vice versa).",
    "affected_functions": [
      "can_mcan_get_message"
    ],
    "functionality": "This function retrieves messages from the CAN hardware FIFO and processes them based on installed filters.",
    "call_patterns": [
      {
        "pattern": "can_mcan_line_1_isr(drivers/can/can_mcan.c)<-can_stm32fd_line_1_isr(drivers/can/can_stm32fd.c)",
        "description": "Vulnerable call chain leading to can_mcan_get_message (version: v2.7.2)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the filter matching logic correctly handles the RTR (Remote Transmission Request) bit. Implement checks to drop frames when the RTR bit does not match the expected value based on the filter configuration. This should be done in the interrupt service routine or any function that processes incoming CAN frames to prevent endless loops caused by unacknowledged frames.",
      "code_snippet": "if (hdr.xtd != 0) {\n    rtr_filter_mask = (data->ext_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->ext_filt_rtr & BIT(filt_idx)) != 0;\n} else {\n    rtr_filter_mask = (data->std_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->std_filt_rtr & BIT(filt_idx)) != 0;\n}\n\nif (rtr_filter_mask && (rtr_filter != frame.rtr)) {\n    /* RTR bit does not match filter RTR mask and bit, drop frame */\n    *fifo_ack_reg = get_idx;\n    continue;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/47959",
      "patch_diff": "if (hdr.xtd != 0) {\n    rtr_filter_mask = (data->ext_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->ext_filt_rtr & BIT(filt_idx)) != 0;\n} else {\n    rtr_filter_mask = (data->std_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->std_filt_rtr & BIT(filt_idx)) != 0;\n}\n\nif (rtr_filter_mask && (rtr_filter != frame.rtr)) {\n    /* RTR bit does not match filter RTR mask and bit, drop frame */\n    *fifo_ack_reg = get_idx;\n    continue;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Transmitting a carefully crafted CAN frame with a matching CAN ID and opposite RTR bit on the same CAN network."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_mcan_get_message in vulnerable versions (v3.1.0 → v3.2.0)"
    ],
    "related_cve": [
      "CVE-2022-2741"
    ],
    "related_cwe": [
      "CWE-400"
    ],
    "vulnerable_version": "v2.7.2"
  },
  {
    "id": "VULN-000136",
    "vulnerability": "The denial-of-service can be triggered by transmitting a carefully crafted CAN frame on the same CAN network as the vulnerable node. The frame must have a CAN ID matching an installed filter in the vulnerable node (this can easily be guessed based on CAN traffic analyses). The frame must contain the opposite RTR bit as what the filter installed in the vulnerable node contains (if the filter matches RTR frames, the frame must be a data frame or vice versa).",
    "affected_functions": [
      "can_mcan_line_1_isr"
    ],
    "functionality": "This function retrieves messages from the CAN hardware FIFO and processes them based on installed filters.",
    "call_patterns": [
      {
        "pattern": "can_mcan_line_1_isr(drivers/can/can_mcan.c)",
        "description": "Vulnerable call chain leading to can_mcan_line_1_isr (version: v3.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that the filtering logic for CAN frames correctly checks both the identifier and the RTR (Remote Transmission Request) bit. Implement checks that drop frames when the RTR bit does not match the expected value based on the filter configuration. This prevents denial-of-service attacks by ensuring that improperly crafted frames do not cause the system to enter an endless loop.",
      "code_snippet": "if (hdr.xtd != 0) {\n    rtr_filter_mask = (data->ext_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->ext_filt_rtr & BIT(filt_idx)) != 0;\n} else {\n    rtr_filter_mask = (data->std_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->std_filt_rtr & BIT(filt_idx)) != 0;\n}\n\nif (rtr_filter_mask && (rtr_filter != frame.rtr)) {\n    /* RTR bit does not match filter RTR mask and bit, drop frame */\n    *fifo_ack_reg = get_idx;\n    continue;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/47903",
      "patch_diff": "if (hdr.xtd != 0) {\n    rtr_filter_mask = (data->ext_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->ext_filt_rtr & BIT(filt_idx)) != 0;\n} else {\n    rtr_filter_mask = (data->std_filt_rtr_mask & BIT(filt_idx)) != 0;\n    rtr_filter = (data->std_filt_rtr & BIT(filt_idx)) != 0;\n}\n\nif (rtr_filter_mask && (rtr_filter != frame.rtr)) {\n    /* RTR bit does not match filter RTR mask and bit, drop frame */\n    *fifo_ack_reg = get_idx;\n    continue;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "Transmitting a carefully crafted CAN frame with a matching CAN ID and opposite RTR bit on the same CAN network."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_mcan_line_1_isr in vulnerable versions (v3.1.0 → v3.2.0)"
    ],
    "related_cve": [
      "CVE-2022-2741"
    ],
    "related_cwe": [
      "CWE-400"
    ],
    "vulnerable_version": "v3.1.0"
  },
  {
    "id": "VULN-000137",
    "vulnerability": "There is no check to see if slot 0 is being uploaded from the device to the host. When using encrypted images this means the unencrypted firmware can be retrieved easily.",
    "affected_functions": [
      "dfu_class_handle_to_host"
    ],
    "functionality": "Handles the DFU upload process from the device to the host.",
    "call_patterns": [
      {
        "pattern": "dfu_class_handle_to_host(subsys/usb/class/dfu/usb_dfu.c)<-dfu_class_handle_req(subsys/usb/class/dfu/usb_dfu.c)",
        "description": "Vulnerable call chain leading to dfu_class_handle_to_host (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function handling sensitive operations, such as firmware uploads, includes checks to validate whether the operation is permitted based on the configuration. Specifically, check if the upload feature is enabled before proceeding with the upload logic. Additionally, provide clear warnings or errors if the operation is not allowed, and ensure that the function's behavior is consistent with the security policies defined in the configuration.",
      "code_snippet": "static int dfu_class_handle_to_host(struct usb_setup_packet *setup, struct dfu_data_t *dfu_data) {\n    LOG_DBG(\"DFU_UPLOAD block %d, len %d, state %d\", setup->wValue, setup->wLength, dfu_data.state);\n\n    if (!IS_ENABLED(CONFIG_USB_DFU_ENABLE_UPLOAD)) {\n        LOG_WRN(\"Firmware uploading is not enabled\");\n        dfu_data.status = errSTALLEDPKT;\n        dfu_data.state = dfuERROR;\n        return -ENOTSUP;\n    }\n\n    if (dfu_check_app_state()) {\n        return -EINVAL;\n    }\n    // Additional upload handling logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42424",
      "patch_diff": "diff --git a/subsys/usb/class/dfu/usb_dfu.c b/subsys/usb/class/dfu/usb_dfu.c\nindex 4c5bb4cf4b942..2f0ce006ddc1b 100644\n--- a/subsys/usb/class/dfu/usb_dfu.c\n+++ b/subsys/usb/class/dfu/usb_dfu.c\n@@ -427,6 +432,13 @@ static int dfu_class_handle_to_host(struct usb_setup_packet *setup,\n \n+        if (!IS_ENABLED(CONFIG_USB_DFU_ENABLE_UPLOAD)) {\n+            LOG_WRN(\"Firmware uploading is not enabled\");\n+            dfu_data.status = errSTALLEDPKT;\n+            dfu_data.state = dfuERROR;\n+            return -ENOTSUP;\n+        }\n+\n         if (dfu_check_app_state()) {\n             return -EINVAL;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called when firmware uploading is enabled, allowing unencrypted firmware to be uploaded."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dfu_class_handle_to_host in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2022-0553"
    ],
    "related_cwe": [
      "CWE-200,CWE-319"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000138",
    "vulnerability": "There is no check to see if slot 0 is being uploaded from the device to the host. When using encrypted images this means the unencrypted firmware can be retrieved easily.",
    "affected_functions": [
      "dfu_class_handle_to_device"
    ],
    "functionality": "Handles the DFU upload process to the device.",
    "call_patterns": [
      {
        "pattern": "dfu_class_handle_to_device(subsys/usb/class/dfu/usb_dfu.c)<-dfu_class_handle_req(subsys/usb/class/dfu/usb_dfu.c)",
        "description": "Vulnerable call chain leading to dfu_class_handle_to_device (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function handling sensitive operations, such as firmware uploads, includes checks to validate the context in which they are invoked. Specifically, check if the operation is allowed based on configuration flags or other security measures. In this case, ensure that firmware uploads are only permitted when explicitly enabled and that appropriate warnings or errors are logged when they are not.",
      "code_snippet": "static int dfu_class_handle_to_device(struct usb_setup_packet *setup, struct usb_dfu_data *dfu_data) {\n    // ... existing code ...\n\n    if (dfu_data.flash_area_id != DOWNLOAD_FLASH_AREA_ID) {\n        dfu_data.status = errWRITE;\n        dfu_data.state = dfuERROR;\n        LOG_ERR(\"This area can not be overwritten\");\n        return -EINVAL;\n    }\n    // ... existing code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42424",
      "patch_diff": "diff --git a/subsys/usb/class/dfu/usb_dfu.c b/subsys/usb/class/dfu/usb_dfu.c\nindex 4c5bb4cf4b942..2f0ce006ddc1b 100644\n--- a/subsys/usb/class/dfu/usb_dfu.c\n+++ b/subsys/usb/class/dfu/usb_dfu.c\n@@ -562,7 +574,7 @@ static int dfu_class_handle_to_device(struct usb_setup_packet *setup,\n \n-            if (dfu_data.flash_area_id != UPLOAD_FLASH_AREA_ID) {\n+            if (dfu_data.flash_area_id != DOWNLOAD_FLASH_AREA_ID) {\n                 dfu_data.status = errWRITE;\n                 dfu_data.state = dfuERROR;\n                 LOG_ERR(\"This area can not be overwritten\");\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called when the flash area ID is incorrectly set, allowing unintended overwriting of firmware."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dfu_class_handle_to_device in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2022-0553"
    ],
    "related_cwe": [
      "CWE-200,CWE-319"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000139",
    "vulnerability": "There is no check to see if slot 0 is being uploaded from the device to the host. When using encrypted images this means the unencrypted firmware can be retrieved easily.",
    "affected_functions": [
      "dfu_work_handler"
    ],
    "functionality": "Handles the work related to DFU operations, including erasing the image bank.",
    "call_patterns": [
      {
        "pattern": "usb_dfu_init(subsys/usb/class/dfu/usb_dfu.c)",
        "description": "Vulnerable call chain leading to dfu_work_handler (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that allows uploading or downloading of sensitive data includes checks to verify whether the operation is permitted based on the current configuration. Specifically, if the function deals with encrypted images, implement checks to prevent unauthorized access to unencrypted data. Additionally, provide clear warnings in the documentation about the security implications of enabling such features.",
      "code_snippet": "static void dfu_work_handler(struct k_work *item) {\n    if (boot_erase_img_bank(DOWNLOAD_FLASH_AREA_ID)) {\n        dfu_data.state = dfuERROR;\n        dfu_data.status = errERASE;\n        break;\n    }\n    // Additional logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42424",
      "patch_diff": "diff --git a/subsys/usb/class/dfu/usb_dfu.c b/subsys/usb/class/dfu/usb_dfu.c\n@@ -100,9 +109,7 @@ USBD_CLASS_DESCR_DEFINE(primary, 0) struct usb_dfu_config dfu_cfg = {\n-    .bmAttributes = DFU_ATTR_CAN_DNLOAD |\n-            DFU_ATTR_CAN_UPLOAD |\n-            DFU_ATTR_MANIFESTATION_TOLERANT,\n+    .bmAttributes = DFU_DESC_ATTRIBUTES,\n    // Additional changes to handle upload checks...\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called when the wrong flash area ID is used, leading to potential data loss."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dfu_work_handler in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2022-0553"
    ],
    "related_cwe": [
      "CWE-200,CWE-319"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000140",
    "vulnerability": "There is no check to see if slot 0 is being uploaded from the device to the host. When using encrypted images this means the unencrypted firmware can be retrieved easily.",
    "affected_functions": [
      "usb_dfu_init"
    ],
    "functionality": "Handles the work related to DFU operations, including erasing the image bank.",
    "call_patterns": [
      {
        "pattern": "usb_dfu_init(subsys/usb/class/dfu/usb_dfu.c)",
        "description": "Vulnerable call chain leading to usb_dfu_init (version: v2.7.99)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that allows uploading or downloading of sensitive data includes checks to verify whether the operation is permitted based on the current configuration. Specifically, if the function deals with encrypted images, implement checks to prevent unauthorized access to unencrypted data. Additionally, provide clear warnings in the documentation about the security implications of enabling such features.",
      "code_snippet": "static void dfu_work_handler(struct k_work *item) {\n    if (boot_erase_img_bank(DOWNLOAD_FLASH_AREA_ID)) {\n        dfu_data.state = dfuERROR;\n        dfu_data.status = errERASE;\n        break;\n    }\n    // Additional logic...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/42424",
      "patch_diff": "diff --git a/subsys/usb/class/dfu/usb_dfu.c b/subsys/usb/class/dfu/usb_dfu.c\n@@ -100,9 +109,7 @@ USBD_CLASS_DESCR_DEFINE(primary, 0) struct usb_dfu_config dfu_cfg = {\n-    .bmAttributes = DFU_ATTR_CAN_DNLOAD |\n-            DFU_ATTR_CAN_UPLOAD |\n-            DFU_ATTR_MANIFESTATION_TOLERANT,\n+    .bmAttributes = DFU_DESC_ATTRIBUTES,\n    // Additional changes to handle upload checks...\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called when the wrong flash area ID is used, leading to potential data loss."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using usb_dfu_init in vulnerable versions (v2.7.99 → v3.0.0)"
    ],
    "related_cve": [
      "CVE-2022-0553"
    ],
    "related_cwe": [
      "CWE-200,CWE-319"
    ],
    "vulnerable_version": "v2.7.99"
  },
  {
    "id": "VULN-000141",
    "vulnerability": "In Bluetooth mesh implementation If provisionee has a public key that is sent OOB then during provisioning it can be sent back and will be accepted by provisionee.",
    "affected_functions": [
      "prov_pub_key"
    ],
    "functionality": "Handles the provisioning of a public key in Bluetooth mesh implementation.",
    "call_patterns": [
      {
        "pattern": "prov_pub_key(subsys/bluetooth/mesh/prov_device.c)",
        "description": "Vulnerable call chain leading to prov_pub_key (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to public key handling in Bluetooth provisioning, ensure to validate the received public key against the expected values. Implement checks to prevent the acceptance of identical public keys from the provisioner and provisionee, which could lead to security issues. Always log errors for identical keys and fail the provisioning process appropriately.",
      "code_snippet": "static void prov_pub_key(const uint8_t *data) {\n\tif (!data) {\n\t\treturn;\n\t}\n\n\tif (!memcmp(bt_mesh_prov->public_key_be,\n\t\t\tbt_mesh_prov_link.conf_inputs.pub_key_provisioner, PDU_LEN_PUB_KEY)) {\n\t\tLOG_ERR(\"Public keys are identical\");\n\t\tprov_fail(PROV_ERR_NVAL_FMT);\n\t\treturn;\n\t}\n\n\t/* No swap needed since user provides public key in big-endian */\n\tmemcpy(bt_mesh_prov_link.conf_inputs.pub_key_device, bt_mesh_prov->public_key_be,\n\t\tPDU_LEN_PUB_KEY);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/59467",
      "patch_diff": "+\tif (!memcmp(bt_mesh_prov->public_key_be,\n+\t\t\tbt_mesh_prov_link.conf_inputs.pub_key_provisioner, PDU_LEN_PUB_KEY)) {\n+\t\tLOG_ERR(\"Public keys are identical\");\n+\t\tprov_fail(PROV_ERR_NVAL_FMT);\n+\t\treturn;\n+\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "If the provisionee has a public key that is sent out-of-band (OOB) and it is identical to the public key of the provisioner."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using prov_pub_key in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4258"
    ],
    "related_cwe": [
      "CWE-684"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000142",
    "vulnerability": "Two potential buffer overflow vulnerabilities at the following locations in the Zephyr eS-WiFi driver source code.",
    "affected_functions": [
      "eswifi_mgmt_iface_status"
    ],
    "functionality": "Updates the status of the WiFi interface.",
    "call_patterns": [
      {
        "pattern": "<global>(drivers/wifi/eswifi/eswifi_core.c)",
        "description": "Vulnerable call chain leading to eswifi_mgmt_iface_status (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63074",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the SSID exceeds 32 characters, leading to an off-by-one buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using eswifi_mgmt_iface_status in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4259"
    ],
    "related_cwe": [
      "CWE-120,CWE-193"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000143",
    "vulnerability": "Two potential buffer overflow vulnerabilities at the following locations in the Zephyr eS-WiFi driver source code.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Updates the status of the WiFi interface.",
    "call_patterns": [
      {
        "pattern": "<global>(drivers/wifi/eswifi/eswifi_core.c)",
        "description": "Vulnerable call chain leading to <global> (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any buffer copying operations are bounded by the size of the destination buffer. Use functions like strncat or strncpy that allow specifying the maximum number of bytes to copy. Always validate the length of the source data against the destination buffer size to prevent buffer overflows. Additionally, consider using safer alternatives or libraries that handle string operations more securely.",
      "code_snippet": "int eswifi_mgmt_iface_status(const struct device *dev, struct wifi_iface_status *status) {\n\tstruct eswifi_dev *eswifi = dev->data;\n\tstruct eswifi_sta *sta = &eswifi->sta;\n\n\t/* Update status */\n\teswifi_status_work(&eswifi->status_work.work);\n\n\tif (!sta->connected) {\n\t\tstatus->state = WIFI_STATE_DISCONNECTED;\n\t\treturn 0;\n\t}\n\n\tstatus->state = WIFI_STATE_COMPLETED;\n\tstatus->ssid_len = strnlen(sta->ssid, WIFI_SSID_MAX_LEN);\n\tstrncpy(status->ssid, sta->ssid, status->ssid_len);\n\tstatus->band = WIFI_FREQ_BAND_2_4_GHZ;\n\tstatus->channel = 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63750",
      "patch_diff": "@@ -491,7 +491,7 @@ int eswifi_mgmt_iface_status(const struct device *dev,\n \n \tstatus->state = WIFI_STATE_COMPLETED;\n \tstatus->ssid_len = strnlen(sta->ssid, WIFI_SSID_MAX_LEN);\n- \tstrcpy(status->ssid, sta->ssid); /* VULN: off-by-one (sta->ssid[33] copied over status->ssid[32]) */ \n+ \tstrncpy(status->ssid, sta->ssid, status->ssid_len);\n \tstatus->band = WIFI_FREQ_BAND_2_4_GHZ;\n \tstatus->channel = 0;"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the SSID exceeds 32 characters, leading to an off-by-one buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4259"
    ],
    "related_cwe": [
      "CWE-120,CWE-193"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000144",
    "vulnerability": "Two potential buffer overflow vulnerabilities at the following locations in the Zephyr eS-WiFi driver source code.",
    "affected_functions": [
      "eswifi_shell_atcmd"
    ],
    "functionality": "Handles AT commands for the eS-WiFi shell interface.",
    "call_patterns": [
      {
        "pattern": "eswifi_shell_atcmd(drivers/wifi/eswifi/eswifi_shell.c)",
        "description": "Vulnerable call chain leading to eswifi_shell_atcmd (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63074",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the total length of concatenated arguments exceeds the buffer size, causing a static buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using eswifi_shell_atcmd in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4259"
    ],
    "related_cwe": [
      "CWE-120,CWE-193"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000145",
    "vulnerability": "Two potential buffer overflow vulnerabilities at the following locations in the Zephyr eS-WiFi driver source code.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Handles AT commands for the eS-WiFi shell interface.",
    "call_patterns": [
      {
        "pattern": "eswifi_shell_atcmd(drivers/wifi/eswifi/eswifi_shell.c)",
        "description": "Vulnerable call chain leading to <global> (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any buffer copying or concatenation operations are bounded by the size of the destination buffer. Use functions like strncat or strncpy that allow specifying the maximum number of bytes to copy. Always validate the length of input data before processing it, and consider using safer alternatives or libraries that handle buffer sizes automatically. Additionally, ensure that the buffer is large enough to accommodate the expected data, including null terminators.",
      "code_snippet": "static int eswifi_shell_atcmd(const struct shell *sh, size_t argc, char **argv) {\n    int i;\n\n    if (eswifi == NULL) {\n        shell_print(sh, \"no eswifi device registered\");\n        return -ENOEXEC;\n    }\n\n    if (argc < 2) {\n        shell_help(sh);\n        return -ENOEXEC;\n    }\n\n    eswifi_lock(eswifi);\n\n    memset(eswifi->buf, 0, sizeof(eswifi->buf));\n    for (i = 1; i < argc; i++) {\n        strncat(eswifi->buf, argv[i], sizeof(eswifi->buf) - strlen(eswifi->buf) - 1);\n    }\n    strncat(eswifi->buf, \"\\r\", sizeof(eswifi->buf) - strlen(eswifi->buf) - 1);\n\n    shell_print(sh, \"> %s\", eswifi->buf);\n    eswifi_at_cmd(eswifi, eswifi->buf);\n    shell_print(sh, \"< %s\", eswifi->buf);\n\n    eswifi_unlock(eswifi);\n\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63750",
      "patch_diff": "for (i = 1; i < argc; i++) {\n    strncat(eswifi->buf, argv[i], sizeof(eswifi->buf) - strlen(eswifi->buf) - 1);\n}\nstrncat(eswifi->buf, \"\\r\", sizeof(eswifi->buf) - strlen(eswifi->buf) - 1);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the total length of concatenated arguments exceeds the buffer size, causing a static buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4259"
    ],
    "related_cwe": [
      "CWE-120,CWE-193"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000146",
    "vulnerability": "Potential off-by-one buffer overflow vulnerability in the Zephyr fuse file system.",
    "affected_functions": [
      "fuse_fs_access_readdir"
    ],
    "functionality": "This function reads directory entries from a FUSE filesystem.",
    "call_patterns": [
      {
        "pattern": "fuse_fs_access_create(subsys/fs/fuse_fs_access.c)<-fuse_fs_access_open(subsys/fs/fuse_fs_access.c)",
        "description": "Vulnerable call chain leading to fuse_fs_access_readdir (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63079",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when the 'path' parameter is PATH_MAX characters long, including the NUL terminator."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fuse_fs_access_readdir in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4260"
    ],
    "related_cwe": [
      "CWE-120,CWE-193"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000147",
    "vulnerability": "Potential off-by-one buffer overflow vulnerability in the Zephyr fuse file system.",
    "affected_functions": [
      "fuse_fs_access_create"
    ],
    "functionality": "This function reads directory entries from a FUSE filesystem.",
    "call_patterns": [
      {
        "pattern": "fuse_fs_access_create(subsys/fs/fuse_fs_access.c)<-fuse_fs_access_open(subsys/fs/fuse_fs_access.c)",
        "description": "Vulnerable call chain leading to fuse_fs_access_create (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63079",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when the 'path' parameter is PATH_MAX characters long, including the NUL terminator."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using fuse_fs_access_create in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4260"
    ],
    "related_cwe": [
      "CWE-120,CWE-193"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000148",
    "vulnerability": "The SJA1000 CAN controller driver backend automatically attempt to recover from a bus-off event when built with CONFIG_CAN_AUTO_BUS_OFF_RECOVERY=y. This results in calling k_sleep() in IRQ context, causing a fatal exception.",
    "affected_functions": [
      "can_sja1000_leave_reset_mode_nowait"
    ],
    "functionality": "This function leaves the reset mode of the SJA1000 CAN controller without waiting.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "When fixing vulnerabilities related to function calls in IRQ context, ensure that any function invoked does not perform blocking operations such as sleeping. Instead, create a non-blocking version of the function that performs the necessary operations without causing context switches or delays. Review the call chain to identify where the vulnerable function is called and replace it with the non-blocking version in all relevant places.",
      "code_snippet": "static inline void can_sja1000_leave_reset_mode_nowait(const struct device *dev) {\n\tuint8_t mod;\n\tmod = can_sja1000_read_reg(dev, CAN_SJA1000_MOD);\n\tcan_sja1000_write_reg(dev, CAN_SJA1000_MOD, mod & ~(CAN_SJA1000_MOD_RM));\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63713",
      "patch_diff": "@@ -590,7 +598,7 @@ static void can_sja1000_handle_error_warning_irq(const struct device *dev)\n \t\tcan_sja1000_tx_done(dev, -ENETUNREACH);\n #ifdef CONFIG_CAN_AUTO_BUS_OFF_RECOVERY\n \t\tif (data->started) {\n- \t\t\t(void)can_sja1000_leave_reset_mode(dev);\n+ \t\t\tcan_sja1000_leave_reset_mode_nowait(dev);\n \t\t}\n #endif /* CONFIG_CAN_AUTO_BUS_OFF_RECOVERY */"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called in IRQ context when CONFIG_CAN_AUTO_BUS_OFF_RECOVERY is enabled, leading to a fatal exception."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_sja1000_leave_reset_mode_nowait in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5563"
    ],
    "related_cwe": [
      "CWE-703"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000149",
    "vulnerability": "Potential buffer overflow vulnerability in the Zephyr IEEE 802.15.4 nRF 15.4 driver",
    "affected_functions": [
      "nrf5_tx"
    ],
    "functionality": "This function transmits a packet over the IEEE 802.15.4 radio interface.",
    "call_patterns": [
      {
        "pattern": "nrf5_tx(drivers/ieee802154/ieee802154_nrf5.c)",
        "description": "Vulnerable call chain leading to nrf5_tx (version: v2.7.5)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/61216",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when the 'payload_len' exceeds the size of the 'tx_psdu' buffer, leading to a buffer overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using nrf5_tx in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4263"
    ],
    "related_cwe": [
      "CWE-120,CWE-121"
    ],
    "vulnerable_version": "v2.7.5"
  },
  {
    "id": "VULN-000150",
    "vulnerability": "Potential buffer overflow vulnerability in the Zephyr IEEE 802.15.4 nRF 15.4 driver",
    "affected_functions": [
      "static struct ieee802154_radio_api nrf5_radio_api"
    ],
    "functionality": "Prepare and transmits IEEE 802.15.4 frames via nRF5 radio hardware, handling different transmission modes and waiting for completion through semaphore synchronization.",
    "call_patterns": [
      {
        "pattern": "static int nrf5_tx(const struct device *dev,enum ieee802154_tx_mode mode,struct net_pkt *pkt,struct net_buf *frag)(zephyr/drivers/ieee802154/ieee802154_nrf5.c)<-static struct ieee802154_radio_api nrf5_radio_api(zephyr/drivers/ieee802154/ieee802154_nrf5.c)",
        "description": "Vulnerable call chain leading to static struct ieee802154_radio_api nrf5_radio_api (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Validate the length of net_buf parameter does not exceed IEEE802154_MAX_PHY_PACKET_SIZE before calling the public API.",
      "code_snippet": "static struct ieee802154_radio_api *radio_api;\nstatic const struct device *const ieee802154_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_ieee802154));\n\nstatic bool init_ieee802154(void)\n{\n    if (!device_is_ready(ieee802154_dev)) {\n        return false;\n    }\n\n    radio_api = (struct ieee802154_radio_api *)ieee802154_dev->api;\n\n    get_mac(ieee802154_dev);\n\n    if (IEEE802154_HW_FILTER & radio_api->get_capabilities(ieee802154_dev)) {\n        struct ieee802154_filter filter;\n        uint16_t short_addr;\n\n        short_addr = (mac_addr[0] << 8) + mac_addr[1];\n        filter.short_addr = short_addr;\n        radio_api->filter(ieee802154_dev, true, IEEE802154_FILTER_TYPE_SHORT_ADDR, &filter);\n\n        filter.ieee_addr = mac_addr;\n        radio_api->filter(ieee802154_dev, true, IEEE802154_FILTER_TYPE_IEEE_ADDR, &filter);\n\n#ifdef CONFIG_NET_CONFIG_SETTINGS\n        filter.pan_id = CONFIG_NET_CONFIG_IEEE802154_PAN_ID;\n        radio_api->filter(ieee802154_dev, true, IEEE802154_FILTER_TYPE_PAN_ID, &filter);\n#endif\n    }\n\n#ifdef CONFIG_NET_CONFIG_SETTINGS\n    radio_api->set_channel(ieee802154_dev, CONFIG_NET_CONFIG_IEEE802154_CHANNEL);\n#endif\n\n    radio_api->start(ieee802154_dev);\n    return true;\n}\n\nstatic void process_data(struct net_pkt *pkt)\n{\n    struct net_buf *buf = net_buf_frag_last(pkt->buffer);\n    uint8_t seq, num_attr;\n    int ret, i;\n\n    if (buf->len < 2) {\n        send_pkt_report(0, -EINVAL, 0);\n        return;\n    }\n\n    seq = net_buf_pull_u8(buf);\n    num_attr = net_buf_pull_u8(buf);\n\n    if (buf->len < num_attr * 3) {\n        send_pkt_report(seq, -EINVAL, 0);\n        return;\n    }\n\n    for (i = 0; i < num_attr; i++) {\n        net_buf_pull_u8(buf);\n        net_buf_pull_be16(buf);\n    }\n\n    if (buf->len > IEEE802154_MAX_PHY_PACKET_SIZE) {\n        send_pkt_report(seq, -EMSGSIZE, 0);\n        return;\n    }\n\n    ret = radio_api->tx(ieee802154_dev, IEEE802154_TX_MODE_DIRECT, pkt, buf);\n    send_pkt_report(seq, ret, 1);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/60528",
      "patch_diff": "@@ -582,9 +582,14 @@ static int nrf5_tx(const struct device *dev,\n \t\t   enum ieee802154_tx_mode mode,\n \t\t   struct net_pkt *pkt,\n \t\t   struct net_buf *frag)\n {\n \tstruct nrf5_802154_data *nrf5_radio = NRF5_802154_DATA(dev);\n \tuint8_t payload_len = frag->len;\n \tuint8_t *payload = frag->data;\n \tbool ret = true;\n +\n +\tif (payload_len > IEEE802154_MTU) {\n +\t\tLOG_ERR(\"Payload too large: %d\", payload_len);\n +\t\treturn -EMSGSIZE;\n +\t}\n +\n \tLOG_DBG(\"%p (%u)\", payload, payload_len);\n \n \tnrf5_radio->tx_psdu[0] = payload_len + IEEE802154_FCS_LENGTH;\n \tm memcpy(nrf5_radio->tx_psdu + 1, payload, payload_len);\n \n \t/* Reset semaphore in case ACK was received after timeout */\n \tk_sem_reset(&nrf5_radio->tx_wait);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The public API radio_api->tx calls the driver function nrf5_tx, and there is a stack-based buffer overflow vulnerability inside nrf5_tx due to the missing bounds check on the length of net_buf parameter before memcpy."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using target_time_convert_to_64_bits in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4263"
    ],
    "related_cwe": [
      "CWE-120,CWE-121"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000151",
    "vulnerability": "Potential buffer overflow vulnerability in the Zephyr IEEE 802.15.4 nRF 15.4 driver",
    "affected_functions": [
      "static struct ieee802154_radio_api nrf5_radio_api"
    ],
    "functionality": "Prepare and transmits IEEE 802.15.4 frames via nRF5 radio hardware, handling different transmission modes and waiting for completion through semaphore synchronization.",
    "call_patterns": [
      {
        "pattern": "static int nrf5_tx(const struct device *dev,enum ieee802154_tx_mode mode,struct net_pkt *pkt,struct net_buf *frag)(zephyr/drivers/ieee802154/ieee802154_nrf5.c)<-static struct ieee802154_radio_api nrf5_radio_api(zephyr/drivers/ieee802154/ieee802154_nrf5.c)",
        "description": "Vulnerable call chain leading to static struct ieee802154_radio_api nrf5_radio_api (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Validate the length of net_buf parameter does not exceed IEEE802154_MAX_PHY_PACKET_SIZE before calling the public API.",
      "code_snippet": "static struct ieee802154_radio_api *radio_api;\nstatic const struct device *const ieee802154_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_ieee802154));\n\nstatic bool init_ieee802154(void)\n{\n    if (!device_is_ready(ieee802154_dev)) {\n        return false;\n    }\n\n    radio_api = (struct ieee802154_radio_api *)ieee802154_dev->api;\n\n    get_mac(ieee802154_dev);\n\n    if (IEEE802154_HW_FILTER & radio_api->get_capabilities(ieee802154_dev)) {\n        struct ieee802154_filter filter;\n        uint16_t short_addr;\n\n        short_addr = (mac_addr[0] << 8) + mac_addr[1];\n        filter.short_addr = short_addr;\n        radio_api->filter(ieee802154_dev, true, IEEE802154_FILTER_TYPE_SHORT_ADDR, &filter);\n\n        filter.ieee_addr = mac_addr;\n        radio_api->filter(ieee802154_dev, true, IEEE802154_FILTER_TYPE_IEEE_ADDR, &filter);\n\n#ifdef CONFIG_NET_CONFIG_SETTINGS\n        filter.pan_id = CONFIG_NET_CONFIG_IEEE802154_PAN_ID;\n        radio_api->filter(ieee802154_dev, true, IEEE802154_FILTER_TYPE_PAN_ID, &filter);\n#endif\n    }\n\n#ifdef CONFIG_NET_CONFIG_SETTINGS\n    radio_api->set_channel(ieee802154_dev, CONFIG_NET_CONFIG_IEEE802154_CHANNEL);\n#endif\n\n    radio_api->start(ieee802154_dev);\n    return true;\n}\n\nstatic void process_data(struct net_pkt *pkt)\n{\n    struct net_buf *buf = net_buf_frag_last(pkt->buffer);\n    uint8_t seq, num_attr;\n    int ret, i;\n\n    if (buf->len < 2) {\n        send_pkt_report(0, -EINVAL, 0);\n        return;\n    }\n\n    seq = net_buf_pull_u8(buf);\n    num_attr = net_buf_pull_u8(buf);\n\n    if (buf->len < num_attr * 3) {\n        send_pkt_report(seq, -EINVAL, 0);\n        return;\n    }\n\n    for (i = 0; i < num_attr; i++) {\n        net_buf_pull_u8(buf);\n        net_buf_pull_be16(buf);\n    }\n\n    if (buf->len > IEEE802154_MAX_PHY_PACKET_SIZE) {\n        send_pkt_report(seq, -EMSGSIZE, 0);\n        return;\n    }\n\n    ret = radio_api->tx(ieee802154_dev, IEEE802154_TX_MODE_DIRECT, pkt, buf);\n    send_pkt_report(seq, ret, 1);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/60528",
      "patch_diff": "@@ -582,9 +582,14 @@ static int nrf5_tx(const struct device *dev,\n \t\t   enum ieee802154_tx_mode mode,\n \t\t   struct net_pkt *pkt,\n \t\t   struct net_buf *frag)\n {\n \tstruct nrf5_802154_data *nrf5_radio = NRF5_802154_DATA(dev);\n \tuint8_t payload_len = frag->len;\n \tuint8_t *payload = frag->data;\n \tbool ret = true;\n +\n +\tif (payload_len > IEEE802154_MTU) {\n +\t\tLOG_ERR(\"Payload too large: %d\", payload_len);\n +\t\treturn -EMSGSIZE;\n +\t}\n +\n \tLOG_DBG(\"%p (%u)\", payload, payload_len);\n \n \tnrf5_radio->tx_psdu[0] = payload_len + IEEE802154_FCS_LENGTH;\n \tm memcpy(nrf5_radio->tx_psdu + 1, payload, payload_len);\n \n \t/* Reset semaphore in case ACK was received after timeout */\n \tk_sem_reset(&nrf5_radio->tx_wait);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The public API radio_api->tx calls the driver function nrf5_tx, and there is a stack-based buffer overflow vulnerability inside nrf5_tx due to the missing bounds check on the length of net_buf parameter before memcpy."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using target_time_convert_to_64_bits in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4263"
    ],
    "related_cwe": [
      "CWE-120,CWE-121"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000152",
    "vulnerability": "Unchecked user input length in /subsys/net/l2/wifi/wifi_shell.c can cause buffer overflows.",
    "affected_functions": [
      "static int __wifi_args_to_params(size_t argc, char *argv[],struct wifi_connect_req_params *params)"
    ],
    "functionality": "Establish a Wi-Fi connection as a station.Activate the device's Access Point mode.",
    "call_patterns": [
      {
        "pattern": "static int __wifi_args_to_params(size_t argc, char *argv[],struct wifi_connect_req_params *params)(zephyr/subsys/net/l2/wifi/wifi_shell.c)<-static int cmd_wifi_connect(const struct shell *sh, size_t argc,char *argv[])(zephyr/subsys/net/l2/wifi/wifi_shell.c)<-SHELL_CMD(zephyr/subsys/net/l2/wifi/wifi_shell.c)<-SHELL_STATIC_SUBCMD_SET_CREATE(zephyr/subsys/net/l2/wifi/wifi_shell.c)",
        "description": "Vulnerable call chain leading to __wifi_args_to_params (version: v3.4.0)"
      },
      {
        "pattern": "static int __wifi_args_to_params(size_t argc, char *argv[],struct wifi_connect_req_params *params)(zephyr/subsys/net/l2/wifi/wifi_shell.c)<-static int cmd_wifi_ap_enable(const struct shell *sh, size_t argc,char *argv[])(zephyr/subsys/net/l2/wifi/wifi_shell.c)<-SHELL_CMD(zephyr/subsys/net/l2/wifi/wifi_shell.c)<-SHELL_STATIC_SUBCMD_SET_CREATE(zephyr/subsys/net/l2/wifi/wifi_shell.c)",
        "description": "Vulnerable call chain leading to __wifi_args_to_params (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all user inputs are validated against defined length constraints before being processed. Specifically, check the length of input strings against maximum and minimum allowed lengths, and return an appropriate error code if the input does not meet these criteria. This should be done immediately after assigning the input to the relevant parameters.",
      "code_snippet": "static int __wifi_args_to_params(size_t argc, char *argv[], struct wifi_connect_req_params *params) {\n    char *endptr;\n    int idx = 1;\n\n    if (argc < 1) {\n        return -EINVAL;\n    }\n\n    /* SSID */\n    params->ssid = argv[0];\n    params->ssid_length = strlen(params->ssid);\n    if (params->ssid_length > WIFI_SSID_MAX_LEN) {\n        return -EINVAL;\n    }\n\n    /* Channel (optional) */\n    if ((idx < argc) && (strlen(argv[idx]) <= 3)) {\n        ...\n    }\n\n    /* PSK (optional) */\n    if (idx < argc) {\n        params->psk = argv[idx];\n        params->psk_length = strlen(argv[idx]);\n        if (params->psk_length < WIFI_PSK_MIN_LEN ||\n            (params->security != WIFI_SECURITY_TYPE_SAE &&\n             params->psk_length > WIFI_PSK_MAX_LEN) ||\n            (params->security == WIFI_SECURITY_TYPE_SAE &&\n             params->psk_length > WIFI_SAE_PSWD_MAX_LEN)) {\n            return -EINVAL;\n        }\n        /* Defaults */\n        params->security = WIFI_SECURITY_TYPE_PSK;\n        params->mfp = WIFI_MFP_OPTIONAL;\n        idx++;\n    } else {\n        params->security = WIFI_SECURITY_TYPE_NONE;\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/60537",
      "patch_diff": "diff --git a/subsys/net/l2/wifi/wifi_shell.c b/subsys/net/l2/wifi/wifi_shell.c\nindex a520dc798bfdb..ae48a4f9b15c2 100644\n--- a/subsys/net/l2/wifi/wifi_shell.c\n+++ b/subsys/net/l2/wifi/wifi_shell.c\n@@ -333,6 +333,9 @@ static int __wifi_args_to_params(size_t argc, char *argv[],\n     /* SSID */\n     params->ssid = argv[0];\n     params->ssid_length = strlen(params->ssid);\n+    if (params->ssid_length > WIFI_SSID_MAX_LEN) {\n+        return -EINVAL;\n+    }\n \n     /* Channel (optional) */\n     if ((idx < argc) && (strlen(argv[idx]) <= 3)) {\n@@ -378,6 +381,14 @@ static int __wifi_args_to_params(size_t argc, char *argv[],\n                 idx++;\n             }\n         }\n+\n+        if (params->psk_length < WIFI_PSK_MIN_LEN ||\n+            (params->security != WIFI_SECURITY_TYPE_SAE &&\n+             params->psk_length > WIFI_PSK_MAX_LEN) ||\n+            (params->security == WIFI_SECURITY_TYPE_SAE &&\n+             params->psk_length > WIFI_SAE_PSWD_MAX_LEN)) {\n+            return -EINVAL;\n+        }\n     } else {\n         params->security = WIFI_SECURITY_TYPE_NONE;\n     }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "User input for SSID exceeding 32 characters or PSK not meeting the minimum length of 8 or exceeding 64 characters."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using __wifi_args_to_params in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-4257"
    ],
    "related_cwe": [
      "CWE-120,CWE-131"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000153",
    "vulnerability": "Potential buffer overflows in the Bluetooth subsystem due to asserts being disabled in /subsys/bluetooth/host/hci_core.c",
    "affected_functions": [
      "ll_adv_params_set"
    ],
    "functionality": "Sets advertising parameters for Bluetooth Low Energy.",
    "call_patterns": [
      {
        "pattern": "ll_adv_params_set(subsys/bluetooth/controller/ll_sw/ull_adv.c)",
        "description": "Vulnerable call chain leading to ll_adv_params_set (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, replace assert statements that check buffer lengths with conditional checks that log an error and safely handle the invalid case. Ensure that any buffer operations are only performed after validating the buffer length against the expected size. This prevents potential buffer overflows and ensures that the program can handle unexpected input gracefully.",
      "code_snippet": "uint8_t ll_adv_params_set(uint16_t interval, uint8_t adv_type,\n               uint8_t own_addr_type, uint8_t direct_addr_type,\n               uint8_t const *const direct_addr, uint8_t chan_map,\n               uint8_t filter_policy)\n{\n...\n#if defined(CONFIG_BT_CTLR_AD_DATA_BACKUP)\n    if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||\n         (IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) &&\n          (pdu->type == PDU_ADV_TYPE_EXT_IND))) &&\n        (pdu_type_prev != PDU_ADV_TYPE_DIRECT_IND) &&\n        (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||\n         (pdu_type_prev != PDU_ADV_TYPE_EXT_IND))) {\n        if (pdu->len == 0U) {\n            adv->ad_data_backup.len = 0U;\n        } else {\n            if (pdu->len < offsetof(struct pdu_adv_adv_ind, data)) {\n                LOG_ERR(\"Invalid PDU length (%u)\", pdu->len);\n                return;\n            }\n            adv->ad_data_backup.len = pdu->len -\n                offsetof(struct pdu_adv_adv_ind, data);\n            memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,\n                   adv->ad_data_backup.len);\n        }\n    }\n#endif /* CONFIG_BT_CTLR_AD_DATA_BACKUP */\n...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63605",
      "patch_diff": "if (pdu->len < offsetof(struct pdu_adv_adv_ind, data)) {\n    LOG_ERR(\"Invalid PDU length (%u)\", pdu->len);\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the PDU is less than the offset of the data."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ll_adv_params_set in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5753"
    ],
    "related_cwe": [
      "CWE-120,CWE-191"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000154",
    "vulnerability": "Potential buffer overflows in the Bluetooth subsystem due to asserts being disabled in /subsys/bluetooth/host/hci_core.c",
    "affected_functions": [
      "HDR_LLL2ULL"
    ],
    "functionality": "Sets advertising parameters for Bluetooth Low Energy.",
    "call_patterns": [
      {
        "pattern": "ll_adv_params_set(subsys/bluetooth/controller/ll_sw/ull_adv.c)",
        "description": "Vulnerable call chain leading to HDR_LLL2ULL (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, replace assert statements that check buffer lengths with conditional checks that log an error and safely handle the invalid case. Ensure that any buffer operations are only performed after validating the buffer length against the expected size. This prevents potential buffer overflows and ensures that the program can handle unexpected input gracefully.",
      "code_snippet": "uint8_t ll_adv_params_set(uint16_t interval, uint8_t adv_type,\n               uint8_t own_addr_type, uint8_t direct_addr_type,\n               uint8_t const *const direct_addr, uint8_t chan_map,\n               uint8_t filter_policy)\n{\n...\n#if defined(CONFIG_BT_CTLR_AD_DATA_BACKUP)\n    if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||\n         (IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) &&\n          (pdu->type == PDU_ADV_TYPE_EXT_IND))) &&\n        (pdu_type_prev != PDU_ADV_TYPE_DIRECT_IND) &&\n        (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||\n         (pdu_type_prev != PDU_ADV_TYPE_EXT_IND))) {\n        if (pdu->len == 0U) {\n            adv->ad_data_backup.len = 0U;\n        } else {\n            if (pdu->len < offsetof(struct pdu_adv_adv_ind, data)) {\n                LOG_ERR(\"Invalid PDU length (%u)\", pdu->len);\n                return;\n            }\n            adv->ad_data_backup.len = pdu->len -\n                offsetof(struct pdu_adv_adv_ind, data);\n            memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,\n                   adv->ad_data_backup.len);\n        }\n    }\n#endif /* CONFIG_BT_CTLR_AD_DATA_BACKUP */\n...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63605",
      "patch_diff": "if (pdu->len < offsetof(struct pdu_adv_adv_ind, data)) {\n    LOG_ERR(\"Invalid PDU length (%u)\", pdu->len);\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the PDU is less than the offset of the data."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using HDR_LLL2ULL in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5753"
    ],
    "related_cwe": [
      "CWE-120,CWE-191"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000155",
    "vulnerability": "Potential buffer overflows in the Bluetooth subsystem due to asserts being disabled in /subsys/bluetooth/host/hci_core.c",
    "affected_functions": [
      "hci_acl"
    ],
    "functionality": "Handles HCI ACL data packets.",
    "call_patterns": [
      {
        "pattern": "hci_acl(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_acl (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63605",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the buffer length is less than the size of the HCI ACL header."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using hci_acl in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5753"
    ],
    "related_cwe": [
      "CWE-120,CWE-191"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000156",
    "vulnerability": "Potential buffer overflows in the Bluetooth subsystem due to asserts being disabled in /subsys/bluetooth/host/hci_core.c",
    "affected_functions": [
      "hci_event"
    ],
    "functionality": "Processes HCI event packets.",
    "call_patterns": [
      {
        "pattern": "hci_event(subsys/bluetooth/host/hci_core.c)<-rx_work_handler(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_event (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, replace assertions that check buffer lengths with conditional checks that log an error and safely handle the invalid case. Ensure that any buffer operations are only performed after validating the buffer length against the expected size. This prevents potential buffer overflows and allows for graceful error handling.",
      "code_snippet": "static void hci_event(struct net_buf *buf) {\n    struct bt_hci_evt_hdr *hdr;\n\n    if (buf->len < sizeof(*hdr)) {\n        LOG_ERR(\"Invalid HCI event size (%u)\", buf->len);\n        net_buf_unref(buf);\n        return;\n    }\n\n    hdr = net_buf_pull_mem(buf, sizeof(*hdr));\n    LOG_DBG(\"event 0x%02x\", hdr->evt);\n    BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);\n\n    handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));\n\n    net_buf_unref(buf);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63605",
      "patch_diff": "if (buf->len < sizeof(*hdr)) {\n    LOG_ERR(\"Invalid HCI event size (%u)\", buf->len);\n    net_buf_unref(buf);\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the buffer length is less than the size of the HCI event header."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using hci_event in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5753"
    ],
    "related_cwe": [
      "CWE-120,CWE-191"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000157",
    "vulnerability": "Potential buffer overflows in the Bluetooth subsystem due to asserts being disabled in /subsys/bluetooth/host/hci_core.c",
    "affected_functions": [
      "hci_event_prio"
    ],
    "functionality": "Handles priority HCI event packets.",
    "call_patterns": [
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-rx_thread(drivers/bluetooth/hci/h4.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-h5_process_complete_packet(drivers/bluetooth/hci/h5.c)<-bt_uart_isr(drivers/bluetooth/hci/h5.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-hci_b91_host_rcv_pkt(drivers/bluetooth/hci/hci_b91.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-hci_esp_host_rcv_pkt(drivers/bluetooth/hci/hci_esp32.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-psoc6_bless_events_handler(drivers/bluetooth/hci/hci_psoc6_bless.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-bt_ipm_rx_thread(drivers/bluetooth/hci/ipm_stm32wb.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-bt_rpmsg_rx(drivers/bluetooth/hci/rpmsg.c)<-hci_ept_recv(drivers/bluetooth/hci/rpmsg.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-hci_common_transport_transmit(drivers/bluetooth/hci/slz_hci.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-bt_spi_rx_thread(drivers/bluetooth/hci/spi.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-rx_thread(drivers/bluetooth/hci/userchan.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-recv_thread(subsys/bluetooth/controller/hci/hci_driver.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-tx_thread(samples/bluetooth/hci_rpmsg/src/main.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-bt_tx_thread(samples/bluetooth/hci_spi/src/main.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-tx_thread(samples/bluetooth/hci_uart/src/main.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-send_acl(subsys/bluetooth/host/conn.c)<-do_send_frag(subsys/bluetooth/host/conn.c)<-send_frag(subsys/bluetooth/host/conn.c)<-send_buf(subsys/bluetooth/host/conn.c)<-bt_conn_process_tx(subsys/bluetooth/host/conn.c)<-process_events(subsys/bluetooth/host/hci_core.c)<-hci_tx_thread(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-bt_hci_cmd_send(subsys/bluetooth/host/hci_core.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-hci_rx_thread(subsys/usb/device/class/bluetooth.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-hci_rx_thread(subsys/usb/device/class/bt_h4.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_core.c)<-bt_hci_rx_thread(subsys/usb/device_next/class/bt_hci.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-send_cmd_status(subsys/bluetooth/host/hci_ecc.c)<-le_gen_dhkey_v1(subsys/bluetooth/host/hci_ecc.c)<-bt_hci_ecc_send(subsys/bluetooth/host/hci_ecc.c)<-bt_send(subsys/bluetooth/host/hci_raw.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-emulate_le_p256_public_key_cmd(subsys/bluetooth/host/hci_ecc.c)<-ecc_process(subsys/bluetooth/host/hci_ecc.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv(subsys/bluetooth/host/hci_core.c)<-bt_recv_prio(subsys/bluetooth/host/hci_raw.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv_prio(subsys/bluetooth/host/hci_core.c)<-read_payload(drivers/bluetooth/hci/h4.c)<-process_rx(drivers/bluetooth/hci/h4.c)<-bt_uart_isr(drivers/bluetooth/hci/h4.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv_prio(subsys/bluetooth/host/hci_core.c)<-prio_recv_thread(subsys/bluetooth/controller/hci/hci_driver.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      },
      {
        "pattern": "hci_event_prio(subsys/bluetooth/host/hci_core.c)<-bt_recv_prio(subsys/bluetooth/host/hci_core.c)<-cmd_handle(subsys/bluetooth/controller/hci/hci_driver.c)<-hci_driver_send(subsys/bluetooth/controller/hci/hci_driver.c)",
        "description": "Vulnerable call chain leading to hci_event_prio (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, replace assertions that check buffer lengths with conditional checks that log an error and safely handle the invalid case. Ensure that any function that processes buffers first verifies the buffer's length against the expected size before proceeding with operations that assume the buffer is valid. This approach prevents potential buffer overflows by ensuring that the buffer is adequately sized before accessing its contents.",
      "code_snippet": "void hci_event_prio(struct net_buf *buf) {\n    struct net_buf_simple_state state;\n    struct bt_hci_evt_hdr *hdr;\n    uint8_t evt_flags;\n\n    net_buf_simple_save(&buf->b, &state);\n\n    if (buf->len < sizeof(*hdr)) {\n        LOG_ERR(\"Invalid HCI event size (%u)\", buf->len);\n        net_buf_unref(buf);\n        return;\n    }\n\n    hdr = net_buf_pull_mem(buf, sizeof(*hdr));\n    evt_flags = bt_hci_evt_get_flags(hdr->evt);\n    BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);\n\n    handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));\n\n    if (evt_flags & BT_HCI_EVT_FLAG_RECV) {\n        net_buf_simple_restore(&buf->b, &state);\n    } else {\n        net_buf_unref(buf);\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63605",
      "patch_diff": "@@ -3714,7 +3721,11 @@ void hci_event_prio(struct net_buf *buf) {\n \n     net_buf_simple_save(&buf->b, &state);\n \n -    BT_ASSERT(buf->len >= sizeof(*hdr));\n +    if (buf->len < sizeof(*hdr)) {\n +        LOG_ERR(\"Invalid HCI event size (%u)\", buf->len);\n +        net_buf_unref(buf);\n +        return;\n +    }\n \n     hdr = net_buf_pull_mem(buf, sizeof(*hdr));\n     evt_flags = bt_hci_evt_get_flags(hdr->evt);\n     BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the buffer length is less than the size of the HCI event header."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using hci_event_prio in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5753"
    ],
    "related_cwe": [
      "CWE-120,CWE-191"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000158",
    "vulnerability": "Potential buffer overflows in the Bluetooth subsystem due to asserts being disabled in /subsys/bluetooth/host/hci_core.c",
    "affected_functions": [
      "hci_iso"
    ],
    "functionality": "Processes HCI ISO data packets.",
    "call_patterns": [
      {
        "pattern": "hci_iso(subsys/bluetooth/host/iso.c)",
        "description": "Vulnerable call chain leading to hci_iso (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, replace assertions that check buffer lengths with conditional checks that log an error and safely handle the invalid case. Ensure that any buffer operations are only performed after validating the buffer length against the expected size. This prevents potential buffer overflows and allows for graceful error handling.",
      "code_snippet": "void hci_iso(struct net_buf *buf) {\n    struct bt_hci_iso_hdr *hdr;\n    uint16_t handle, len;\n    struct bt_conn *iso;\n    uint8_t flags;\n\n    BT_ISO_DATA_DBG(\"buf %p\", buf);\n\n    if (buf->len < sizeof(*hdr)) {\n        LOG_ERR(\"Invalid HCI ISO packet size (%u)\", buf->len);\n        net_buf_unref(buf);\n        return;\n    }\n\n    hdr = net_buf_pull_mem(buf, sizeof(*hdr));\n    len = bt_iso_hdr_len(sys_le16_to_cpu(hdr->len));\n    handle = sys_le16_to_cpu(hdr->handle);\n    flags = bt_iso_flags(handle);\n    ...",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/63605",
      "patch_diff": "diff --git a/subsys/bluetooth/host/iso.c b/subsys/bluetooth/host/iso.c\nindex 49dd52d0ffb2a..a1b645c0e2f26 100644\n--- a/subsys/bluetooth/host/iso.c\n+++ b/subsys/bluetooth/host/iso.c\n@@ -105,7 +105,11 @@ void hci_iso(struct net_buf *buf)\n \n     BT_ISO_DATA_DBG(\"buf %p\", buf);\n \n-    BT_ASSERT(buf->len >= sizeof(*hdr));\n+    if (buf->len < sizeof(*hdr)) {\n+        LOG_ERR(\"Invalid HCI ISO packet size (%u)\", buf->len);\n+        net_buf_unref(buf);\n+        return;\n+    }\n \n     hdr = net_buf_pull_mem(buf, sizeof(*hdr));\n     len = bt_iso_hdr_len(sys_le16_to_cpu(hdr->len));"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the buffer length is less than the size of the HCI ISO header."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using hci_iso in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5753"
    ],
    "related_cwe": [
      "CWE-120,CWE-191"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000159",
    "vulnerability": "Possible variant of CVE-2021-3434 in function le_ecred_reconf_req.",
    "affected_functions": [
      "le_ecred_reconf_req"
    ],
    "functionality": "Handles the LE eCred reconfiguration request in the Bluetooth L2CAP layer.",
    "call_patterns": [
      {
        "pattern": "le_ecred_reconf_req(subsys/bluetooth/host/l2cap.c)",
        "description": "Vulnerable call chain leading to le_ecred_reconf_req (version: v3.4.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any input data is validated against expected limits before processing. Specifically, check the length of buffers or arrays against predefined maximum values to prevent out-of-bounds writes. Implement early return patterns to handle invalid input gracefully, and always document the constraints based on the specifications.",
      "code_snippet": "static void le_ecred_reconf_req(struct bt_l2cap *l2cap, uint8_t ident, struct net_buf *buf) {\n\t...\n\tif (buf->len > (L2CAP_ECRED_CHAN_MAX_PER_REQ * sizeof(scid))) {\n\t\tresult = BT_L2CAP_RECONF_OTHER_UNACCEPT;\n\t\tgoto response;\n\t}\n\t...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/62381",
      "patch_diff": "if (buf->len > (L2CAP_ECRED_CHAN_MAX_PER_REQ * sizeof(scid))) {\n\tresult = BT_L2CAP_RECONF_OTHER_UNACCEPT;\n\tgoto response;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "If buf->len is greater than L2CAP_ECRED_CHAN_MAX_PER_REQ times the size of scid."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using le_ecred_reconf_req in vulnerable versions (v3.4.0 → v3.5.0)"
    ],
    "related_cve": [
      "CVE-2023-5055"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v3.4.0"
  },
  {
    "id": "VULN-000160",
    "vulnerability": "Unchecked length coming from user input in settings shell",
    "affected_functions": [
      "cmd_write"
    ],
    "functionality": "Handles writing settings through a shell command.",
    "call_patterns": [
      {
        "pattern": "cmd_write(subsys/settings/src/settings_shell.c)",
        "description": "Vulnerable call chain leading to cmd_write (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always validate the length of user input before processing it, especially when copying data into fixed-size buffers. Implement checks to ensure that the input does not exceed the buffer size, and handle cases where it does appropriately by returning an error and providing feedback to the user.",
      "code_snippet": "static int cmd_write(const struct shell *shell_ptr, size_t argc, char *argv[]) {\n    int err;\n    uint8_t buffer[CONFIG_SHELL_CMD_BUFF_SIZE / 2];\n    size_t buffer_len = 0;\n    enum settings_value_types value_type = SETTINGS_VALUE_HEX;\n\n    if (argc > 3) {\n        err = settings_parse_type(argv[1], &value_type);\n        if (err) {\n            shell_error(shell_ptr, \"Invalid type: %s\", argv[1]);\n            return err;\n        }\n    }\n\n    switch (value_type) {\n    case SETTINGS_VALUE_HEX:\n        buffer_len = hex2bin(argv[argc - 1], strlen(argv[argc - 1]), buffer, sizeof(buffer));\n        break;\n    case SETTINGS_VALUE_STRING:\n        buffer_len = strlen(argv[argc - 1]) + 1;\n        if (buffer_len > sizeof(buffer)) {\n            shell_error(shell_ptr, \"%s is bigger than shell's buffer\", argv[argc - 1]);\n            return -EINVAL;\n        }\n        memcpy(buffer, argv[argc - 1], buffer_len);\n        break;\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/66451",
      "patch_diff": "if (buffer_len > sizeof(buffer)) {\n    shell_error(shell_ptr, \"%s is bigger than shell's buffer\", argv[argc - 1]);\n    return -EINVAL;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the string argument exceeds the buffer size."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using cmd_write in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-6749"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000161",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_nxp_s32_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the CAN NXP S32 device.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters, especially those that can be controlled by users or external sources, are validated against expected bounds before they are used. Implement checks to verify that the input falls within valid ranges, and log an error or return early if the input is out of bounds. This prevents potential out-of-bounds access and enhances the security of the function.",
      "code_snippet": "static void can_nxp_s32_remove_rx_filter(const struct device *dev, int filter_id) {\n\tconst struct can_nxp_s32_config *config = dev->config;\n\tstruct can_nxp_s32_data *data = dev->data;\n\tint mb_indx = ALLOC_IDX_TO_RXMB_IDX(filter_id);\n\n\tif (filter_id < 0 || filter_id >= CONFIG_CAN_NXP_S32_MAX_RX) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\t\treturn;\n\t}\n\n\t__ASSERT_NO_MSG(filter_id >= 0 && filter_id < CONFIG_CAN_NXP_S32_MAX_RX);\n\n\tk_mutex_lock(&data->rx_mutex, K_FOREVER);\n\n\tif (atomic_test_and_clear_bit(data->rx_allocs, filter_id)) {\n\t\tif (can_nxp_s32_abort_msg(config, mb_indx)) {\n\t\t\tLOG_ERR(\"Can't abort message !\");\n\t\t};\n\n\t\tdata->rx_cbs[filter_id].function = NULL;\n\t\tdata->rx_cbs[filter_id].arg = NULL;\n\t\tdata->rx_cbs[filter_id].filter = (struct can_filter){0};\n\t} else {\n\t\tLOG_WRN(\"Filter ID %d already detached\", filter_id);\n\t}\n\n\tk_mutex_unlock(&data->rx_mutex);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64431",
      "patch_diff": "if (filter_id < 0 || filter_id >= CONFIG_CAN_NXP_S32_MAX_RX) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\t\treturn;\n\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When filter_id is out of bounds (negative or greater than or equal to CONFIG_CAN_NXP_S32_MAX_RX)."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_nxp_s32_remove_rx_filter in vulnerable versions (v2.7.5 → v2.7.6)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.5"
  },
  {
    "id": "VULN-000162",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcp2515_detach"
    ],
    "functionality": "Detaches a filter from the MCP2515 CAN controller.",
    "call_patterns": [
      {
        "pattern": "mcp2515_register_state_change_isr(drivers/can/can_mcp2515.c)",
        "description": "Vulnerable call chain leading to mcp2515_detach (version: v2.7.5)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64431",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When filter_nr is out of bounds (negative or greater than or equal to CONFIG_CAN_MAX_FILTER)."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcp2515_detach in vulnerable versions (v2.7.5 → v2.7.6)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.5"
  },
  {
    "id": "VULN-000163",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcp2515_register_state_change_isr"
    ],
    "functionality": "Detaches a filter from the MCP2515 CAN controller.",
    "call_patterns": [
      {
        "pattern": "mcp2515_register_state_change_isr(drivers/can/can_mcp2515.c)",
        "description": "Vulnerable call chain leading to mcp2515_register_state_change_isr (version: v2.7.5)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64431",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When filter_nr is out of bounds (negative or greater than or equal to CONFIG_CAN_MAX_FILTER)."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcp2515_register_state_change_isr in vulnerable versions (v2.7.5 → v2.7.6)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.5"
  },
  {
    "id": "VULN-000164",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcux_flexcan_detach"
    ],
    "functionality": "Detaches a filter from the MCUX FlexCAN device.",
    "call_patterns": [
      {
        "pattern": "mcux_flexcan_detach(drivers/can/can_mcux_flexcan.c)",
        "description": "Vulnerable call chain leading to mcux_flexcan_detach (version: v2.7.5)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checking for all relevant parameters, especially those that are derived from user input or external sources. Use clear logging to indicate when invalid parameters are detected, and return early from the function to prevent further processing.",
      "code_snippet": "static void mcux_flexcan_detach(const struct device *dev, int filter_id) {\n\tconst struct mcux_flexcan_config *config = dev->config;\n\tstruct mcux_flexcan_data *data = dev->data;\n\n\tif (filter_id < 0 || filter_id >= MCUX_FLEXCAN_MAX_RX) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\t\treturn;\n\t}\n\n\t// Existing logic for detaching the filter\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64431",
      "patch_diff": "diff --git a/drivers/can/can_mcux_flexcan.c b/drivers/can/can_mcux_flexcan.c\nindex 88542242dc961..c51748bb6b432 100644\n--- a/drivers/can/can_mcux_flexcan.c\n+++ b/drivers/can/can_mcux_flexcan.c\n@@ -480,9 +480,8 @@ static void mcux_flexcan_detach(const struct device *dev, int filter_id)\n \tconst struct mcux_flexcan_config *config = dev->config;\n \tstruct mcux_flexcan_data *data = dev->data;\n \n--\tif (filter_id >= MCUX_FLEXCAN_MAX_RX) {\n--\t\tLOG_ERR(\"Detach: Filter id >= MAX_RX (%d >= %d)\", filter_id,\n--\t\t\t\tMCUX_FLEXCAN_MAX_RX);\n+-\tif (filter_id < 0 || filter_id >= MCUX_FLEXCAN_MAX_RX) {\n+\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n \t\treturn;\n \t}\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When filter_id is out of bounds (negative or greater than or equal to MCUX_FLEXCAN_MAX_RX)."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcux_flexcan_detach in vulnerable versions (v2.7.5 → v2.7.6)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.5"
  },
  {
    "id": "VULN-000165",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_rcar_detach"
    ],
    "functionality": "Detaches a filter from the R-Car CAN controller.",
    "call_patterns": [
      {
        "pattern": "can_rcar_detach(drivers/can/can_rcar.c)",
        "description": "Vulnerable call chain leading to can_rcar_detach (version: v2.7.5)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checking for all relevant parameters, especially those that are derived from user input or external sources. Use clear logging to indicate when invalid parameters are detected, and return early from the function to prevent further processing.",
      "code_snippet": "void can_rcar_detach(const struct device *dev, int filter_nr) {\n\tstruct can_rcar_data *data = DEV_CAN_DATA(dev);\n\n\tif (filter_nr < 0 || filter_nr >= CONFIG_CAN_RCAR_MAX_FILTER) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_nr);\n\t\treturn;\n\t}\n\n\t// Existing logic for detaching the filter...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64431",
      "patch_diff": "diff --git a/drivers/can/can_rcar.c b/drivers/can/can_rcar.c\nindex 31a53c25bf4fe..66fcc4bac9297 100644\n--- a/drivers/can/can_rcar.c\n+++ b/drivers/can/can_rcar.c\n@@ -829,7 +829,8 @@ void can_rcar_detach(const struct device *dev, int filter_nr)\n {\n \tstruct can_rcar_data *data = DEV_CAN_DATA(dev);\n \n- \tif (filter_nr >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+ \tif (filter_nr < 0 || filter_nr >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+ \t\tLOG_ERR(\"filter ID %d out of bounds\", filter_nr);\n \t\treturn;\n \t}\n\n\t// Existing logic for detaching the filter...\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When filter_nr is out of bounds (negative or greater than or equal to CONFIG_CAN_RCAR_MAX_FILTER)."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_rcar_detach in vulnerable versions (v2.7.5 → v2.7.6)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v2.7.5"
  },
  {
    "id": "VULN-000166",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_nxp_s32_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the NXP S32 CAN controller.",
    "call_patterns": [
      {
        "pattern": "can_nxp_s32_add_rx_filter(drivers/can/can_nxp_s32_canxl.c)",
        "description": "Vulnerable call chain leading to can_nxp_s32_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before use. Specifically, check that the filter ID is within valid bounds (greater than or equal to 0 and less than the maximum allowed value) before proceeding with any operations that depend on it. Use logging to report any invalid inputs and return early to prevent further processing.",
      "code_snippet": "static void can_nxp_s32_remove_rx_filter(const struct device *dev, int filter_id) {\n    const struct can_nxp_s32_config *config = dev->config;\n    struct can_nxp_s32_data *data = dev->data;\n    int mb_indx = ALLOC_IDX_TO_RXMB_IDX(filter_id);\n\n    if (filter_id < 0 || filter_id >= CONFIG_CAN_NXP_S32_MAX_RX) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&data->rx_mutex, K_FOREVER);\n\n    if (atomic_test_and_clear_bit(data->rx_allocs, filter_id)) {\n        if (can_nxp_s32_abort_msg(config, mb_indx)) {\n            LOG_ERR(\"Can't abort message !\");\n        };\n\n        data->rx_cbs[filter_id].function = NULL;\n        data->rx_cbs[filter_id].arg = NULL;\n        data->rx_cbs[filter_id].filter = (struct can_filter){0};\n    } else {\n        LOG_WRN(\"Filter ID %d already detached\", filter_id);\n    }\n\n    k_mutex_unlock(&data->rx_mutex);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_nxp_s32_canxl.c b/drivers/can/can_nxp_s32_canxl.c\n+++ b/drivers/can/can_nxp_s32_canxl.c\n@@ -396,7 +396,10 @@ static void can_nxp_s32_remove_rx_filter(const struct device *dev, int filter_id\n     struct can_nxp_s32_data *data = dev->data;\n     int mb_indx = ALLOC_IDX_TO_RXMB_IDX(filter_id);\n \n-    __ASSERT_NO_MSG(filter_id >= 0 && filter_id < CONFIG_CAN_NXP_S32_MAX_RX);\n+    if (filter_id < 0 || filter_id >= CONFIG_CAN_NXP_S32_MAX_RX) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n \n     k_mutex_lock(&data->rx_mutex, K_FOREVER);\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CONFIG_CAN_NXP_S32_MAX_RX."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_nxp_s32_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000167",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_nxp_s32_add_rx_filter"
    ],
    "functionality": "Removes a receive filter from the NXP S32 CAN controller.",
    "call_patterns": [
      {
        "pattern": "can_nxp_s32_add_rx_filter(drivers/can/can_nxp_s32_canxl.c)",
        "description": "Vulnerable call chain leading to can_nxp_s32_add_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before use. Specifically, check that the filter ID is within valid bounds (greater than or equal to 0 and less than the maximum allowed value) before proceeding with any operations that depend on it. Use logging to report any invalid inputs and return early to prevent further processing.",
      "code_snippet": "static void can_nxp_s32_remove_rx_filter(const struct device *dev, int filter_id) {\n    const struct can_nxp_s32_config *config = dev->config;\n    struct can_nxp_s32_data *data = dev->data;\n    int mb_indx = ALLOC_IDX_TO_RXMB_IDX(filter_id);\n\n    if (filter_id < 0 || filter_id >= CONFIG_CAN_NXP_S32_MAX_RX) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&data->rx_mutex, K_FOREVER);\n\n    if (atomic_test_and_clear_bit(data->rx_allocs, filter_id)) {\n        if (can_nxp_s32_abort_msg(config, mb_indx)) {\n            LOG_ERR(\"Can't abort message !\");\n        };\n\n        data->rx_cbs[filter_id].function = NULL;\n        data->rx_cbs[filter_id].arg = NULL;\n        data->rx_cbs[filter_id].filter = (struct can_filter){0};\n    } else {\n        LOG_WRN(\"Filter ID %d already detached\", filter_id);\n    }\n\n    k_mutex_unlock(&data->rx_mutex);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_nxp_s32_canxl.c b/drivers/can/can_nxp_s32_canxl.c\n+++ b/drivers/can/can_nxp_s32_canxl.c\n@@ -396,7 +396,10 @@ static void can_nxp_s32_remove_rx_filter(const struct device *dev, int filter_id\n     struct can_nxp_s32_data *data = dev->data;\n     int mb_indx = ALLOC_IDX_TO_RXMB_IDX(filter_id);\n \n-    __ASSERT_NO_MSG(filter_id >= 0 && filter_id < CONFIG_CAN_NXP_S32_MAX_RX);\n+    if (filter_id < 0 || filter_id >= CONFIG_CAN_NXP_S32_MAX_RX) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n \n     k_mutex_lock(&data->rx_mutex, K_FOREVER);\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CONFIG_CAN_NXP_S32_MAX_RX."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_nxp_s32_add_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000168",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcp2515_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the MCP2515 CAN controller.",
    "call_patterns": [
      {
        "pattern": "mcp2515_add_rx_filter(drivers/can/can_mcp2515.c)",
        "description": "Vulnerable call chain leading to mcp2515_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checking for all relevant parameters, especially those that are user-controlled or can be influenced by external inputs. Use conditional statements to check if the input falls within the expected range, and log an error message if it does not. This should be done in a way that prevents further execution of the function if the input is invalid.",
      "code_snippet": "static void mcp2515_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct mcp2515_data *dev_data = dev->data;\n\n    if (filter_id < 0 || filter_id >= CONFIG_CAN_MAX_FILTER) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&dev_data->mutex, K_FOREVER);\n    dev_data->filter_usage &= ~BIT(filter_id);\n    k_mutex_unlock(&dev_data->mutex);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_mcp2515.c b/drivers/can/can_mcp2515.c\nindex df403dfac62d0..4009718e2ba56 100644\n--- a/drivers/can/can_mcp2515.c\n+++ b/drivers/can/can_mcp2515.c\n@@ -663,6 +663,11 @@ static void mcp2515_remove_rx_filter(const struct device *dev, int filter_id)\n {\n     struct mcp2515_data *dev_data = dev->data;\n+\n+    if (filter_id < 0 || filter_id >= CONFIG_CAN_MAX_FILTER) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n+\n     k_mutex_lock(&dev_data->mutex, K_FOREVER);\n     dev_data->filter_usage &= ~BIT(filter_id);\n     k_mutex_unlock(&dev_data->mutex);\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CONFIG_CAN_MAX_FILTER."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcp2515_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000169",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcp2515_add_rx_filter"
    ],
    "functionality": "Removes a receive filter from the MCP2515 CAN controller.",
    "call_patterns": [
      {
        "pattern": "mcp2515_add_rx_filter(drivers/can/can_mcp2515.c)",
        "description": "Vulnerable call chain leading to mcp2515_add_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checking for all relevant parameters, especially those that are user-controlled or can be influenced by external inputs. Use conditional statements to check if the input falls within the expected range, and log an error message if it does not. This should be done in a way that prevents further execution of the function if the input is invalid.",
      "code_snippet": "static void mcp2515_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct mcp2515_data *dev_data = dev->data;\n\n    if (filter_id < 0 || filter_id >= CONFIG_CAN_MAX_FILTER) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&dev_data->mutex, K_FOREVER);\n    dev_data->filter_usage &= ~BIT(filter_id);\n    k_mutex_unlock(&dev_data->mutex);\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_mcp2515.c b/drivers/can/can_mcp2515.c\nindex df403dfac62d0..4009718e2ba56 100644\n--- a/drivers/can/can_mcp2515.c\n+++ b/drivers/can/can_mcp2515.c\n@@ -663,6 +663,11 @@ static void mcp2515_remove_rx_filter(const struct device *dev, int filter_id)\n {\n     struct mcp2515_data *dev_data = dev->data;\n+\n+    if (filter_id < 0 || filter_id >= CONFIG_CAN_MAX_FILTER) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n+\n     k_mutex_lock(&dev_data->mutex, K_FOREVER);\n     dev_data->filter_usage &= ~BIT(filter_id);\n     k_mutex_unlock(&dev_data->mutex);\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CONFIG_CAN_MAX_FILTER."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcp2515_add_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000170",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcux_flexcan_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the MCUX FlexCAN controller.",
    "call_patterns": [
      {
        "pattern": "mcux_flexcan_recover(drivers/can/can_mcux_flexcan.c)",
        "description": "Vulnerable call chain leading to mcux_flexcan_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to MCUX_FLEXCAN_MAX_RX."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcux_flexcan_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000171",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "mcux_flexcan_recover"
    ],
    "functionality": "Removes a receive filter from the MCUX FlexCAN controller.",
    "call_patterns": [
      {
        "pattern": "mcux_flexcan_recover(drivers/can/can_mcux_flexcan.c)",
        "description": "Vulnerable call chain leading to mcux_flexcan_recover (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to MCUX_FLEXCAN_MAX_RX."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mcux_flexcan_recover in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000172",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_stm32_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the STM32 BxCAN controller.",
    "call_patterns": [
      {
        "pattern": "can_stm32_add_rx_filter(drivers/can/can_stm32_bxcan.c)",
        "description": "Vulnerable call chain leading to can_stm32_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checking for all relevant parameters, especially those that are user-controlled or can be influenced by external inputs. Use clear logging to indicate when invalid parameters are detected, and return early from the function to prevent further processing.",
      "code_snippet": "static void can_stm32_remove_rx_filter(const struct device *dev, int filter_id) {\n\tint bank_num;\n\tbool bank_unused;\n\n\tif (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\t\treturn;\n\t}\n\n\tk_mutex_lock(&filter_mutex, K_FOREVER);\n\tk_mutex_lock(&data->inst_mutex, K_FOREVER);\n\t// ... rest of the function ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_stm32_bxcan.c b/drivers/can/can_stm32_bxcan.c\nindex d7eab7aea3524..58df8f1db5d9d 100644\n--- a/drivers/can/can_stm32_bxcan.c\n+++ b/drivers/can/can_stm32_bxcan.c\n@@ -1035,7 +1035,10 @@ static void can_stm32_remove_rx_filter(const struct device *dev, int filter_id)\n \tint bank_num;\n \tbool bank_unused;\n \n- __ASSERT_NO_MSG(filter_id >= 0 && filter_id < CAN_STM32_MAX_FILTER_ID);\n+ if (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {\n+ \tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+ \treturn;\n+ }\n \n \tk_mutex_lock(&filter_mutex, K_FOREVER);\n \tk_mutex_lock(&data->inst_mutex, K_FOREVER);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CAN_STM32_MAX_FILTER_ID."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_stm32_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000173",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_stm32_add_rx_filter"
    ],
    "functionality": "Removes a receive filter from the STM32 BxCAN controller.",
    "call_patterns": [
      {
        "pattern": "can_stm32_add_rx_filter(drivers/can/can_stm32_bxcan.c)",
        "description": "Vulnerable call chain leading to can_stm32_add_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checking for all relevant parameters, especially those that are user-controlled or can be influenced by external inputs. Use clear logging to indicate when invalid parameters are detected, and return early from the function to prevent further processing.",
      "code_snippet": "static void can_stm32_remove_rx_filter(const struct device *dev, int filter_id) {\n\tint bank_num;\n\tbool bank_unused;\n\n\tif (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\t\treturn;\n\t}\n\n\tk_mutex_lock(&filter_mutex, K_FOREVER);\n\tk_mutex_lock(&data->inst_mutex, K_FOREVER);\n\t// ... rest of the function ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_stm32_bxcan.c b/drivers/can/can_stm32_bxcan.c\nindex d7eab7aea3524..58df8f1db5d9d 100644\n--- a/drivers/can/can_stm32_bxcan.c\n+++ b/drivers/can/can_stm32_bxcan.c\n@@ -1035,7 +1035,10 @@ static void can_stm32_remove_rx_filter(const struct device *dev, int filter_id)\n \tint bank_num;\n \tbool bank_unused;\n \n- __ASSERT_NO_MSG(filter_id >= 0 && filter_id < CAN_STM32_MAX_FILTER_ID);\n+ if (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {\n+ \tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+ \treturn;\n+ }\n \n \tk_mutex_lock(&filter_mutex, K_FOREVER);\n \tk_mutex_lock(&data->inst_mutex, K_FOREVER);"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CAN_STM32_MAX_FILTER_ID."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_stm32_add_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000174",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_rcar_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the R-Car CAN controller.",
    "call_patterns": [
      {
        "pattern": "can_rcar_init(drivers/can/can_rcar.c)",
        "description": "Vulnerable call chain leading to can_rcar_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used. Specifically, check that the input values fall within the expected range. Use conditional statements to log errors and return early if the input is invalid. This prevents out-of-bounds access and potential security vulnerabilities.",
      "code_snippet": "static void can_rcar_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct can_rcar_data *data = dev->data;\n\n    if (filter_id < 0 || filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    // Existing logic for removing the RX filter\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_rcar.c b/drivers/can/can_rcar.c\nindex 1dfaf715414c3..f015407c22fa4 100644\n--- a/drivers/can/can_rcar.c\n+++ b/drivers/can/can_rcar.c\n@@ -975,7 +975,8 @@ static void can_rcar_remove_rx_filter(const struct device *dev, int filter_id)\n {\n     struct can_rcar_data *data = dev->data;\n \n-    if (filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+    if (filter_id < 0 || filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n         return;\n     }\n \n     // Existing logic for removing the RX filter\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CONFIG_CAN_RCAR_MAX_FILTER."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_rcar_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000175",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_rcar_init"
    ],
    "functionality": "Removes a receive filter from the R-Car CAN controller.",
    "call_patterns": [
      {
        "pattern": "can_rcar_init(drivers/can/can_rcar.c)",
        "description": "Vulnerable call chain leading to can_rcar_init (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used. Specifically, check that the input values fall within the expected range. Use conditional statements to log errors and return early if the input is invalid. This prevents out-of-bounds access and potential security vulnerabilities.",
      "code_snippet": "static void can_rcar_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct can_rcar_data *data = dev->data;\n\n    if (filter_id < 0 || filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    // Existing logic for removing the RX filter\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_rcar.c b/drivers/can/can_rcar.c\nindex 1dfaf715414c3..f015407c22fa4 100644\n--- a/drivers/can/can_rcar.c\n+++ b/drivers/can/can_rcar.c\n@@ -975,7 +975,8 @@ static void can_rcar_remove_rx_filter(const struct device *dev, int filter_id)\n {\n     struct can_rcar_data *data = dev->data;\n \n-    if (filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+    if (filter_id < 0 || filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n         return;\n     }\n \n     // Existing logic for removing the RX filter\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to CONFIG_CAN_RCAR_MAX_FILTER."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_rcar_init in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000176",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_mcan_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the MCAN controller.",
    "call_patterns": [
      {
        "pattern": "can_mcan_remove_rx_filter(drivers/can/can_mcan.c)",
        "description": "Vulnerable call chain leading to can_mcan_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement checks to verify that the input values fall within the expected range. Use logging to report any invalid inputs and return early from the function to prevent further processing.",
      "code_snippet": "void can_mcan_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct can_mcan_data *data = dev->data;\n    int err;\n\n    if (filter_id < 0) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&data->lock, K_FOREVER);\n\n    if (filter_id >= cbs->num_std) {\n        filter_id -= cbs->num_std;\n        if (filter_id >= cbs->num_ext) {\n            LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n            k_mutex_unlock(&data->lock);\n            return;\n        }\n    }",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_mcan.c b/drivers/can/can_mcan.c\nindex 550f29b2334d7..9b9fec79acedc 100644\n--- a/drivers/can/can_mcan.c\n+++ b/drivers/can/can_mcan.c\n@@ -1149,12 +1149,17 @@ void can_mcan_remove_rx_filter(const struct device *dev, int filter_id)\n     struct can_mcan_data *data = dev->data;\n     int err;\n \n+    if (filter_id < 0) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n+\n     k_mutex_lock(&data->lock, K_FOREVER);\n \n     if (filter_id >= cbs->num_std) {\n         filter_id -= cbs->num_std;\n         if (filter_id >= cbs->num_ext) {\n-            LOG_ERR(\"Wrong filter id\");\n+            LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n             k_mutex_unlock(&data->lock);\n             return;\n         }\n     }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to the number of standard or extended filters."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_mcan_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000177",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_mcan_get_max_bitrate"
    ],
    "functionality": "Removes a receive filter from the MCAN controller.",
    "call_patterns": [
      {
        "pattern": "can_mcan_remove_rx_filter(drivers/can/can_mcan.c)",
        "description": "Vulnerable call chain leading to can_mcan_get_max_bitrate (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement checks to verify that the input values fall within the expected range. Use logging to report any invalid inputs and return early from the function to prevent further processing.",
      "code_snippet": "void can_mcan_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct can_mcan_data *data = dev->data;\n    int err;\n\n    if (filter_id < 0) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&data->lock, K_FOREVER);\n\n    if (filter_id >= cbs->num_std) {\n        filter_id -= cbs->num_std;\n        if (filter_id >= cbs->num_ext) {\n            LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n            k_mutex_unlock(&data->lock);\n            return;\n        }\n    }",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_mcan.c b/drivers/can/can_mcan.c\nindex 550f29b2334d7..9b9fec79acedc 100644\n--- a/drivers/can/can_mcan.c\n+++ b/drivers/can/can_mcan.c\n@@ -1149,12 +1149,17 @@ void can_mcan_remove_rx_filter(const struct device *dev, int filter_id)\n     struct can_mcan_data *data = dev->data;\n     int err;\n \n+    if (filter_id < 0) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n+\n     k_mutex_lock(&data->lock, K_FOREVER);\n \n     if (filter_id >= cbs->num_std) {\n         filter_id -= cbs->num_std;\n         if (filter_id >= cbs->num_ext) {\n-            LOG_ERR(\"Wrong filter id\");\n+            LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n             k_mutex_unlock(&data->lock);\n             return;\n         }\n     }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to the number of standard or extended filters."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_mcan_get_max_bitrate in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000178",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_mcan_set_state_change_callback"
    ],
    "functionality": "Removes a receive filter from the MCAN controller.",
    "call_patterns": [
      {
        "pattern": "can_mcan_remove_rx_filter(drivers/can/can_mcan.c)",
        "description": "Vulnerable call chain leading to can_mcan_set_state_change_callback (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement checks to verify that the input values fall within the expected range. Use logging to report any invalid inputs and return early from the function to prevent further processing.",
      "code_snippet": "void can_mcan_remove_rx_filter(const struct device *dev, int filter_id) {\n    struct can_mcan_data *data = dev->data;\n    int err;\n\n    if (filter_id < 0) {\n        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n        return;\n    }\n\n    k_mutex_lock(&data->lock, K_FOREVER);\n\n    if (filter_id >= cbs->num_std) {\n        filter_id -= cbs->num_std;\n        if (filter_id >= cbs->num_ext) {\n            LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n            k_mutex_unlock(&data->lock);\n            return;\n        }\n    }",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "diff --git a/drivers/can/can_mcan.c b/drivers/can/can_mcan.c\nindex 550f29b2334d7..9b9fec79acedc 100644\n--- a/drivers/can/can_mcan.c\n+++ b/drivers/can/can_mcan.c\n@@ -1149,12 +1149,17 @@ void can_mcan_remove_rx_filter(const struct device *dev, int filter_id)\n     struct can_mcan_data *data = dev->data;\n     int err;\n \n+    if (filter_id < 0) {\n+        LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+        return;\n+    }\n+\n     k_mutex_lock(&data->lock, K_FOREVER);\n \n     if (filter_id >= cbs->num_std) {\n         filter_id -= cbs->num_std;\n         if (filter_id >= cbs->num_ext) {\n-            LOG_ERR(\"Wrong filter id\");\n+            LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n             k_mutex_unlock(&data->lock);\n             return;\n         }\n     }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to the number of standard or extended filters."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_mcan_set_state_change_callback in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000179",
    "vulnerability": "can: out of bounds in remove_rx_filter function",
    "affected_functions": [
      "can_sja1000_remove_rx_filter"
    ],
    "functionality": "Removes a receive filter from the SJA1000 CAN controller.",
    "call_patterns": [
      {
        "pattern": "can_sja1000_remove_rx_filter(drivers/can/can_sja1000.c)",
        "description": "Vulnerable call chain leading to can_sja1000_remove_rx_filter (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all input parameters are validated before they are used in any operations that could lead to out-of-bounds access. Implement bounds checks that verify the input is within the expected range, and log an error message if the input is invalid. This should be done at the beginning of the function to prevent any further processing with invalid data.",
      "code_snippet": "void can_sja1000_remove_rx_filter(const struct device *dev, int filter_id) {\n\tstruct can_sja1000_data *data = dev->data;\n\n\tif (filter_id < 0 || filter_id >= ARRAY_SIZE(data->filters)) {\n\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\t\treturn;\n\t}\n\n\t// Existing logic for removing the filter\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/64399",
      "patch_diff": "if (filter_id < 0 || filter_id >= ARRAY_SIZE(data->filters)) {\n\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\treturn;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "filter_id is less than 0 or greater than or equal to the size of the filters array."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using can_sja1000_remove_rx_filter in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-5779"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000180",
    "vulnerability": "Possible buffer overflow in is_mount_point",
    "affected_functions": [
      "is_mount_point"
    ],
    "functionality": "Checks if the given path is a mount point.",
    "call_patterns": [
      {
        "pattern": "is_mount_point(subsys/fs/fuse_fs_access.c)<-fuse_fs_access_getattr(subsys/fs/fuse_fs_access.c)",
        "description": "Vulnerable call chain leading to is_mount_point (version: v3.5.0)"
      },
      {
        "pattern": "is_mount_point(subsys/fs/fuse_fs_access.c)<-fuse_fs_access_readdir(subsys/fs/fuse_fs_access.c)",
        "description": "Vulnerable call chain leading to is_mount_point (version: v3.5.0)"
      },
      {
        "pattern": "is_mount_point(subsys/fs/fuse_fs_access.c)<-fuse_fs_access_create(subsys/fs/fuse_fs_access.c)<-fuse_fs_access_open(subsys/fs/fuse_fs_access.c)",
        "description": "Vulnerable call chain leading to is_mount_point (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/66592",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "If the string passed via path parameter is PATH_MAX long."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using is_mount_point in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2023-6881"
    ],
    "related_cwe": [
      "CWE-120"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000181",
    "vulnerability": "The documentation specifies that the BT_GATT_PERM_READ_LESC and BT_GATT_PERM_WRITE_LESC defines for a Bluetooth characteristic: Attribute read/write permission with LE Secure Connection encryption. If set, requires that LE Secure Connections is used for read/write access, however this is only true when it is combined with other permissions, namely BT_GATT_PERM_READ_ENCRYPT/BT_GATT_PERM_READ_AUTHEN (for read) or BT_GATT_PERM_WRITE_ENCRYPT/BT_GATT_PERM_WRITE_AUTHEN (for write), if these additional permissions are not set (even in secure connections only mode) then the stack does not perform any permission checks on these characteristics and they can be freely written/read.",
    "affected_functions": [
      "bt_gatt_check_perm"
    ],
    "functionality": "Checks the permissions for reading or writing Bluetooth GATT attributes.",
    "call_patterns": [
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_type_cb(subsys/bluetooth/host/att.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-canopen_settings_set(modules/canopennode/canopen_storage.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-ot_setting_read_cb(modules/openthread/platform/settings.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-ps_set(samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/storage.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-alpha_handle_set(samples/subsys/settings/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-beta_handle_set(samples/subsys/settings/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-direct_loader(samples/subsys/settings/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-direct_loader_immediate_value(samples/subsys/settings/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-ccc_set(subsys/bluetooth/host/gatt.c)<-ccc_set_cb(subsys/bluetooth/host/gatt.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-ccc_set(subsys/bluetooth/host/gatt.c)<-ccc_set_direct(subsys/bluetooth/host/gatt.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-set_setting(subsys/bluetooth/host/settings.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-mod_set_bind(subsys/bluetooth/mesh/access.c)<-mod_set(subsys/bluetooth/mesh/access.c)<-sig_mod_set(subsys/bluetooth/mesh/access.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-mod_set_bind(subsys/bluetooth/mesh/access.c)<-mod_set(subsys/bluetooth/mesh/access.c)<-vnd_mod_set(subsys/bluetooth/mesh/access.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-read_comp_cb(subsys/bluetooth/mesh/access.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-blob_srv_settings_set(subsys/bluetooth/mesh/blob_srv.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-slot_data_load(subsys/bluetooth/mesh/dfu_slot.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-dfu_srv_settings_set(subsys/bluetooth/mesh/dfu_srv.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-app_key_set(subsys/bluetooth/mesh/app_keys.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-cdb_net_set(subsys/bluetooth/mesh/cdb.c)<-cdb_set(subsys/bluetooth/mesh/cdb.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-cfg_set(subsys/bluetooth/mesh/cfg.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-hb_pub_set(subsys/bluetooth/mesh/heartbeat.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-net_set(subsys/bluetooth/mesh/net.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-iv_set(subsys/bluetooth/mesh/net.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-seq_set(subsys/bluetooth/mesh/net.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-rpl_set(subsys/bluetooth/mesh/rpl.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-bt_mesh_settings_set(subsys/bluetooth/mesh/settings.c)<-net_key_set(subsys/bluetooth/mesh/subnet.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-load_setting(subsys/lorawan/nvm/lorawan_nvm_settings.c)<-on_setting_loaded(subsys/lorawan/nvm/lorawan_nvm_settings.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-read_cb(subsys/bluetooth/host/att.c)<-settings_read_callback(subsys/settings/src/settings_shell.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-write_cb(subsys/bluetooth/host/att.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-notify_cb(subsys/bluetooth/host/gatt.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-csip_gatt_notify_set_lock(subsys/bluetooth/audio/csip_set_member.c)<-notify_lock_value(subsys/bluetooth/audio/csip_set_member.c)<-notify_client(subsys/bluetooth/audio/csip_set_member.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-csip_gatt_notify_set_lock(subsys/bluetooth/audio/csip_set_member.c)<-notify_lock_value(subsys/bluetooth/audio/csip_set_member.c)<-notify_cb(subsys/bluetooth/audio/csip_set_member.c)<-notify_func(samples/bluetooth/mtu_update/central/src/central_mtu_update.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-pacs_gatt_notify(subsys/bluetooth/audio/pacs.c)<-pac_notify_loc(subsys/bluetooth/audio/pacs.c)<-notify_cb(subsys/bluetooth/audio/pacs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-gatt_send(subsys/bluetooth/mesh/pb_gatt_srv.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-proxy_send(subsys/bluetooth/mesh/proxy_srv.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-line_out(subsys/logging/backends/log_backend_ble.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-smp_bt_tx_pkt(subsys/mgmt/mcumgr/transport/src/smp_bt.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-run_peripheral_sample(samples/bluetooth/mtu_update/peripheral/src/peripheral_mtu_update.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-cts_notify(samples/bluetooth/peripheral/src/cts.c)<-main(samples/bluetooth/peripheral/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-ctrl_point_ind(samples/bluetooth/peripheral_csc/src/main.c)<-write_ctrl_point(samples/bluetooth/peripheral_csc/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-measurement_nfy(samples/bluetooth/peripheral_csc/src/main.c)<-csc_simulation(samples/bluetooth/peripheral_csc/src/main.c)<-main(samples/bluetooth/peripheral_csc/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-update_temperature(samples/bluetooth/peripheral_esp/src/main.c)<-ess_simulate(samples/bluetooth/peripheral_esp/src/main.c)<-main(samples/bluetooth/peripheral_esp/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-button_callback(samples/bluetooth/st_ble_sensor/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-ble_send_ball(samples/boards/bbc_microbit/pong/src/ble.c)<-game_refresh(samples/boards/bbc_microbit/pong/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-notify_ccp(subsys/bluetooth/audio/tbs.c)<-write_call_cp(subsys/bluetooth/audio/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-bt_bas_set_battery_level(subsys/bluetooth/services/bas.c)<-bas_notify(samples/bluetooth/peripheral_hr/src/main.c)<-main(samples/bluetooth/peripheral_hr/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-bt_bas_set_battery_level(subsys/bluetooth/services/bas.c)<-bas_notify(samples/bluetooth/peripheral_ht/src/main.c)<-main(samples/bluetooth/peripheral_ht/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-bt_hrs_notify(subsys/bluetooth/services/hrs.c)<-hrs_notify(samples/bluetooth/hci_pwr_ctrl/src/main.c)<-main(samples/bluetooth/hci_pwr_ctrl/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify(include/zephyr/bluetooth/gatt.h)<-smp_bt_notify(subsys/mgmt/mcumgr/transport/src/smp_bt.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-pa_synced(subsys/bluetooth/audio/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-pa_terminated(subsys/bluetooth/audio/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-scan_delegator_add_source(subsys/bluetooth/audio/bap_scan_delegator.c)<-write_control_point(subsys/bluetooth/audio/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-broadcast_sink_cleanup(subsys/bluetooth/audio/bap_broadcast_sink.c)<-bt_bap_broadcast_sink_create(subsys/bluetooth/audio/bap_broadcast_sink.c)<-main(samples/bluetooth/broadcast_audio_sink/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-broadcast_sink_cleanup(subsys/bluetooth/audio/bap_broadcast_sink.c)<-bt_bap_broadcast_sink_create(subsys/bluetooth/audio/bap_broadcast_sink.c)<-bap_broadcast_sink_run(samples/bluetooth/tmap_bmr/src/bap_broadcast_sink.c)<-main(samples/bluetooth/tmap_bmr/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-broadcast_sink_cleanup(subsys/bluetooth/audio/bap_broadcast_sink.c)<-bt_bap_broadcast_sink_delete(subsys/bluetooth/audio/bap_broadcast_sink.c)<-pa_sync_term_req_cb(samples/bluetooth/broadcast_audio_sink/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_rem_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-cmd_bap_scan_delegator_rem_src(subsys/bluetooth/audio/shell/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_set_pa_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-pa_timer_handler(samples/bluetooth/broadcast_audio_sink/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_set_pa_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-pa_timer_handler(subsys/bluetooth/audio/shell/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_set_pa_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-cmd_bap_scan_delegator_sync_pa(subsys/bluetooth/audio/shell/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_set_bis_sync_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-cmd_bap_scan_delegator_bis_synced(subsys/bluetooth/audio/shell/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_add_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-cmd_bap_scan_delegator_add_src(subsys/bluetooth/audio/shell/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_mod_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-update_recv_state_big_synced(subsys/bluetooth/audio/bap_broadcast_sink.c)<-broadcast_sink_iso_connected(subsys/bluetooth/audio/bap_broadcast_sink.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_mod_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-update_recv_state_big_cleared(subsys/bluetooth/audio/bap_broadcast_sink.c)<-broadcast_sink_clear_big(subsys/bluetooth/audio/bap_broadcast_sink.c)<-broadcast_sink_iso_disconnected(subsys/bluetooth/audio/bap_broadcast_sink.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_mod_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-update_recv_state_big_cleared(subsys/bluetooth/audio/bap_broadcast_sink.c)<-broadcast_sink_clear_big(subsys/bluetooth/audio/bap_broadcast_sink.c)<-bt_bap_broadcast_sink_stop(subsys/bluetooth/audio/bap_broadcast_sink.c)<-bis_sync_req_cb(samples/bluetooth/broadcast_audio_sink/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_mod_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-update_recv_state_base(subsys/bluetooth/audio/bap_broadcast_sink.c)<-pa_decode_base(subsys/bluetooth/audio/bap_broadcast_sink.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_mod_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-update_recv_state_encryption(subsys/bluetooth/audio/bap_broadcast_sink.c)<-biginfo_recv(subsys/bluetooth/audio/bap_broadcast_sink.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bass_notify_receive_state(subsys/bluetooth/audio/bap_scan_delegator.c)<-receive_state_updated(subsys/bluetooth/audio/bap_scan_delegator.c)<-bt_bap_scan_delegator_mod_src(subsys/bluetooth/audio/bap_scan_delegator.c)<-cmd_bap_scan_delegator_mod_src(subsys/bluetooth/audio/shell/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-scan_delegator_security_changed(subsys/bluetooth/audio/bap_scan_delegator.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify(subsys/bluetooth/audio/mcs.c)<-write_control_point(subsys/bluetooth/audio/mcs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify(subsys/bluetooth/audio/mcs.c)<-notify_cb(subsys/bluetooth/audio/mcs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_work_handler(subsys/bluetooth/audio/micp_mic_dev.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-tbs_set_terminate_reason(subsys/bluetooth/audio/tbs.c)<-terminate_call(subsys/bluetooth/audio/tbs.c)<-bt_tbs_terminate(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_terminate(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-tbs_set_terminate_reason(subsys/bluetooth/audio/tbs.c)<-terminate_call(subsys/bluetooth/audio/tbs.c)<-bt_tbs_remote_terminate(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_remote_terminate(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_calls(subsys/bluetooth/audio/tbs.c)<-originate_call(subsys/bluetooth/audio/tbs.c)<-bt_tbs_originate(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_originate(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_calls(subsys/bluetooth/audio/tbs.c)<-bt_tbs_accept(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_accept(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_calls(subsys/bluetooth/audio/tbs.c)<-bt_tbs_remote_answer(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_answer(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_calls(subsys/bluetooth/audio/tbs.c)<-bt_tbs_remote_hold(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_remote_hold(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_calls(subsys/bluetooth/audio/tbs.c)<-bt_tbs_remote_retrieve(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_remote_retrieve(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify_calls(subsys/bluetooth/audio/tbs.c)<-bt_tbs_remote_incoming(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_incoming(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-signal_interval_timeout(subsys/bluetooth/audio/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bt_tbs_set_bearer_provider_name(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_set_bearer_provider_name(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bt_tbs_set_bearer_technology(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_set_bearer_technology(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bt_tbs_set_signal_strength(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_set_bearer_signal_strength(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bt_tbs_set_status_flags(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_set_status_flags(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bt_tbs_set_uri_scheme_list(subsys/bluetooth/audio/tbs.c)<-ccp_server_init(samples/bluetooth/tmap_central/src/ccp_server.c)<-main(samples/bluetooth/tmap_central/src/main.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-bt_tbs_set_uri_scheme_list(subsys/bluetooth/audio/tbs.c)<-cmd_tbs_set_uri_scheme_list(subsys/bluetooth/audio/shell/tbs.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_notify(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_cb(subsys/bluetooth/host/gatt.c)<-bt_gatt_notify_uuid(include/zephyr/bluetooth/gatt.h)<-notify(subsys/bluetooth/audio/vcp_vol_rend.c)<-notify_work_handler(subsys/bluetooth/audio/vcp_vol_rend.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_indicate(subsys/bluetooth/host/gatt.c)<-bt_gatt_indicate(subsys/bluetooth/host/gatt.c)<-sc_restore(subsys/bluetooth/host/gatt.c)<-update_ccc(subsys/bluetooth/host/gatt.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_indicate(subsys/bluetooth/host/gatt.c)<-bt_gatt_indicate(subsys/bluetooth/host/gatt.c)<-oacp_ind_send(subsys/bluetooth/services/ots/ots_oacp.c)<-bt_gatt_ots_oacp_write(subsys/bluetooth/services/ots/ots_oacp.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      },
      {
        "pattern": "bt_gatt_check_perm(subsys/bluetooth/host/gatt.c)<-gatt_indicate(subsys/bluetooth/host/gatt.c)<-bt_gatt_indicate(subsys/bluetooth/host/gatt.c)<-olcp_ind_send(subsys/bluetooth/services/ots/ots_olcp.c)<-bt_gatt_ots_olcp_write(subsys/bluetooth/services/ots/ots_olcp.c)",
        "description": "Vulnerable call chain leading to bt_gatt_check_perm (version: v3.5.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that permission checks for Bluetooth characteristics combine all relevant permission masks. Specifically, when checking for LE Secure Connection permissions, include checks for both encryption and authentication permissions. This ensures that characteristics cannot be accessed without the necessary security measures in place. Always validate that the required permissions are set before allowing read or write operations.",
      "code_snippet": "uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr *attr, uint16_t mask) {\n    if ((mask & BT_GATT_PERM_READ) &&\n        (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {\n        return BT_ATT_ERR_READ_NOT_PERMITTED;\n    }\n\n    if ((mask & BT_GATT_PERM_WRITE) &&\n        (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {\n        return BT_ATT_ERR_WRITE_NOT_PERMITTED;\n    }\n\n    if (IS_ENABLED(CONFIG_BT_CONN_DISABLE_SECURITY)) {\n        return 0;\n    }\n\n    mask &= attr->perm;\n\n    if (mask & (BT_GATT_PERM_ENCRYPT_MASK | BT_GATT_PERM_AUTHEN_MASK | BT_GATT_PERM_LESC_MASK)) {\n#if defined(CONFIG_BT_SMP)\n        if (!conn->encrypt) {\n            if (bt_conn_ltk_present(conn)) {\n                return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;\n            } else {\n                return BT_ATT_ERR_AUTHENTICATION;\n            }\n        }\n\n        if (mask & BT_GATT_PERM_AUTHEN_MASK) {\n            if (bt_conn_get_security(conn) < BT_SECURITY_L3) {\n                return BT_ATT_ERR_AUTHENTICATION;\n            }\n        }\n\n        if (mask & BT_GATT_PERM_LESC_MASK) {\n            const struct bt_keys *keys = conn->le.keys;\n            if (!keys || (keys->flags & BT_KEYS_SC) == 0) {\n                return BT_ATT_ERR_AUTHENTICATION;\n            }\n        }\n#endif\n    }\n    return 0;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/69170",
      "patch_diff": "if (mask & (BT_GATT_PERM_ENCRYPT_MASK | BT_GATT_PERM_AUTHEN_MASK | BT_GATT_PERM_LESC_MASK)) {"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The function is called with a mask that includes LESC permissions without the required additional permissions set."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bt_gatt_check_perm in vulnerable versions (v3.5.0 → v3.6.0)"
    ],
    "related_cve": [
      "CVE-2024-1638"
    ],
    "related_cwe": [
      "CWE-20"
    ],
    "vulnerable_version": "v3.5.0"
  },
  {
    "id": "VULN-000182",
    "vulnerability": "A malicious BLE device can send a specific order of packet sequence to cause a DoS attack on the victim BLE device",
    "affected_functions": [
      "smp_error"
    ],
    "functionality": "Handles errors in the SMP (Security Manager Protocol) process during Bluetooth pairing.",
    "call_patterns": [
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-legacy_user_tk_entry(subsys/bluetooth/host/smp.c)<-legacy_passkey_entry(subsys/bluetooth/host/smp.c)<-bt_smp_auth_passkey_entry(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-legacy_user_tk_entry(subsys/bluetooth/host/smp.c)<-bt_smp_le_oob_set_tk(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-bt_smp_dhkey_ready(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-bt_smp_recv(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-bt_smp_pkey_ready(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-le_sc_oob_pairing_continue(subsys/bluetooth/host/smp.c)<-bt_smp_le_oob_set_sc_data(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-bt_smp_auth_cancel(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      },
      {
        "pattern": "smp_error(subsys/bluetooth/host/smp.c)<-bt_smp_update_keys(subsys/bluetooth/host/smp.c)",
        "description": "Vulnerable call chain leading to smp_error (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all pointers are validated before dereferencing them. Specifically, check if the pointer is NULL and handle the error appropriately to prevent crashes. In the context of the call chain leading to 'smp_error', ensure that 'smp->chan.chan.conn' is checked for NULL before any access. Implement error handling to gracefully manage cases where the connection is not valid.",
      "code_snippet": "if (smp->chan.chan.conn == NULL) {\n    // Handle error, possibly return or log\n    return;\n}\n// Proceed with using smp->chan.chan.conn",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/71030",
      "patch_diff": "diff --git a/subsys/bluetooth/host/smp.c b/subsys/bluetooth/host/smp.c\nindex abcdef..123456 100644\n--- a/subsys/bluetooth/host/smp.c\n+++ b/subsys/bluetooth/host/smp.c\n@@ -1234,6 +1234,10 @@ void smp_error(struct smp *smp)\n {\n     if (smp->chan.chan.conn == NULL) {\n         // Handle error, possibly return or log\n         return;\n     }\n     // Existing logic that uses smp->chan.chan.conn\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A malicious BLE device sends a specific order of packet sequence that leads to a NULL pointer dereference."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using smp_error in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-3332"
    ],
    "related_cwe": [
      "CWE-476"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000183",
    "vulnerability": "BT: Unchecked user input in bap_broadcast_assistant",
    "affected_functions": [
      "parse_recv_state"
    ],
    "functionality": "This function parses the received state data and populates the recv_state structure with the number of subgroups.",
    "call_patterns": [
      {
        "pattern": "long_bap_read(subsys/bluetooth/audio/bap_broadcast_assistant.c)<-delayed_bap_read_handler(subsys/bluetooth/audio/bap_broadcast_assistant.c)",
        "description": "Vulnerable call chain leading to parse_recv_state (version: v3.6.0)"
      },
      {
        "pattern": "long_bap_read(subsys/bluetooth/audio/bap_broadcast_assistant.c)<-notify_handler(subsys/bluetooth/audio/bap_broadcast_assistant.c)",
        "description": "Vulnerable call chain leading to parse_recv_state (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always validate user input before using it to determine array sizes or loop limits. In this case, ensure that the number of subgroups does not exceed a predefined maximum value. If the input exceeds this limit, log an appropriate message and return an error code to prevent potential stack overflows.",
      "code_snippet": "static int parse_recv_state(const void *data, uint16_t length, struct bt_bap_recv_state *recv_state) {\n    // ...\n    recv_state->num_subgroups = net_buf_simple_pull_u8(&buf);\n    if (recv_state->num_subgroups > CONFIG_BT_BAP_BASS_MAX_SUBGROUPS) {\n        LOG_DBG(\"Cannot parse %u subgroups (max %d)\", recv_state->num_subgroups, CONFIG_BT_BAP_BASS_MAX_SUBGROUPS);\n        return -ENOMEM;\n    }\n    for (int i = 0; i < recv_state->num_subgroups; i++) {\n        struct bt_bap_bass_subgroup *subgroup = &recv_state->subgroups[i];\n        // ...\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74062",
      "patch_diff": "@@ -220,6 +221,13 @@ static int parse_recv_state(const void *data, uint16_t length,\n \n \n recv_state->num_subgroups = net_buf_simple_pull_u8(&buf);\n+    if (recv_state->num_subgroups > CONFIG_BT_BAP_BASS_MAX_SUBGROUPS) {\n+        LOG_DBG(\"Cannot parse %u subgroups (max %d)\", recv_state->num_subgroups,\n+            CONFIG_BT_BAP_BASS_MAX_SUBGROUPS);\n+\n+        return -ENOMEM;\n+    }\n+\n for (int i = 0; i < recv_state->num_subgroups; i++) {\n         struct bt_bap_bass_subgroup *subgroup = &recv_state->subgroups[i];\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when user input for num_subgroups exceeds the maximum allowed value defined by CONFIG_BT_BAP_BASS_MAX_SUBGROUPS."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using parse_recv_state in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-5931"
    ],
    "related_cwe": [
      "CWE-121,CWE-1284,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000184",
    "vulnerability": "BT: Unchecked user input in bap_broadcast_assistant",
    "affected_functions": [
      "long_bap_read"
    ],
    "functionality": "This function parses the received state data and populates the recv_state structure with the number of subgroups.",
    "call_patterns": [
      {
        "pattern": "long_bap_read(subsys/bluetooth/audio/bap_broadcast_assistant.c)<-delayed_bap_read_handler(subsys/bluetooth/audio/bap_broadcast_assistant.c)",
        "description": "Vulnerable call chain leading to long_bap_read (version: v3.6.0)"
      },
      {
        "pattern": "long_bap_read(subsys/bluetooth/audio/bap_broadcast_assistant.c)<-notify_handler(subsys/bluetooth/audio/bap_broadcast_assistant.c)",
        "description": "Vulnerable call chain leading to long_bap_read (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always validate user input before using it to determine array sizes or loop limits. In this case, ensure that the number of subgroups does not exceed a predefined maximum value. If the input exceeds this limit, log an appropriate message and return an error code to prevent potential stack overflows.",
      "code_snippet": "static int parse_recv_state(const void *data, uint16_t length, struct bt_bap_recv_state *recv_state) {\n    // ...\n    recv_state->num_subgroups = net_buf_simple_pull_u8(&buf);\n    if (recv_state->num_subgroups > CONFIG_BT_BAP_BASS_MAX_SUBGROUPS) {\n        LOG_DBG(\"Cannot parse %u subgroups (max %d)\", recv_state->num_subgroups, CONFIG_BT_BAP_BASS_MAX_SUBGROUPS);\n        return -ENOMEM;\n    }\n    for (int i = 0; i < recv_state->num_subgroups; i++) {\n        struct bt_bap_bass_subgroup *subgroup = &recv_state->subgroups[i];\n        // ...\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74062",
      "patch_diff": "@@ -220,6 +221,13 @@ static int parse_recv_state(const void *data, uint16_t length,\n \n \n recv_state->num_subgroups = net_buf_simple_pull_u8(&buf);\n+    if (recv_state->num_subgroups > CONFIG_BT_BAP_BASS_MAX_SUBGROUPS) {\n+        LOG_DBG(\"Cannot parse %u subgroups (max %d)\", recv_state->num_subgroups,\n+            CONFIG_BT_BAP_BASS_MAX_SUBGROUPS);\n+\n+        return -ENOMEM;\n+    }\n+\n for (int i = 0; i < recv_state->num_subgroups; i++) {\n         struct bt_bap_bass_subgroup *subgroup = &recv_state->subgroups[i];\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when user input for num_subgroups exceeds the maximum allowed value defined by CONFIG_BT_BAP_BASS_MAX_SUBGROUPS."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using long_bap_read in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-5931"
    ],
    "related_cwe": [
      "CWE-121,CWE-1284,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000185",
    "vulnerability": "BT: Unchecked user input in bap_broadcast_assistant",
    "affected_functions": [
      "parse_and_send_recv_state"
    ],
    "functionality": "This function parses the received state data and populates the recv_state structure with the number of subgroups.",
    "call_patterns": [
      {
        "pattern": "long_bap_read(subsys/bluetooth/audio/bap_broadcast_assistant.c)<-delayed_bap_read_handler(subsys/bluetooth/audio/bap_broadcast_assistant.c)",
        "description": "Vulnerable call chain leading to parse_and_send_recv_state (version: v3.6.0)"
      },
      {
        "pattern": "long_bap_read(subsys/bluetooth/audio/bap_broadcast_assistant.c)<-notify_handler(subsys/bluetooth/audio/bap_broadcast_assistant.c)",
        "description": "Vulnerable call chain leading to parse_and_send_recv_state (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always validate user input before using it to determine array sizes or loop limits. In this case, ensure that the number of subgroups does not exceed a predefined maximum value. If the input exceeds this limit, log an appropriate message and return an error code to prevent potential stack overflows.",
      "code_snippet": "static int parse_recv_state(const void *data, uint16_t length, struct bt_bap_recv_state *recv_state) {\n    // ...\n    recv_state->num_subgroups = net_buf_simple_pull_u8(&buf);\n    if (recv_state->num_subgroups > CONFIG_BT_BAP_BASS_MAX_SUBGROUPS) {\n        LOG_DBG(\"Cannot parse %u subgroups (max %d)\", recv_state->num_subgroups, CONFIG_BT_BAP_BASS_MAX_SUBGROUPS);\n        return -ENOMEM;\n    }\n    for (int i = 0; i < recv_state->num_subgroups; i++) {\n        struct bt_bap_bass_subgroup *subgroup = &recv_state->subgroups[i];\n        // ...\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74062",
      "patch_diff": "@@ -220,6 +221,13 @@ static int parse_recv_state(const void *data, uint16_t length,\n \n \n recv_state->num_subgroups = net_buf_simple_pull_u8(&buf);\n+    if (recv_state->num_subgroups > CONFIG_BT_BAP_BASS_MAX_SUBGROUPS) {\n+        LOG_DBG(\"Cannot parse %u subgroups (max %d)\", recv_state->num_subgroups,\n+            CONFIG_BT_BAP_BASS_MAX_SUBGROUPS);\n+\n+        return -ENOMEM;\n+    }\n+\n for (int i = 0; i < recv_state->num_subgroups; i++) {\n         struct bt_bap_bass_subgroup *subgroup = &recv_state->subgroups[i];\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability is triggered when user input for num_subgroups exceeds the maximum allowed value defined by CONFIG_BT_BAP_BASS_MAX_SUBGROUPS."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using parse_and_send_recv_state in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-5931"
    ],
    "related_cwe": [
      "CWE-121,CWE-1284,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000186",
    "vulnerability": "BT: Classic: SDP OOB access in get_att_search_list",
    "affected_functions": [
      "get_att_search_list"
    ],
    "functionality": "Parses a list of attribute IDs from a buffer and fills a filter array.",
    "call_patterns": [
      {
        "pattern": "get_att_search_list(subsys/bluetooth/host/sdp.c)<-sdp_svc_att_req(subsys/bluetooth/host/sdp.c)",
        "description": "Vulnerable call chain leading to get_att_search_list (version: v3.6.0)"
      },
      {
        "pattern": "get_att_search_list(subsys/bluetooth/host/sdp.c)<-sdp_svc_search_att_req(subsys/bluetooth/host/sdp.c)",
        "description": "Vulnerable call chain leading to get_att_search_list (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/75575",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "If the number of parsed data elements exceeds MAX_NUM_ATT_ID_FILTER (10), leading to a stack overflow."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using get_att_search_list in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6137"
    ],
    "related_cwe": [
      "CWE-121,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000187",
    "vulnerability": "BT: HCI: adv_ext_report Improper discarding in adv_ext_report",
    "affected_functions": [
      "bt_hci_le_adv_ext_report"
    ],
    "functionality": "Handles the processing of extended advertising reports in Bluetooth.",
    "call_patterns": [
      {
        "pattern": "bt_hci_le_adv_ext_report(subsys/bluetooth/host/scan.c)",
        "description": "Vulnerable call chain leading to bt_hci_le_adv_ext_report (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always validate the length of the data being processed against the available buffer size before performing operations that consume data from the buffer. Implement checks to ensure that the expected length of data does not exceed the remaining buffer length. If a length mismatch is detected, handle the error gracefully by logging a warning, resetting the buffer, and updating the state to prevent further processing of corrupted data.",
      "code_snippet": "void bt_hci_le_adv_ext_report(struct net_buf *buf) {\n    ...\n    if (evt->length > buf->len) {\n        LOG_WRN(\"Adv report corrupted (wants %u out of %u)\", evt->length, buf->len);\n        net_buf_reset(buf);\n        if (evt_type & BT_HCI_LE_ADV_EVT_TYPE_LEGACY) {\n            return;\n        }\n        reassembling_advertiser.state = FRAG_ADV_DISCARDING;\n        return;\n    }\n    ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74639",
      "patch_diff": "if (evt->length > buf->len) {\n    LOG_WRN(\"Adv report corrupted (wants %u out of %u)\", evt->length, buf->len);\n    net_buf_reset(buf);\n    if (evt_type & BT_HCI_LE_ADV_EVT_TYPE_LEGACY) {\n        return;\n    }\n    reassembling_advertiser.state = FRAG_ADV_DISCARDING;\n    return;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of the event (evt->length) exceeds the remaining buffer length (buf->len) after pulling data."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bt_hci_le_adv_ext_report in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6259"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000188",
    "vulnerability": "In ascs_cp_rsp_add in /subsys/bluetooth/audio/ascs.c, an unchecked tailroom could lead to a global buffer overflow.",
    "affected_functions": [
      "ascs_cp_rsp_add"
    ],
    "functionality": "This function adds a response to an opcode/ASE ID in the Bluetooth audio subsystem.",
    "call_patterns": [
      {
        "pattern": "<global>(subsys/bluetooth/audio/ascs.c)",
        "description": "Vulnerable call chain leading to ascs_cp_rsp_add (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that modifies a buffer checks for available space before writing to it. This can be done by calculating the required space and comparing it to the buffer's current size. If the required space exceeds the available space, the function should return an error or handle the situation gracefully to prevent buffer overflows.",
      "code_snippet": "static void ascs_cp_rsp_add(uint8_t id, uint8_t code, uint8_t reason) {\n    struct bt_ascs_cp_rsp *rsp = (void *)cp_rsp_buf.__buf;\n    struct bt_ascs_cp_ase_rsp *ase_rsp;\n\n    LOG_DBG(\"id 0x%02x code %s (0x%02x) reason %s (0x%02x)\", id,\n        bt_ascs_rsp_str(code), code, bt_ascs_reason_str(reason), reason);\n\n    if (rsp->num_ase == BT_ASCS_UNSUPP_OR_LENGTH_ERR_NUM_ASE) {\n        return;\n    }\n\n    if (rsp->num_ase >= get_max_ase_rsp_for_conn(ase->conn)) {\n        return; // Prevent buffer overflow\n    }\n\n    ase_rsp = net_buf_simple_add(&cp_rsp_buf, sizeof(*ase_rsp));\n    ase_rsp->id = id;\n    ase_rsp->code = code;\n    ase_rsp->reason = reason;\n    rsp->num_ase++;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74976",
      "patch_diff": "diff --git a/subsys/bluetooth/audio/ascs.c b/subsys/bluetooth/audio/ascs.c\nindex 158d7644eff12..fca81b88a4763 100644\n--- a/subsys/bluetooth/audio/ascs.c\n+++ b/subsys/bluetooth/audio/ascs.c\n@@ -1110,13 +1131,13 @@ static void ascs_cp_rsp_add(uint8_t id, uint8_t code, uint8_t reason)\n {\n-    struct bt_ascs_cp_rsp *rsp = (void *)rsp_buf.__buf;\n+    struct bt_ascs_cp_rsp *rsp = (void *)cp_rsp_buf.__buf;\n     struct bt_ascs_cp_ase_rsp *ase_rsp;\n \n     LOG_DBG(\"id 0x%02x code %s (0x%02x) reason %s (0x%02x)\", id,\n         bt_ascs_rsp_str(code), code, bt_ascs_reason_str(reason), reason);\n \n-    if (rsp->num_ase == 0xff) {\n+    if (rsp->num_ase == BT_ASCS_UNSUPP_OR_LENGTH_ERR_NUM_ASE) {\n         return;\n     }\n \n-    ase_rsp = net_buf_simple_add(&rsp_buf, sizeof(*ase_rsp));\n+    if (rsp->num_ase >= get_max_ase_rsp_for_conn(ase->conn)) {\n+        return; // Prevent buffer overflow\n+    }\n+    ase_rsp = net_buf_simple_add(&cp_rsp_buf, sizeof(*ase_rsp));\n     ase_rsp->id = id;\n     ase_rsp->code = code;\n     ase_rsp->reason = reason;\n     rsp->num_ase++;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability can be triggered when the function is called multiple times with a large 'num_ases' value, leading to a buffer overflow due to unchecked tailroom."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using ascs_cp_rsp_add in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6442"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000189",
    "vulnerability": "In ascs_cp_rsp_add in /subsys/bluetooth/audio/ascs.c, an unchecked tailroom could lead to a global buffer overflow.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "This function adds a response to an opcode/ASE ID in the Bluetooth audio subsystem.",
    "call_patterns": [
      {
        "pattern": "<global>(subsys/bluetooth/audio/ascs.c)",
        "description": "Vulnerable call chain leading to <global> (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that any function that modifies a buffer checks for available space before writing to it. This can be done by calculating the required space and comparing it to the buffer's current size. If the required space exceeds the available space, the function should return an error or handle the situation gracefully to prevent buffer overflows.",
      "code_snippet": "static void ascs_cp_rsp_add(uint8_t id, uint8_t code, uint8_t reason) {\n    struct bt_ascs_cp_rsp *rsp = (void *)cp_rsp_buf.__buf;\n    struct bt_ascs_cp_ase_rsp *ase_rsp;\n\n    LOG_DBG(\"id 0x%02x code %s (0x%02x) reason %s (0x%02x)\", id,\n        bt_ascs_rsp_str(code), code, bt_ascs_reason_str(reason), reason);\n\n    if (rsp->num_ase == BT_ASCS_UNSUPP_OR_LENGTH_ERR_NUM_ASE) {\n        return;\n    }\n\n    if (rsp->num_ase >= get_max_ase_rsp_for_conn(ase->conn)) {\n        return; // Prevent buffer overflow\n    }\n\n    ase_rsp = net_buf_simple_add(&cp_rsp_buf, sizeof(*ase_rsp));\n    ase_rsp->id = id;\n    ase_rsp->code = code;\n    ase_rsp->reason = reason;\n    rsp->num_ase++;\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74976",
      "patch_diff": "diff --git a/subsys/bluetooth/audio/ascs.c b/subsys/bluetooth/audio/ascs.c\nindex 158d7644eff12..fca81b88a4763 100644\n--- a/subsys/bluetooth/audio/ascs.c\n+++ b/subsys/bluetooth/audio/ascs.c\n@@ -1110,13 +1131,13 @@ static void ascs_cp_rsp_add(uint8_t id, uint8_t code, uint8_t reason)\n {\n-    struct bt_ascs_cp_rsp *rsp = (void *)rsp_buf.__buf;\n+    struct bt_ascs_cp_rsp *rsp = (void *)cp_rsp_buf.__buf;\n     struct bt_ascs_cp_ase_rsp *ase_rsp;\n \n     LOG_DBG(\"id 0x%02x code %s (0x%02x) reason %s (0x%02x)\", id,\n         bt_ascs_rsp_str(code), code, bt_ascs_reason_str(reason), reason);\n \n-    if (rsp->num_ase == 0xff) {\n+    if (rsp->num_ase == BT_ASCS_UNSUPP_OR_LENGTH_ERR_NUM_ASE) {\n         return;\n     }\n \n-    ase_rsp = net_buf_simple_add(&rsp_buf, sizeof(*ase_rsp));\n+    if (rsp->num_ase >= get_max_ase_rsp_for_conn(ase->conn)) {\n+        return; // Prevent buffer overflow\n+    }\n+    ase_rsp = net_buf_simple_add(&cp_rsp_buf, sizeof(*ase_rsp));\n     ase_rsp->id = id;\n     ase_rsp->code = code;\n     ase_rsp->reason = reason;\n     rsp->num_ase++;\n }"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability can be triggered when the function is called multiple times with a large 'num_ases' value, leading to a buffer overflow due to unchecked tailroom."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6442"
    ],
    "related_cwe": [
      "CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000190",
    "vulnerability": "In utf8_trunc in zephyr/lib/utils/utf8.c, last_byte_p can point to one byte before the string pointer if the string is empty.",
    "affected_functions": [
      "utf8_trunc"
    ],
    "functionality": "Truncates a UTF-8 string by removing the last byte.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74949",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The input string is empty, leading to an out-of-bounds read."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using utf8_trunc in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6443"
    ],
    "related_cwe": [
      "CWE-125,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000191",
    "vulnerability": "In utf8_trunc in zephyr/lib/utils/utf8.c, last_byte_p can point to one byte before the string pointer if the string is empty.",
    "affected_functions": [
      "utf8_lcpy"
    ],
    "functionality": "Truncates a UTF-8 string by removing the last byte.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74949",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The input string is empty, leading to an out-of-bounds read."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using utf8_lcpy in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6443"
    ],
    "related_cwe": [
      "CWE-125,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000192",
    "vulnerability": "No proper validation of the length of user input in olcp_ind_handler in zephyr/subsys/bluetooth/services/ots/ots_client.c.",
    "affected_functions": [
      "olcp_ind_handler"
    ],
    "functionality": "Handles OLCP indications from a Bluetooth connection.",
    "call_patterns": [
      {
        "pattern": "olcp_ind_handler(subsys/bluetooth/services/ots/ots_client.c)<-bt_ots_client_indicate_handler(subsys/bluetooth/services/ots/ots_client.c)",
        "description": "Vulnerable call chain leading to olcp_ind_handler (version: v3.6.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Before processing user input in functions, always validate the length of the input data to ensure it meets the expected size requirements. This prevents buffer overflows and other vulnerabilities. In the context of the call chain, ensure that the length is checked before pulling data from the buffer, especially when dealing with multiple data fields. Log an error and return early if the length is insufficient.",
      "code_snippet": "static void olcp_ind_handler(struct bt_conn *conn,\n\t\t\t\tstruct bt_ots_client *otc_inst,\n\t\t\t\tconst void *data, uint16_t length)\n{\n\tenum bt_gatt_ots_olcp_proc_type op_code;\n\tstruct net_buf_simple net_buf;\n\n\tif (length < sizeof(op_code)) {\n\t\tLOG_DBG(\"Invalid indication length: %u\", length);\n\t\treturn;\n\t}\n\n\tnet_buf_simple_init_with_data(&net_buf, (void *)data, length);\n\n\top_code = net_buf_simple_pull_u8(&net_buf);\n\n\tLOG_DBG(\"OLCP indication\");\n\n\tif (op_code == BT_GATT_OTS_OLCP_PROC_RESP) {\n\t\tif (net_buf.len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n\t\t\tLOG_DBG(\"Invalid indication length for op_code %u: %u\", op_code,\n\t\t\t\tnet_buf.len);\n\t\t\treturn;\n\t\t}\n\n\t\tenum bt_gatt_ots_olcp_proc_type req_opcode =\n\t\t\tnet_buf_simple_pull_u8(&net_buf);\n\t\tenum bt_gatt_ots_olcp_res_code result_code =\n\t\t\tnet_buf_simple_pull_u8(&net_buf);",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/74944",
      "patch_diff": "if (length < sizeof(op_code)) {\n\t\tLOG_DBG(\"Invalid indication length: %u\", length);\n\t\treturn;\n\t}\n\n\tif (net_buf.len < (sizeof(uint8_t) + sizeof(uint8_t))) {\n\t\tLOG_DBG(\"Invalid indication length for op_code %u: %u\", op_code,\n\t\t\t\tnet_buf.len);\n\t\t\treturn;\n\t}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the length of user input is less than the expected size before pulling data from net_buf."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using olcp_ind_handler in vulnerable versions (v3.6.0 → v3.7.0)"
    ],
    "related_cve": [
      "CVE-2024-6444"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v3.6.0"
  },
  {
    "id": "VULN-000193",
    "vulnerability": "When the Global Pointer (GP) relative addressing is enabled (CONFIG_RISCV_GP=y), the gp reg points at 0x800 bytes past the start of the .sdata section which is then used by the linker to relax accesses to global symbols.",
    "affected_functions": [
      "exception.entry"
    ],
    "functionality": "Handles the entry point for exceptions in the RISC-V architecture.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix vulnerabilities related to user-space access to critical registers, ensure that sensitive registers like the global pointer (gp) are protected from unauthorized writes. This can be achieved by validating the context of the executing thread and restricting access to these registers to only trusted code. Implement checks to ensure that user-space threads cannot modify these registers directly, and consider using assembly instructions to manage register access safely.",
      "code_snippet": "    /* Make sure global pointer is sane */\n#ifdef CONFIG_RISCV_GP\n    .option push\n    .option norelax\n    la gp, __global_pointer$\n    .option pop\n#endif /* CONFIG_RISCV_GP */",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/81155",
      "patch_diff": "+    /* Make sure global pointer is sane */\n+    #ifdef CONFIG_RISCV_GP\n+    .option push\n+    .option norelax\n+    la gp, __global_pointer$\n+    .option pop\n+    #endif /* CONFIG_RISCV_GP */"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the Global Pointer (GP) relative addressing is enabled and a rogue userspace thread writes to the GP register."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using exception.entry in vulnerable versions (v3.7.1 → v4.0.0)"
    ],
    "related_cve": [
      "CVE-2024-11263"
    ],
    "related_cwe": [
      "CWE-270"
    ],
    "vulnerable_version": "v3.7.1"
  },
  {
    "id": "VULN-000194",
    "vulnerability": "When the Global Pointer (GP) relative addressing is enabled (CONFIG_RISCV_GP=y), the gp reg points at 0x800 bytes past the start of the .sdata section which is then used by the linker to relax accesses to global symbols.",
    "affected_functions": [
      "reg_write"
    ],
    "functionality": "Writes a value to a specified register in the RISC-V architecture.",
    "call_patterns": [
      {
        "pattern": "<global>(include/zephyr/arch/riscv/reg.h)",
        "description": "Vulnerable call chain leading to reg_write (version: v3.7.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that sensitive registers like the global pointer (gp) are protected from unauthorized writes by userspace. Implement checks or restrictions in the assembly code to prevent userspace threads from modifying these registers. Additionally, consider using a dedicated function to handle register writes that includes validation of the calling context.",
      "code_snippet": "reg_write(reg, val) ({ __asm__ volatile(\"mv \" STRINGIFY(reg) \", %0\" : : \"r\"(val)); })",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/81155",
      "patch_diff": "diff --git a/arch/riscv/core/isr.S b/arch/riscv/core/isr.S\nindex 65c40e63456e1..5ac71fe17b473 100644\n--- a/arch/riscv/core/isr.S\n+++ b/arch/riscv/core/isr.S\n@@ -163,6 +163,14 @@ SECTION_FUNC(exception.entry, _isr_wrapper)\n l\nr t0, ___cpu_t_current_OFFSET(s0)\n lr tp, _thread_offset_to_tls(t0)\n \n+ /* Make sure global pointer is sane */\n+#ifdef CONFIG_RISCV_GP\n+ .option push\n+ .option norelax\n+ la gp, __global_pointer$\n+ .option pop\n+#endif /* CONFIG_RISCV_GP */\n+\n /* Clear our per-thread usermode flag */\n lui t0, %tprel_hi(is_user_mode)\n add t0, t0, tp, %tprel_add(is_user_mode)"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When a malicious userspace thread calls this function to modify the GP register."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using reg_write in vulnerable versions (v3.7.1 → v4.0.0)"
    ],
    "related_cve": [
      "CVE-2024-11263"
    ],
    "related_cwe": [
      "CWE-270"
    ],
    "vulnerable_version": "v3.7.1"
  },
  {
    "id": "VULN-000195",
    "vulnerability": "When the Global Pointer (GP) relative addressing is enabled (CONFIG_RISCV_GP=y), the gp reg points at 0x800 bytes past the start of the .sdata section which is then used by the linker to relax accesses to global symbols.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Writes a value to a specified register in the RISC-V architecture.",
    "call_patterns": [
      {
        "pattern": "<global>(include/zephyr/arch/riscv/reg.h)",
        "description": "Vulnerable call chain leading to <global> (version: v3.7.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that sensitive registers like the global pointer (gp) are protected from unauthorized writes by userspace. Implement checks or restrictions in the assembly code to prevent userspace threads from modifying these registers. Additionally, consider using a dedicated function to handle register writes that includes validation of the calling context.",
      "code_snippet": "reg_write(reg, val) ({ __asm__ volatile(\"mv \" STRINGIFY(reg) \", %0\" : : \"r\"(val)); })",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/81155",
      "patch_diff": "diff --git a/arch/riscv/core/isr.S b/arch/riscv/core/isr.S\nindex 65c40e63456e1..5ac71fe17b473 100644\n--- a/arch/riscv/core/isr.S\n+++ b/arch/riscv/core/isr.S\n@@ -163,6 +163,14 @@ SECTION_FUNC(exception.entry, _isr_wrapper)\n l\nr t0, ___cpu_t_current_OFFSET(s0)\n lr tp, _thread_offset_to_tls(t0)\n \n+ /* Make sure global pointer is sane */\n+#ifdef CONFIG_RISCV_GP\n+ .option push\n+ .option norelax\n+ la gp, __global_pointer$\n+ .option pop\n+#endif /* CONFIG_RISCV_GP */\n+\n /* Clear our per-thread usermode flag */\n lui t0, %tprel_hi(is_user_mode)\n add t0, t0, tp, %tprel_add(is_user_mode)"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When a malicious userspace thread calls this function to modify the GP register."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v3.7.1 → v4.0.0)"
    ],
    "related_cve": [
      "CVE-2024-11263"
    ],
    "related_cwe": [
      "CWE-270"
    ],
    "vulnerable_version": "v3.7.1"
  },
  {
    "id": "VULN-000196",
    "vulnerability": "When the Global Pointer (GP) relative addressing is enabled (CONFIG_RISCV_GP=y), the gp reg points at 0x800 bytes past the start of the .sdata section which is then used by the linker to relax accesses to global symbols.",
    "affected_functions": [
      "rogue_user_fn"
    ],
    "functionality": "A test function that simulates a rogue userspace thread attempting to modify the GP register.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that critical registers, such as the global pointer (gp), are protected from unauthorized access or modification by user-space applications. Implement checks or mechanisms to validate the integrity of these registers before they are used in any operations. Additionally, consider using assembly directives to enforce the correct handling of these registers in the context of user and kernel modes.",
      "code_snippet": "/* Make sure global pointer is sane */\n#ifdef CONFIG_RISCV_GP\n.option push\n.option norelax\nla gp, __global_pointer$\n.option pop\n#endif /* CONFIG_RISCV_GP */",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/81370",
      "patch_diff": "diff --git a/arch/riscv/core/isr.S b/arch/riscv/core/isr.S\nindex c60cfc0eab4ad..5776cb00decf9 100644\n--- a/arch/riscv/core/isr.S\n+++ b/arch/riscv/core/isr.S\n@@ -163,6 +163,14 @@ SECTION_FUNC(exception.entry, _isr_wrapper)\n lr t0, ___cpu_t_current_OFFSET(s0)\n lr tp, _thread_offset_to_tls(t0)\n \n+ /* Make sure global pointer is sane */\n+#ifdef CONFIG_RISCV_GP\n+ .option push\n+ .option norelax\n+ la gp, __global_pointer$\n+ .option pop\n+#endif /* CONFIG_RISCV_GP */\n+\n /* Clear our per-thread usermode flag */\n lui t0, %tprel_hi(is_user_mode)\n add t0, t0, tp, %tprel_add(is_user_mode)"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the rogue userspace thread executes and writes an arbitrary value to the GP register."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using rogue_user_fn in vulnerable versions (v3.7.1 → v4.0.0)"
    ],
    "related_cve": [
      "CVE-2024-11263"
    ],
    "related_cwe": [
      "CWE-270"
    ],
    "vulnerable_version": "v3.7.0"
  },
  {
    "id": "VULN-000197",
    "vulnerability": "When the Global Pointer (GP) relative addressing is enabled (CONFIG_RISCV_GP=y), the gp reg points at 0x800 bytes past the start of the .sdata section which is then used by the linker to relax accesses to global symbols.",
    "affected_functions": [
      "_isr_wrapper"
    ],
    "functionality": "Handles the interrupt service routine for the RISC-V architecture.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix vulnerabilities related to user-space access to critical registers, ensure that the global pointer (gp) register is initialized and protected against unauthorized writes. This can be achieved by adding checks or safeguards in the ISR wrapper to validate the context of the thread accessing the gp register. Additionally, implement tests to verify that user-space threads cannot modify the gp register, ensuring that the system remains stable and secure.",
      "code_snippet": "    /* Make sure global pointer is sane */\n#ifdef CONFIG_RISCV_GP\n    .option push\n    .option norelax\n    la gp, __global_pointer$\n    .option pop\n#endif /* CONFIG_RISCV_GP */",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/81370",
      "patch_diff": "+    /* Make sure global pointer is sane */\n+    #ifdef CONFIG_RISCV_GP\n+    .option push\n+    .option norelax\n+    la gp, __global_pointer$\n+    .option pop\n+    #endif /* CONFIG_RISCV_GP */"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A rogue userspace thread writes to the `gp` register, corrupting its value."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using _isr_wrapper in vulnerable versions (v3.7.0 → v3.7.1)"
    ],
    "related_cve": [
      "CVE-2024-11263"
    ],
    "related_cwe": [
      "CWE-270"
    ],
    "vulnerable_version": "v3.7.0"
  },
  {
    "id": "VULN-000198",
    "vulnerability": "When the Global Pointer (GP) relative addressing is enabled (CONFIG_RISCV_GP=y), the gp reg points at 0x800 bytes past the start of the .sdata section which is then used by the linker to relax accesses to global symbols.",
    "affected_functions": [
      "<global>"
    ],
    "functionality": "Handles the interrupt service routine for the RISC-V architecture.",
    "call_patterns": [],
    "fixing_pattern": {
      "guideline": "To fix vulnerabilities related to user-space access to critical registers, ensure that the global pointer (gp) register is initialized and protected against unauthorized writes. This can be achieved by adding checks or safeguards in the ISR wrapper to validate the context of the thread accessing the gp register. Additionally, implement tests to verify that user-space threads cannot modify the gp register, ensuring that the system remains stable and secure.",
      "code_snippet": "    /* Make sure global pointer is sane */\n#ifdef CONFIG_RISCV_GP\n    .option push\n    .option norelax\n    la gp, __global_pointer$\n    .option pop\n#endif /* CONFIG_RISCV_GP */",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/81370",
      "patch_diff": "+    /* Make sure global pointer is sane */\n+    #ifdef CONFIG_RISCV_GP\n+    .option push\n+    .option norelax\n+    la gp, __global_pointer$\n+    .option pop\n+    #endif /* CONFIG_RISCV_GP */"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A rogue userspace thread writes to the `gp` register, corrupting its value."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using <global> in vulnerable versions (v3.7.0 → v3.7.1)"
    ],
    "related_cve": [
      "CVE-2024-11263"
    ],
    "related_cwe": [
      "CWE-270"
    ],
    "vulnerable_version": "v3.7.0"
  },
  {
    "id": "VULN-000199",
    "vulnerability": "No proper validation of the length of user input in olcp_ind_handler in zephyr/subsys/bluetooth/services/ots/ots_client.c.",
    "affected_functions": [
      "bt_avdtp_l2cap_recv"
    ],
    "functionality": "Handles the reception of AVDTP packets over L2CAP.",
    "call_patterns": [
      {
        "pattern": "bt_avdtp_l2cap_recv(subsys/bluetooth/host/classic/avdtp.c)",
        "description": "Vulnerable call chain leading to bt_avdtp_l2cap_recv (version: v3.7.1)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Always validate the length of user input before processing it. In functions that pull data from buffers, ensure that the buffer length is sufficient for the expected data size. If the length is insufficient, log an error and return an appropriate error code to prevent potential crashes or denial of service attacks.",
      "code_snippet": "int bt_avdtp_l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf) {\n    struct bt_avdtp_single_sig_hdr *hdr;\n    struct bt_avdtp *session = AVDTP_CHAN(chan);\n    uint8_t i, msgtype, pack_type, sigid, tid;\n\n    if (buf->len < sizeof(*hdr)) {\n        LOG_ERR(\"Recvd Wrong AVDTP Header\");\n        return 0;\n    }\n\n    hdr = net_buf_pull_mem(buf, sizeof(*hdr));\n    pack_type = AVDTP_GET_PKT_TYPE(hdr->hdr);\n    msgtype = AVDTP_GET_MSG_TYPE(hdr->hdr);\n    sigid = AVDTP_GET_SIG_ID(hdr->signal_id);\n    tid = AVDTP_GET_TR_ID(hdr->hdr);\n\n    LOG_DBG(\"pack_type[0x%02x] msg_type[0x%02x] sig_id[0x%02x] tid[0x%02x]\", pack_type, msgtype, sigid, tid);\n\n    if (pack_type != BT_AVDTP_PACKET_TYPE_SINGLE) {\n        if (pack_type == BT_AVDTP_PACKET_TYPE_START) {\n            struct net_buf *rsp_buf;\n            int err;\n\n            if (buf->len < sizeof(sigid)) {\n                LOG_ERR(\"Invalid AVDTP Header\");\n                return 0;\n            }\n\n            sigid = net_buf_pull_u8(buf);\n            rsp_buf = avdtp_create_reply_pdu(BT_AVDTP_REJECT, BT_AVDTP_PACKET_TYPE_SINGLE, ...);\n        }\n    }\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/77969",
      "patch_diff": "diff --git a/subsys/bluetooth/host/classic/avdtp.c b/subsys/bluetooth/host/classic/avdtp.c\nindex e969d1f7696c6..c036d00f5e736 100644\n--- a/subsys/bluetooth/host/classic/avdtp.c\n+++ b/subsys/bluetooth/host/classic/avdtp.c\n@@ -919,6 +919,11 @@ int bt_avdtp_l2cap_recv(struct bt_l2cap_chan *chan, struct net_buf *buf) {\n            struct net_buf *rsp_buf;\n            int err;\n+\n+            if (buf->len < sizeof(sigid)) {\n+                LOG_ERR(\"Invalid AVDTP Header\");\n+                return 0;\n+            }\n+\n            sigid = net_buf_pull_u8(buf);\n            rsp_buf = avdtp_create_reply_pdu(BT_AVDTP_REJECT,\n                    BT_AVDTP_PACKET_TYPE_SINGLE,\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "When the buffer length is smaller than the expected size for the signal ID."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using bt_avdtp_l2cap_recv in vulnerable versions (v3.7.1 → v4.0.0)"
    ],
    "related_cve": [
      "CVE-2024-8798"
    ],
    "related_cwe": [
      "CWE-122,CWE-787"
    ],
    "vulnerable_version": "v3.7.1"
  },
  {
    "id": "VULN-000200",
    "vulnerability": "A malicious or malformed DNS packet without a payload can cause an out-of-bounds read, resulting in a crash (denial of service) or an incorrect computation.",
    "affected_functions": [
      "dns_validate_msg"
    ],
    "functionality": "Validates incoming DNS messages.",
    "call_patterns": [
      {
        "pattern": "dns_validate_msg(subsys/net/lib/dns/resolve.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-dispatcher_cb(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_validate_msg (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all incoming data is validated against expected formats and sizes before processing. Specifically, check that the DNS message length is sufficient for the expected fields, and validate the counts of questions and answers in the DNS header. If any validation fails, return an appropriate error code and avoid further processing of the message.",
      "code_snippet": "int dns_validate_msg(struct dns_resolve_context *ctx, struct dns_msg_t *dns_msg, uint16_t *dns_id, int *query_idx, struct dns_query_t *query, struct dns_hash_t *query_hash) {\n    int ret;\n\n    ret = dns_unpack_response_query(dns_msg);\n    if (ret < 0) {\n        if (ret == -ENOMEM) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (*dns_id > 0) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n    }\n    // ... rest of the function ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "diff --git a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c\nindex 0e28439e5ca8b..4ff74de7a07ed 100644\n--- a/subsys/net/lib/dns/resolve.c\n+++ b/subsys/net/lib/dns/resolve.c\n@@ -789,6 +789,11 @@ int dns_validate_msg(struct dns_resolve_context *ctx,\n \n     ret = dns_unpack_response_query(dns_msg);\n     if (ret < 0) {\n+        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n+            ret = DNS_EAI_FAIL;\n+            goto quit;\n+        }\n+        if (ret == -ENOMEM) {\n             ret = DNS_EAI_FAIL;\n             goto quit;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A DNS packet with ID 0, QD count of 1, and a missing payload."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_validate_msg in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1673"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000201",
    "vulnerability": "A malicious or malformed DNS packet without a payload can cause an out-of-bounds read, resulting in a crash (denial of service) or an incorrect computation.",
    "affected_functions": [
      "dns_write"
    ],
    "functionality": "Validates incoming DNS messages.",
    "call_patterns": [
      {
        "pattern": "dns_validate_msg(subsys/net/lib/dns/resolve.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-dispatcher_cb(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_write (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all incoming data is validated against expected formats and sizes before processing. Specifically, check that the DNS message length is sufficient for the expected fields, and validate the counts of questions and answers in the DNS header. If any validation fails, return an appropriate error code and avoid further processing of the message.",
      "code_snippet": "int dns_validate_msg(struct dns_resolve_context *ctx, struct dns_msg_t *dns_msg, uint16_t *dns_id, int *query_idx, struct dns_query_t *query, struct dns_hash_t *query_hash) {\n    int ret;\n\n    ret = dns_unpack_response_query(dns_msg);\n    if (ret < 0) {\n        if (ret == -ENOMEM) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (*dns_id > 0) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n    }\n    // ... rest of the function ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "diff --git a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c\nindex 0e28439e5ca8b..4ff74de7a07ed 100644\n--- a/subsys/net/lib/dns/resolve.c\n+++ b/subsys/net/lib/dns/resolve.c\n@@ -789,6 +789,11 @@ int dns_validate_msg(struct dns_resolve_context *ctx,\n \n     ret = dns_unpack_response_query(dns_msg);\n     if (ret < 0) {\n+        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n+            ret = DNS_EAI_FAIL;\n+            goto quit;\n+        }\n+        if (ret == -ENOMEM) {\n             ret = DNS_EAI_FAIL;\n             goto quit;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A DNS packet with ID 0, QD count of 1, and a missing payload."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_write in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1673"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000202",
    "vulnerability": "A malicious or malformed DNS packet without a payload can cause an out-of-bounds read, resulting in a crash (denial of service) or an incorrect computation.",
    "affected_functions": [
      "dns_read"
    ],
    "functionality": "Validates incoming DNS messages.",
    "call_patterns": [
      {
        "pattern": "dns_validate_msg(subsys/net/lib/dns/resolve.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-dispatcher_cb(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_read (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all incoming data is validated against expected formats and sizes before processing. Specifically, check that the DNS message length is sufficient for the expected fields, and validate the counts of questions and answers in the DNS header. If any validation fails, return an appropriate error code and avoid further processing of the message.",
      "code_snippet": "int dns_validate_msg(struct dns_resolve_context *ctx, struct dns_msg_t *dns_msg, uint16_t *dns_id, int *query_idx, struct dns_query_t *query, struct dns_hash_t *query_hash) {\n    int ret;\n\n    ret = dns_unpack_response_query(dns_msg);\n    if (ret < 0) {\n        if (ret == -ENOMEM) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (*dns_id > 0) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n    }\n    // ... rest of the function ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "diff --git a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c\nindex 0e28439e5ca8b..4ff74de7a07ed 100644\n--- a/subsys/net/lib/dns/resolve.c\n+++ b/subsys/net/lib/dns/resolve.c\n@@ -789,6 +789,11 @@ int dns_validate_msg(struct dns_resolve_context *ctx,\n \n     ret = dns_unpack_response_query(dns_msg);\n     if (ret < 0) {\n+        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n+            ret = DNS_EAI_FAIL;\n+            goto quit;\n+        }\n+        if (ret == -ENOMEM) {\n             ret = DNS_EAI_FAIL;\n             goto quit;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A DNS packet with ID 0, QD count of 1, and a missing payload."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_read in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1673"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000203",
    "vulnerability": "A malicious or malformed DNS packet without a payload can cause an out-of-bounds read, resulting in a crash (denial of service) or an incorrect computation.",
    "affected_functions": [
      "set_ttl_hop_limit"
    ],
    "functionality": "Validates incoming DNS messages.",
    "call_patterns": [
      {
        "pattern": "dns_validate_msg(subsys/net/lib/dns/resolve.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-dispatcher_cb(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to set_ttl_hop_limit (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that all incoming data is validated against expected formats and sizes before processing. Specifically, check that the DNS message length is sufficient for the expected fields, and validate the counts of questions and answers in the DNS header. If any validation fails, return an appropriate error code and avoid further processing of the message.",
      "code_snippet": "int dns_validate_msg(struct dns_resolve_context *ctx, struct dns_msg_t *dns_msg, uint16_t *dns_id, int *query_idx, struct dns_query_t *query, struct dns_hash_t *query_hash) {\n    int ret;\n\n    ret = dns_unpack_response_query(dns_msg);\n    if (ret < 0) {\n        if (ret == -ENOMEM) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n        if (*dns_id > 0) {\n            ret = DNS_EAI_FAIL;\n            goto quit;\n        }\n    }\n    // ... rest of the function ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "diff --git a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c\nindex 0e28439e5ca8b..4ff74de7a07ed 100644\n--- a/subsys/net/lib/dns/resolve.c\n+++ b/subsys/net/lib/dns/resolve.c\n@@ -789,6 +789,11 @@ int dns_validate_msg(struct dns_resolve_context *ctx,\n \n     ret = dns_unpack_response_query(dns_msg);\n     if (ret < 0) {\n+        if (dns_msg->msg_size < 12 || dns_msg->qdcount < 1) {\n+            ret = DNS_EAI_FAIL;\n+            goto quit;\n+        }\n+        if (ret == -ENOMEM) {\n             ret = DNS_EAI_FAIL;\n             goto quit;\n         }\n"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A DNS packet with ID 0, QD count of 1, and a missing payload."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using set_ttl_hop_limit in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1673"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000204",
    "vulnerability": "A lack of input validation allows for out of bounds reads caused by malicious or malformed packets.",
    "affected_functions": [
      "dns_unpack_answer"
    ],
    "functionality": "The function decodes DNS answers from incoming DNS data.",
    "call_patterns": [
      {
        "pattern": "dns_unpack_answer(subsys/net/lib/dns/dns_pack.c)<-dns_validate_msg(subsys/net/lib/dns/resolve.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-dispatcher_cb(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_unpack_answer (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "Failed to extract guideline",
      "code_snippet": "// No code snippet available",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "// No diff available"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "A lack of input validation allows for out of bounds reads caused by malicious or malformed packets."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_unpack_answer in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1674"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000205",
    "vulnerability": "The function dns_copy_qname in dns_pack.c performs a memcpy operation with an untrusted field and does not check if the source buffer is large enough to contain the copied data.",
    "affected_functions": [
      "static int dispatcher_cb(void *my_ctx, int sock,struct sockaddr *addr, size_t addrlen,struct net_buf *dns_data, size_t len)"
    ],
    "functionality": "A socket event callback function that processes incoming DNS response packets in the Zephyr operating system's DNS resolver module.",
    "call_patterns": [
      {
        "pattern": "int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,struct dns_msg_t *dns_msg, uint16_t pos)(zephyr/subsys/net/lib/dns/dns_pack.c)<-int dns_validate_msg(struct dns_resolve_context *ctx,struct dns_msg_t *dns_msg,uint16_t *dns_id,int *query_idx,struct net_buf *dns_cname,uint16_t *query_hash)(zephyr/subsys/net/lib/dns/resolve.c)<-static int dns_read(struct dns_resolve_context *ctx,struct net_buf *dns_data, size_t buf_len,uint16_t *dns_id,struct net_buf *dns_cname,uint16_t *query_hash)(zephyr/subsys/net/lib/dns/resolve.c)<-static int dispatcher_cb(void *my_ctx, int sock,struct sockaddr *addr, size_t addrlen,struct net_buf *dns_data, size_t len)(zephyr/subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_copy_qname (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v4.1.0 or above.",
      "code_snippet": "int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size, const uint8_t *msg, uint16_t msg_size, uint16_t pos) {\n    // ... other code ...\n    if (DNS_LABEL_LEN_SIZE + lb_size > MIN(size - *len, msg_size - pos)) {\n        rc = -ENOMEM;\n        break;\n    }\n    // ... other code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "if (DNS_LABEL_LEN_SIZE + lb_size > MIN(size - *len, msg_size - pos)) {\n    rc = -ENOMEM;\n    break;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The library function dns_copy_qname in dns_pack.c performs a memcpy from an untrusted DNS packet without proper bounds checking on the computed offset after processing a DNS compression pointer, allowing an out-of-bounds read when a malicious pointer redirects to a negative or invalid position."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using dns_copy_qname in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1675"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000206",
    "vulnerability": "The function dns_copy_qname in dns_pack.c performs performs a memcpy operation with an untrusted field and does not check if the source buffer is large enough to contain the copied data.",
    "affected_functions": [
      "mdns_unpack_query_header"
    ],
    "functionality": "The function copies a DNS query name from a buffer to another buffer.",
    "call_patterns": [
      {
        "pattern": "dns_copy_qname(subsys/net/lib/dns/dns_pack.c)<-dns_validate_msg(subsys/net/lib/dns/resolve.c)<-dns_read(subsys/net/lib/dns/resolve.c)<-dispatcher_cb(subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to mdns_unpack_query_header (version: v4.0.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "To fix similar vulnerabilities, ensure that both the source and destination buffers are validated before performing any memory copy operations. Always check the size of the source buffer to prevent out-of-bounds reads. Implement checks that compare the expected size of the data being copied against the actual size of the source buffer. This should be done in the context of the function's call chain to ensure that the data being passed is safe and valid.",
      "code_snippet": "int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size, const uint8_t *msg, uint16_t msg_size, uint16_t pos) {\n    // ... other code ...\n    if (DNS_LABEL_LEN_SIZE + lb_size > MIN(size - *len, msg_size - pos)) {\n        rc = -ENOMEM;\n        break;\n    }\n    // ... other code ...\n}",
      "patch_link": "https://github.com/zephyrproject-rtos/zephyr/pull/82072",
      "patch_diff": "if (DNS_LABEL_LEN_SIZE + lb_size > MIN(size - *len, msg_size - pos)) {\n    rc = -ENOMEM;\n    break;\n}"
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The vulnerability can be triggered when the source buffer is smaller than expected, leading to a memcpy operation that reads out of bounds."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mdns_unpack_query_header in vulnerable versions (v4.0.0 → v4.1.0)"
    ],
    "related_cve": [
      "CVE-2025-1675"
    ],
    "related_cwe": [
      "CWE-125"
    ],
    "vulnerable_version": "v4.0.0"
  },
  {
    "id": "VULN-000207",
    "vulnerability": "",
    "affected_functions": [
      "int dispatcher_cb(void *my_ctx, int sock,struct sockaddr *addr, size_t addrlen,struct net_buf *dns_data, size_t len)"
    ],
    "functionality": "A socket event callback function that processes incoming DNS response packets in the Zephyr operating system's DNS resolver module.",
    "call_patterns": [
      {
        "pattern": "int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,struct dns_msg_t *dns_msg, uint16_t pos)(zephyr/subsys/net/lib/dns/dns_pack.c)<-int dns_validate_msg(struct dns_resolve_context *ctx,struct dns_msg_t *dns_msg,uint16_t *dns_id,int *query_idx,struct net_buf *dns_cname,uint16_t *query_hash)(zephyr/subsys/net/lib/dns/resolve.c)<-static int dns_read(struct dns_resolve_context *ctx,struct net_buf *dns_data, size_t buf_len,uint16_t *dns_id,struct net_buf *dns_cname,uint16_t *query_hash)(zephyr/subsys/net/lib/dns/resolve.c)<-static int dispatcher_cb(void *my_ctx, int sock,struct sockaddr *addr, size_t addrlen,struct net_buf *dns_data, size_t len)(zephyr/subsys/net/lib/dns/resolve.c)",
        "description": "Vulnerable call chain leading to dns_copy_qname (version: v4.1.0)"
      }
    ],
    "fixing_pattern": {
      "guideline": "This vulnerability cannot be fixed at the application layer. Please update the repository to version v4.2.0 or above.",
      "code_snippet": "",
      "patch_link": "",
      "patch_diff": ""
    },
    "severity": "HIGH",
    "exploit_prereqs": [
      "The library function dns_copy_qname has an infinite loop vulnerability in DNS label parsing, which may be triggered when processing malicious DNS responses containing self-referential or circular compression pointers."
    ],
    "mitigations": [
      "Input validation for user-controlled parameters",
      "Apply fix from related patch",
      "Avoid using mdns_unpack_query_header in vulnerable versions (v4.1.0 → v4.2.0)"
    ],
    "related_cve": [
      "CVE-2025-2962"
    ],
    "related_cwe": [
      "CWE-835"
    ],
    "vulnerable_version": "v4.1.0"
  }
]